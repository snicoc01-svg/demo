(function (global, factory) {
    typeof exports === "object" && typeof module !== "undefined" ? factory() : typeof define === "function" && define.amd ? define(factory) : factory();
})(this, function () {
    "use strict";
    var commonjsGlobal = typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
    function createCommonjsModule(fn, module) {
        return (module = { exports: {} }), fn(module, module.exports), module.exports;
    }
    var underscoreMin = createCommonjsModule(function (module, exports) {
        (function () {
            function n(n) {
                function t(t, r, e, u, i, o) {
                    for (; i >= 0 && o > i; i += n) {
                        var a = u ? u[i] : i;
                        e = r(e, t[a], a, t);
                    }
                    return e;
                }
                return function (r, e, u, i) {
                    e = b(e, i, 4);
                    var o = !k(r) && m.keys(r),
                        a = (o || r).length,
                        c = n > 0 ? 0 : a - 1;
                    return arguments.length < 3 && ((u = r[o ? o[c] : c]), (c += n)), t(r, e, u, o, c, a);
                };
            }
            function t(n) {
                return function (t, r, e) {
                    r = x(r, e);
                    for (var u = O(t), i = n > 0 ? 0 : u - 1; i >= 0 && u > i; i += n) if (r(t[i], i, t)) return i;
                    return -1;
                };
            }
            function r(n, t, r) {
                return function (e, u, i) {
                    var o = 0,
                        a = O(e);
                    if ("number" == typeof i) n > 0 ? (o = i >= 0 ? i : Math.max(i + a, o)) : (a = i >= 0 ? Math.min(i + 1, a) : i + a + 1);
                    else if (r && i && a) return (i = r(e, u)), e[i] === u ? i : -1;
                    if (u !== u) return (i = t(l.call(e, o, a), m.isNaN)), i >= 0 ? i + o : -1;
                    for (i = n > 0 ? o : a - 1; i >= 0 && a > i; i += n) if (e[i] === u) return i;
                    return -1;
                };
            }
            function e(n, t) {
                var r = I.length,
                    e = n.constructor,
                    u = (m.isFunction(e) && e.prototype) || a,
                    i = "constructor";
                for (m.has(n, i) && !m.contains(t, i) && t.push(i); r--;) (i = I[r]), i in n && n[i] !== u[i] && !m.contains(t, i) && t.push(i);
            }
            var u = this,
                i = u._,
                o = Array.prototype,
                a = Object.prototype,
                c = Function.prototype,
                f = o.push,
                l = o.slice,
                s = a.toString,
                p = a.hasOwnProperty,
                h = Array.isArray,
                v = Object.keys,
                g = c.bind,
                y = Object.create,
                d = function () { },
                m = function (n) {
                    return n instanceof m ? n : this instanceof m ? void (this._wrapped = n) : new m(n);
                };
            "undefined" != "object" && module.exports && (exports = module.exports = m), (exports._ = m), (m.VERSION = "1.8.3");
            var b = function (n, t, r) {
                if (t === void 0) return n;
                switch (null == r ? 3 : r) {
                    case 1:
                        return function (r) {
                            return n.call(t, r);
                        };
                    case 2:
                        return function (r, e) {
                            return n.call(t, r, e);
                        };
                    case 3:
                        return function (r, e, u) {
                            return n.call(t, r, e, u);
                        };
                    case 4:
                        return function (r, e, u, i) {
                            return n.call(t, r, e, u, i);
                        };
                }
                return function () {
                    return n.apply(t, arguments);
                };
            },
                x = function (n, t, r) {
                    return null == n ? m.identity : m.isFunction(n) ? b(n, t, r) : m.isObject(n) ? m.matcher(n) : m.property(n);
                };
            m.iteratee = function (n, t) {
                return x(n, t, 1 / 0);
            };
            var _ = function (n, t) {
                return function (r) {
                    var e = arguments.length;
                    if (2 > e || null == r) return r;
                    for (var u = 1; e > u; u++)
                        for (var i = arguments[u], o = n(i), a = o.length, c = 0; a > c; c++) {
                            var f = o[c];
                            (t && r[f] !== void 0) || (r[f] = i[f]);
                        }
                    return r;
                };
            },
                j = function (n) {
                    if (!m.isObject(n)) return {};
                    if (y) return y(n);
                    d.prototype = n;
                    var t = new d();
                    return (d.prototype = null), t;
                },
                w = function (n) {
                    return function (t) {
                        return null == t ? void 0 : t[n];
                    };
                },
                A = Math.pow(2, 53) - 1,
                O = w("length"),
                k = function (n) {
                    var t = O(n);
                    return "number" == typeof t && t >= 0 && A >= t;
                };
            (m.each = m.forEach = function (n, t, r) {
                t = b(t, r);
                var e, u;
                if (k(n)) for (e = 0, u = n.length; u > e; e++) t(n[e], e, n);
                else {
                    var i = m.keys(n);
                    for (e = 0, u = i.length; u > e; e++) t(n[i[e]], i[e], n);
                }
                return n;
            }),
                (m.map = m.collect = function (n, t, r) {
                    t = x(t, r);
                    for (var e = !k(n) && m.keys(n), u = (e || n).length, i = Array(u), o = 0; u > o; o++) {
                        var a = e ? e[o] : o;
                        i[o] = t(n[a], a, n);
                    }
                    return i;
                }),
                (m.reduce = m.foldl = m.inject = n(1)),
                (m.reduceRight = m.foldr = n(-1)),
                (m.find = m.detect = function (n, t, r) {
                    var e;
                    return (e = k(n) ? m.findIndex(n, t, r) : m.findKey(n, t, r)), e !== void 0 && e !== -1 ? n[e] : void 0;
                }),
                (m.filter = m.select = function (n, t, r) {
                    var e = [];
                    return (
                        (t = x(t, r)),
                        m.each(n, function (n, r, u) {
                            t(n, r, u) && e.push(n);
                        }),
                        e
                    );
                }),
                (m.reject = function (n, t, r) {
                    return m.filter(n, m.negate(x(t)), r);
                }),
                (m.every = m.all = function (n, t, r) {
                    t = x(t, r);
                    for (var e = !k(n) && m.keys(n), u = (e || n).length, i = 0; u > i; i++) {
                        var o = e ? e[i] : i;
                        if (!t(n[o], o, n)) return !1;
                    }
                    return !0;
                }),
                (m.some = m.any = function (n, t, r) {
                    t = x(t, r);
                    for (var e = !k(n) && m.keys(n), u = (e || n).length, i = 0; u > i; i++) {
                        var o = e ? e[i] : i;
                        if (t(n[o], o, n)) return !0;
                    }
                    return !1;
                }),
                (m.contains = m.includes = m.include = function (n, t, r, e) {
                    return k(n) || (n = m.values(n)), ("number" != typeof r || e) && (r = 0), m.indexOf(n, t, r) >= 0;
                }),
                (m.invoke = function (n, t) {
                    var r = l.call(arguments, 2),
                        e = m.isFunction(t);
                    return m.map(n, function (n) {
                        var u = e ? t : n[t];
                        return null == u ? u : u.apply(n, r);
                    });
                }),
                (m.pluck = function (n, t) {
                    return m.map(n, m.property(t));
                }),
                (m.where = function (n, t) {
                    return m.filter(n, m.matcher(t));
                }),
                (m.findWhere = function (n, t) {
                    return m.find(n, m.matcher(t));
                }),
                (m.max = function (n, t, r) {
                    var e,
                        u,
                        i = -1 / 0,
                        o = -1 / 0;
                    if (null == t && null != n) {
                        n = k(n) ? n : m.values(n);
                        for (var a = 0, c = n.length; c > a; a++) (e = n[a]), e > i && (i = e);
                    } else
                        (t = x(t, r)),
                            m.each(n, function (n, r, e) {
                                (u = t(n, r, e)), (u > o || (u === -1 / 0 && i === -1 / 0)) && ((i = n), (o = u));
                            });
                    return i;
                }),
                (m.min = function (n, t, r) {
                    var e,
                        u,
                        i = 1 / 0,
                        o = 1 / 0;
                    if (null == t && null != n) {
                        n = k(n) ? n : m.values(n);
                        for (var a = 0, c = n.length; c > a; a++) (e = n[a]), i > e && (i = e);
                    } else
                        (t = x(t, r)),
                            m.each(n, function (n, r, e) {
                                (u = t(n, r, e)), (o > u || (1 / 0 === u && 1 / 0 === i)) && ((i = n), (o = u));
                            });
                    return i;
                }),
                (m.shuffle = function (n) {
                    for (var t, r = k(n) ? n : m.values(n), e = r.length, u = Array(e), i = 0; e > i; i++) (t = m.random(0, i)), t !== i && (u[i] = u[t]), (u[t] = r[i]);
                    return u;
                }),
                (m.sample = function (n, t, r) {
                    return null == t || r ? (k(n) || (n = m.values(n)), n[m.random(n.length - 1)]) : m.shuffle(n).slice(0, Math.max(0, t));
                }),
                (m.sortBy = function (n, t, r) {
                    return (
                        (t = x(t, r)),
                        m.pluck(
                            m
                                .map(n, function (n, r, e) {
                                    return { value: n, index: r, criteria: t(n, r, e) };
                                })
                                .sort(function (n, t) {
                                    var r = n.criteria,
                                        e = t.criteria;
                                    if (r !== e) {
                                        if (r > e || r === void 0) return 1;
                                        if (e > r || e === void 0) return -1;
                                    }
                                    return n.index - t.index;
                                }),
                            "value"
                        )
                    );
                });
            var F = function (n) {
                return function (t, r, e) {
                    var u = {};
                    return (
                        (r = x(r, e)),
                        m.each(t, function (e, i) {
                            var o = r(e, i, t);
                            n(u, e, o);
                        }),
                        u
                    );
                };
            };
            (m.groupBy = F(function (n, t, r) {
                m.has(n, r) ? n[r].push(t) : (n[r] = [t]);
            })),
                (m.indexBy = F(function (n, t, r) {
                    n[r] = t;
                })),
                (m.countBy = F(function (n, t, r) {
                    m.has(n, r) ? n[r]++ : (n[r] = 1);
                })),
                (m.toArray = function (n) {
                    return n ? (m.isArray(n) ? l.call(n) : k(n) ? m.map(n, m.identity) : m.values(n)) : [];
                }),
                (m.size = function (n) {
                    return null == n ? 0 : k(n) ? n.length : m.keys(n).length;
                }),
                (m.partition = function (n, t, r) {
                    t = x(t, r);
                    var e = [],
                        u = [];
                    return (
                        m.each(n, function (n, r, i) {
                            (t(n, r, i) ? e : u).push(n);
                        }),
                        [e, u]
                    );
                }),
                (m.first = m.head = m.take = function (n, t, r) {
                    return null == n ? void 0 : null == t || r ? n[0] : m.initial(n, n.length - t);
                }),
                (m.initial = function (n, t, r) {
                    return l.call(n, 0, Math.max(0, n.length - (null == t || r ? 1 : t)));
                }),
                (m.last = function (n, t, r) {
                    return null == n ? void 0 : null == t || r ? n[n.length - 1] : m.rest(n, Math.max(0, n.length - t));
                }),
                (m.rest = m.tail = m.drop = function (n, t, r) {
                    return l.call(n, null == t || r ? 1 : t);
                }),
                (m.compact = function (n) {
                    return m.filter(n, m.identity);
                });
            var S = function (n, t, r, e) {
                for (var u = [], i = 0, o = e || 0, a = O(n); a > o; o++) {
                    var c = n[o];
                    if (k(c) && (m.isArray(c) || m.isArguments(c))) {
                        t || (c = S(c, t, r));
                        var f = 0,
                            l = c.length;
                        for (u.length += l; l > f;) u[i++] = c[f++];
                    } else r || (u[i++] = c);
                }
                return u;
            };
            (m.flatten = function (n, t) {
                return S(n, t, !1);
            }),
                (m.without = function (n) {
                    return m.difference(n, l.call(arguments, 1));
                }),
                (m.uniq = m.unique = function (n, t, r, e) {
                    m.isBoolean(t) || ((e = r), (r = t), (t = !1)), null != r && (r = x(r, e));
                    for (var u = [], i = [], o = 0, a = O(n); a > o; o++) {
                        var c = n[o],
                            f = r ? r(c, o, n) : c;
                        t ? ((o && i === f) || u.push(c), (i = f)) : r ? m.contains(i, f) || (i.push(f), u.push(c)) : m.contains(u, c) || u.push(c);
                    }
                    return u;
                }),
                (m.union = function () {
                    return m.uniq(S(arguments, !0, !0));
                }),
                (m.intersection = function (n) {
                    for (var t = [], r = arguments.length, e = 0, u = O(n); u > e; e++) {
                        var i = n[e];
                        if (!m.contains(t, i)) {
                            for (var o = 1; r > o && m.contains(arguments[o], i); o++);
                            o === r && t.push(i);
                        }
                    }
                    return t;
                }),
                (m.difference = function (n) {
                    var t = S(arguments, !0, !0, 1);
                    return m.filter(n, function (n) {
                        return !m.contains(t, n);
                    });
                }),
                (m.zip = function () {
                    return m.unzip(arguments);
                }),
                (m.unzip = function (n) {
                    for (var t = (n && m.max(n, O).length) || 0, r = Array(t), e = 0; t > e; e++) r[e] = m.pluck(n, e);
                    return r;
                }),
                (m.object = function (n, t) {
                    for (var r = {}, e = 0, u = O(n); u > e; e++) t ? (r[n[e]] = t[e]) : (r[n[e][0]] = n[e][1]);
                    return r;
                }),
                (m.findIndex = t(1)),
                (m.findLastIndex = t(-1)),
                (m.sortedIndex = function (n, t, r, e) {
                    r = x(r, e, 1);
                    for (var u = r(t), i = 0, o = O(n); o > i;) {
                        var a = Math.floor((i + o) / 2);
                        r(n[a]) < u ? (i = a + 1) : (o = a);
                    }
                    return i;
                }),
                (m.indexOf = r(1, m.findIndex, m.sortedIndex)),
                (m.lastIndexOf = r(-1, m.findLastIndex)),
                (m.range = function (n, t, r) {
                    null == t && ((t = n || 0), (n = 0)), (r = r || 1);
                    for (var e = Math.max(Math.ceil((t - n) / r), 0), u = Array(e), i = 0; e > i; i++, n += r) u[i] = n;
                    return u;
                });
            var E = function (n, t, r, e, u) {
                if (!(e instanceof t)) return n.apply(r, u);
                var i = j(n.prototype),
                    o = n.apply(i, u);
                return m.isObject(o) ? o : i;
            };
            (m.bind = function (n, t) {
                if (g && n.bind === g) return g.apply(n, l.call(arguments, 1));
                if (!m.isFunction(n)) throw new TypeError("Bind must be called on a function");
                var r = l.call(arguments, 2),
                    e = function () {
                        return E(n, e, t, this, r.concat(l.call(arguments)));
                    };
                return e;
            }),
                (m.partial = function (n) {
                    var t = l.call(arguments, 1),
                        r = function () {
                            for (var e = 0, u = t.length, i = Array(u), o = 0; u > o; o++) i[o] = t[o] === m ? arguments[e++] : t[o];
                            for (; e < arguments.length;) i.push(arguments[e++]);
                            return E(n, r, this, this, i);
                        };
                    return r;
                }),
                (m.bindAll = function (n) {
                    var t,
                        r,
                        e = arguments.length;
                    if (1 >= e) throw new Error("bindAll must be passed function names");
                    for (t = 1; e > t; t++) (r = arguments[t]), (n[r] = m.bind(n[r], n));
                    return n;
                }),
                (m.memoize = function (n, t) {
                    var r = function (e) {
                        var u = r.cache,
                            i = "" + (t ? t.apply(this, arguments) : e);
                        return m.has(u, i) || (u[i] = n.apply(this, arguments)), u[i];
                    };
                    return (r.cache = {}), r;
                }),
                (m.delay = function (n, t) {
                    var r = l.call(arguments, 2);
                    return setTimeout(function () {
                        return n.apply(null, r);
                    }, t);
                }),
                (m.defer = m.partial(m.delay, m, 1)),
                (m.throttle = function (n, t, r) {
                    var e,
                        u,
                        i,
                        o = null,
                        a = 0;
                    r || (r = {});
                    var c = function () {
                        (a = r.leading === !1 ? 0 : m.now()), (o = null), (i = n.apply(e, u)), o || (e = u = null);
                    };
                    return function () {
                        var f = m.now();
                        a || r.leading !== !1 || (a = f);
                        var l = t - (f - a);
                        return (e = this), (u = arguments), 0 >= l || l > t ? (o && (clearTimeout(o), (o = null)), (a = f), (i = n.apply(e, u)), o || (e = u = null)) : o || r.trailing === !1 || (o = setTimeout(c, l)), i;
                    };
                }),
                (m.debounce = function (n, t, r) {
                    var e,
                        u,
                        i,
                        o,
                        a,
                        c = function () {
                            var f = m.now() - o;
                            t > f && f >= 0 ? (e = setTimeout(c, t - f)) : ((e = null), r || ((a = n.apply(i, u)), e || (i = u = null)));
                        };
                    return function () {
                        (i = this), (u = arguments), (o = m.now());
                        var f = r && !e;
                        return e || (e = setTimeout(c, t)), f && ((a = n.apply(i, u)), (i = u = null)), a;
                    };
                }),
                (m.wrap = function (n, t) {
                    return m.partial(t, n);
                }),
                (m.negate = function (n) {
                    return function () {
                        return !n.apply(this, arguments);
                    };
                }),
                (m.compose = function () {
                    var n = arguments,
                        t = n.length - 1;
                    return function () {
                        for (var r = t, e = n[t].apply(this, arguments); r--;) e = n[r].call(this, e);
                        return e;
                    };
                }),
                (m.after = function (n, t) {
                    return function () {
                        return --n < 1 ? t.apply(this, arguments) : void 0;
                    };
                }),
                (m.before = function (n, t) {
                    var r;
                    return function () {
                        return --n > 0 && (r = t.apply(this, arguments)), 1 >= n && (t = null), r;
                    };
                }),
                (m.once = m.partial(m.before, 2));
            var M = !{ toString: null }.propertyIsEnumerable("toString"),
                I = ["valueOf", "isPrototypeOf", "toString", "propertyIsEnumerable", "hasOwnProperty", "toLocaleString"];
            (m.keys = function (n) {
                if (!m.isObject(n)) return [];
                if (v) return v(n);
                var t = [];
                for (var r in n) m.has(n, r) && t.push(r);
                return M && e(n, t), t;
            }),
                (m.allKeys = function (n) {
                    if (!m.isObject(n)) return [];
                    var t = [];
                    for (var r in n) t.push(r);
                    return M && e(n, t), t;
                }),
                (m.values = function (n) {
                    for (var t = m.keys(n), r = t.length, e = Array(r), u = 0; r > u; u++) e[u] = n[t[u]];
                    return e;
                }),
                (m.mapObject = function (n, t, r) {
                    t = x(t, r);
                    for (var e, u = m.keys(n), i = u.length, o = {}, a = 0; i > a; a++) (e = u[a]), (o[e] = t(n[e], e, n));
                    return o;
                }),
                (m.pairs = function (n) {
                    for (var t = m.keys(n), r = t.length, e = Array(r), u = 0; r > u; u++) e[u] = [t[u], n[t[u]]];
                    return e;
                }),
                (m.invert = function (n) {
                    for (var t = {}, r = m.keys(n), e = 0, u = r.length; u > e; e++) t[n[r[e]]] = r[e];
                    return t;
                }),
                (m.functions = m.methods = function (n) {
                    var t = [];
                    for (var r in n) m.isFunction(n[r]) && t.push(r);
                    return t.sort();
                }),
                (m.extend = _(m.allKeys)),
                (m.extendOwn = m.assign = _(m.keys)),
                (m.findKey = function (n, t, r) {
                    t = x(t, r);
                    for (var e, u = m.keys(n), i = 0, o = u.length; o > i; i++) if (((e = u[i]), t(n[e], e, n))) return e;
                }),
                (m.pick = function (n, t, r) {
                    var e,
                        u,
                        i = {},
                        o = n;
                    if (null == o) return i;
                    m.isFunction(t)
                        ? ((u = m.allKeys(o)), (e = b(t, r)))
                        : ((u = S(arguments, !1, !1, 1)),
                            (e = function (n, t, r) {
                                return t in r;
                            }),
                            (o = Object(o)));
                    for (var a = 0, c = u.length; c > a; a++) {
                        var f = u[a],
                            l = o[f];
                        e(l, f, o) && (i[f] = l);
                    }
                    return i;
                }),
                (m.omit = function (n, t, r) {
                    if (m.isFunction(t)) t = m.negate(t);
                    else {
                        var e = m.map(S(arguments, !1, !1, 1), String);
                        t = function (n, t) {
                            return !m.contains(e, t);
                        };
                    }
                    return m.pick(n, t, r);
                }),
                (m.defaults = _(m.allKeys, !0)),
                (m.create = function (n, t) {
                    var r = j(n);
                    return t && m.extendOwn(r, t), r;
                }),
                (m.clone = function (n) {
                    return m.isObject(n) ? (m.isArray(n) ? n.slice() : m.extend({}, n)) : n;
                }),
                (m.tap = function (n, t) {
                    return t(n), n;
                }),
                (m.isMatch = function (n, t) {
                    var r = m.keys(t),
                        e = r.length;
                    if (null == n) return !e;
                    for (var u = Object(n), i = 0; e > i; i++) {
                        var o = r[i];
                        if (t[o] !== u[o] || !(o in u)) return !1;
                    }
                    return !0;
                });
            var N = function (n, t, r, e) {
                if (n === t) return 0 !== n || 1 / n === 1 / t;
                if (null == n || null == t) return n === t;
                n instanceof m && (n = n._wrapped), t instanceof m && (t = t._wrapped);
                var u = s.call(n);
                if (u !== s.call(t)) return !1;
                switch (u) {
                    case "[object RegExp]":
                    case "[object String]":
                        return "" + n == "" + t;
                    case "[object Number]":
                        return +n !== +n ? +t !== +t : 0 === +n ? 1 / +n === 1 / t : +n === +t;
                    case "[object Date]":
                    case "[object Boolean]":
                        return +n === +t;
                }
                var i = "[object Array]" === u;
                if (!i) {
                    if ("object" != typeof n || "object" != typeof t) return !1;
                    var o = n.constructor,
                        a = t.constructor;
                    if (o !== a && !(m.isFunction(o) && o instanceof o && m.isFunction(a) && a instanceof a) && "constructor" in n && "constructor" in t) return !1;
                }
                (r = r || []), (e = e || []);
                for (var c = r.length; c--;) if (r[c] === n) return e[c] === t;
                if ((r.push(n), e.push(t), i)) {
                    if (((c = n.length), c !== t.length)) return !1;
                    for (; c--;) if (!N(n[c], t[c], r, e)) return !1;
                } else {
                    var f,
                        l = m.keys(n);
                    if (((c = l.length), m.keys(t).length !== c)) return !1;
                    for (; c--;) if (((f = l[c]), !m.has(t, f) || !N(n[f], t[f], r, e))) return !1;
                }
                return r.pop(), e.pop(), !0;
            };
            (m.isEqual = function (n, t) {
                return N(n, t);
            }),
                (m.isEmpty = function (n) {
                    return null == n ? !0 : k(n) && (m.isArray(n) || m.isString(n) || m.isArguments(n)) ? 0 === n.length : 0 === m.keys(n).length;
                }),
                (m.isElement = function (n) {
                    return !(!n || 1 !== n.nodeType);
                }),
                (m.isArray =
                    h ||
                    function (n) {
                        return "[object Array]" === s.call(n);
                    }),
                (m.isObject = function (n) {
                    var t = typeof n;
                    return "function" === t || ("object" === t && !!n);
                }),
                m.each(["Arguments", "Function", "String", "Number", "Date", "RegExp", "Error"], function (n) {
                    m["is" + n] = function (t) {
                        return s.call(t) === "[object " + n + "]";
                    };
                }),
                m.isArguments(arguments) ||
                (m.isArguments = function (n) {
                    return m.has(n, "callee");
                }),
                "function" != typeof /./ &&
                "object" != typeof Int8Array &&
                (m.isFunction = function (n) {
                    return "function" == typeof n || !1;
                }),
                (m.isFinite = function (n) {
                    return isFinite(n) && !isNaN(parseFloat(n));
                }),
                (m.isNaN = function (n) {
                    return m.isNumber(n) && n !== +n;
                }),
                (m.isBoolean = function (n) {
                    return n === !0 || n === !1 || "[object Boolean]" === s.call(n);
                }),
                (m.isNull = function (n) {
                    return null === n;
                }),
                (m.isUndefined = function (n) {
                    return n === void 0;
                }),
                (m.has = function (n, t) {
                    return null != n && p.call(n, t);
                }),
                (m.noConflict = function () {
                    return (u._ = i), this;
                }),
                (m.identity = function (n) {
                    return n;
                }),
                (m.constant = function (n) {
                    return function () {
                        return n;
                    };
                }),
                (m.noop = function () { }),
                (m.property = w),
                (m.propertyOf = function (n) {
                    return null == n
                        ? function () { }
                        : function (t) {
                            return n[t];
                        };
                }),
                (m.matcher = m.matches = function (n) {
                    return (
                        (n = m.extendOwn({}, n)),
                        function (t) {
                            return m.isMatch(t, n);
                        }
                    );
                }),
                (m.times = function (n, t, r) {
                    var e = Array(Math.max(0, n));
                    t = b(t, r, 1);
                    for (var u = 0; n > u; u++) e[u] = t(u);
                    return e;
                }),
                (m.random = function (n, t) {
                    return null == t && ((t = n), (n = 0)), n + Math.floor(Math.random() * (t - n + 1));
                }),
                (m.now =
                    Date.now ||
                    function () {
                        return new Date().getTime();
                    });
            var B = { "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#x27;", "`": "&#x60;" },
                T = m.invert(B),
                R = function (n) {
                    var t = function (t) {
                        return n[t];
                    },
                        r = "(?:" + m.keys(n).join("|") + ")",
                        e = RegExp(r),
                        u = RegExp(r, "g");
                    return function (n) {
                        return (n = null == n ? "" : "" + n), e.test(n) ? n.replace(u, t) : n;
                    };
                };
            (m.escape = R(B)),
                (m.unescape = R(T)),
                (m.result = function (n, t, r) {
                    var e = null == n ? void 0 : n[t];
                    return e === void 0 && (e = r), m.isFunction(e) ? e.call(n) : e;
                });
            var q = 0;
            (m.uniqueId = function (n) {
                var t = ++q + "";
                return n ? n + t : t;
            }),
                (m.templateSettings = { evaluate: /<%([\s\S]+?)%>/g, interpolate: /<%=([\s\S]+?)%>/g, escape: /<%-([\s\S]+?)%>/g });
            var K = /(.)^/,
                z = { "'": "'", "\\": "\\", "\r": "r", "\n": "n", "\u2028": "u2028", "\u2029": "u2029" },
                D = /\\|'|\r|\n|\u2028|\u2029/g,
                L = function (n) {
                    return "\\" + z[n];
                };
            (m.template = function (n, t, r) {
                !t && r && (t = r), (t = m.defaults({}, t, m.templateSettings));
                var e = RegExp([(t.escape || K).source, (t.interpolate || K).source, (t.evaluate || K).source].join("|") + "|$", "g"),
                    u = 0,
                    i = "__p+='";
                n.replace(e, function (t, r, e, o, a) {
                    return (
                        (i += n.slice(u, a).replace(D, L)), (u = a + t.length), r ? (i += "'+\n((__t=(" + r + "))==null?'':_.escape(__t))+\n'") : e ? (i += "'+\n((__t=(" + e + "))==null?'':__t)+\n'") : o && (i += "';\n" + o + "\n__p+='"), t
                    );
                }),
                    (i += "';\n"),
                    t.variable || (i = "with(obj||{}){\n" + i + "}\n"),
                    (i = "var __t,__p='',__j=Array.prototype.join," + "print=function(){__p+=__j.call(arguments,'');};\n" + i + "return __p;\n");
                try {
                    var o = new Function(t.variable || "obj", "_", i);
                } catch (a) {
                    throw ((a.source = i), a);
                }
                var c = function (n) {
                    return o.call(this, n, m);
                },
                    f = t.variable || "obj";
                return (c.source = "function(" + f + "){\n" + i + "}"), c;
            }),
                (m.chain = function (n) {
                    var t = m(n);
                    return (t._chain = !0), t;
                });
            var P = function (n, t) {
                return n._chain ? m(t).chain() : t;
            };
            (m.mixin = function (n) {
                m.each(m.functions(n), function (t) {
                    var r = (m[t] = n[t]);
                    m.prototype[t] = function () {
                        var n = [this._wrapped];
                        return f.apply(n, arguments), P(this, r.apply(m, n));
                    };
                });
            }),
                m.mixin(m),
                m.each(["pop", "push", "reverse", "shift", "sort", "splice", "unshift"], function (n) {
                    var t = o[n];
                    m.prototype[n] = function () {
                        var r = this._wrapped;
                        return t.apply(r, arguments), ("shift" !== n && "splice" !== n) || 0 !== r.length || delete r[0], P(this, r);
                    };
                }),
                m.each(["concat", "join", "slice"], function (n) {
                    var t = o[n];
                    m.prototype[n] = function () {
                        return P(this, t.apply(this._wrapped, arguments));
                    };
                }),
                (m.prototype.value = function () {
                    return this._wrapped;
                }),
                (m.prototype.valueOf = m.prototype.toJSON = m.prototype.value),
                (m.prototype.toString = function () {
                    return "" + this._wrapped;
                }),
                "function" == typeof undefined &&
                undefined.amd &&
                undefined("underscore", [], function () {
                    return m;
                });
        }.call(commonjsGlobal));
    });
    (function () {
        var lastTime = 0;
        var vendors = ["ms", "moz", "webkit", "o"];
        for (var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
            window.requestAnimationFrame = window[vendors[x] + "RequestAnimationFrame"];
            window.cancelAnimationFrame = window[vendors[x] + "CancelAnimationFrame"] || window[vendors[x] + "CancelRequestAnimationFrame"];
        }
        if (!window.requestAnimationFrame)
            window.requestAnimationFrame = function (callback, element) {
                var currTime = +new Date();
                var timeToCall = Math.max(0, 16 - (currTime - lastTime));
                lastTime = currTime + timeToCall;
                return window.setTimeout(function () {
                    callback(currTime + timeToCall);
                }, timeToCall);
            };
        if (!window.cancelAnimationFrame)
            window.cancelAnimationFrame = function (id) {
                clearTimeout(id);
            };
    })();
    if (Number.EPSILON === undefined) {
        Number.EPSILON = Math.pow(2, -52);
    }
    if (Math.sign === undefined) {
        Math.sign = function (x) {
            return x < 0 ? -1 : x > 0 ? 1 : +x;
        };
    }
    if (Function.prototype.name === undefined) {
        Object.defineProperty(Function.prototype, "name", {
            get: function () {
                return this.toString().match(/^\s*function\s*([^\(\s]*)/)[1];
            },
        });
    }
    if (Object.assign === undefined) {
        (function () {
            Object.assign = function (target) {
                "use strict";
                if (target === undefined || target === null) {
                    throw new TypeError("Cannot convert undefined or null to object");
                }
                var output = Object(target);
                for (var index = 1; index < arguments.length; index++) {
                    var source = arguments[index];
                    if (source !== undefined && source !== null) {
                        for (var nextKey in source) {
                            if (Object.prototype.hasOwnProperty.call(source, nextKey)) {
                                output[nextKey] = source[nextKey];
                            }
                        }
                    }
                }
                return output;
            };
        })();
    }
    window.AudioContext = window.AudioContext || window.webkitAudioContext;
    navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia;
    Array.prototype.getMax =
        Array.prototype.getMax ||
        function () {
            return Math.max.apply(null, this);
        };
    if (Math.rotate === undefined) {
        Math.rotate = function (radius, angle) {
            return { x: radius * Math.cos(angle), y: radius * Math.sin(angle) };
        };
    }
    $.extend({
        shuffle: function (a) {
            for (var j, x, i = a.length; i; j = Math.floor(Math.random() * i), x = a[--i], a[i] = a[j], a[j] = x);
            return a;
        },
        openPopup: function (url, title, w, h) {
            var left = screen.width * 0.5 - w * 0.5,
                top = screen.height * 0.5 - h * 0.5;
            var popup = window.open(url, title, "toolbar=no, location=no, directories=no, status=no, menubar=no, scrollbars=no, resizable=no, copyhistory=no, width=" + w + ", height=" + h + ", top=" + top + ", left=" + left);
            return popup;
        },
        share: function (info, mobile) {
            if (!info) return;
            var sharer,
                socialType = info.social || null,
                url = info.url || window.location.href,
                img = info.img || null,
                label = info.label || "",
                description = info.description || "";
            switch (socialType.toLowerCase()) {
                case "fb":
                    sharer = "https://" + (mobile ? "m" : "www") + ".facebook.com/sharer.php?u=" + encodeURIComponent(url);
                    break;
                case "gp":
                    sharer = "https://plus.google.com/share?url=" + url;
                    break;
                case "tw":
                    sharer = "https://twitter.com/intent/tweet?text=" + (description + " " + url);
                    break;
                case "pi":
                    sharer = "https://pinterest.com/pin/create/button/?url=" + url + "&media=" + imgPath + "&description=" + label;
                    break;
                case "tu":
                    sharer = "https://www.tumblr.com/share/link/?url=" + encodeURIComponent(url) + "&name=" + label + "&description=" + encodeURIComponent(description);
                    break;
            }
            $.openPopup(sharer, "", 540, 360);
        },
        isChrome: function () {
            var test = false,
                isChromium = window.chrome,
                winNav = window.navigator,
                vendorName = winNav.vendor,
                isOpera = winNav.userAgent.indexOf("OPR") > -1,
                isIEedge = winNav.userAgent.indexOf("Edge") > -1,
                isIOSChrome = winNav.userAgent.match("CriOS");
            if (isIOSChrome) {
            } else if (isChromium !== null && isChromium !== undefined && vendorName === "Google Inc." && isOpera == false && isIEedge == false) {
                test = true;
            } else {
            }
            return test;
        },
    });
    $.fn.extend({
        splitRows: function () {
            return this.each(function () {
                if (this.length < 1) return;
                var text = $(this).find("span").text(),
                    html = $(this).find("span").html(),
                    font = $(this).find("span").attr("class"),
                    rows = html.split("<br>"),
                    $row,
                    $span,
                    store = [];
                $(this).data({ text: text }).empty();
                underscoreMin.each(
                    rows,
                    underscoreMin.bind(function (row) {
                        $row = $('<span class="row" />');
                        $span = $("<span />").addClass(font).text(row).css({ position: "relative", display: "inline-block" });
                        $row.append($span);
                        store.push($span);
                        $(this).append($row).append("<br>").data({ store: store });
                    }, this)
                );
            });
        },
        splitLetters: function () {
            return this.each(function () {
                if (this.length < 1) return;
                var text = $(this).find("span").text(),
                    html = $(this).find("span").html(),
                    font = $(this).find("span").attr("class"),
                    rows = html.split("<br>"),
                    letter,
                    display,
                    $row,
                    $span,
                    store = [];
                $(this).data({ text: text }).empty();
                underscoreMin.each(
                    rows,
                    underscoreMin.bind(function (row) {
                        $row = $('<span class="row" />');
                        for (var i = 0; i < row.length; ++i) {
                            letter = row.substr(i, 1);
                            (display = letter == " " ? "inline" : "inline-block"), ($span = $('<span class="sl" />').addClass(font).text(letter).css({ position: "relative", display: display }));
                            $row.append($span);
                            store.push($span);
                        }
                        $(this).append($row).append("<br>").data({ store: store });
                    }, this)
                );
            });
        },
    });
    (function (window) {
        "use strict";
        function minErr(module, ErrorConstructor) {
            ErrorConstructor = ErrorConstructor || Error;
            return function () {
                var code = arguments[0],
                    template = arguments[1],
                    message = "[" + (module ? module + ":" : "") + code + "] ",
                    templateArgs = sliceArgs(arguments, 2).map(function (arg) {
                        return toDebugString(arg, minErrConfig.objectMaxDepth);
                    }),
                    paramPrefix,
                    i;
                message += template.replace(/\{\d+\}/g, function (match) {
                    var index = +match.slice(1, -1);
                    if (index < templateArgs.length) {
                        return templateArgs[index];
                    }
                    return match;
                });
                message += "\nhttp://errors.angularjs.org/1.6.4/" + (module ? module + "/" : "") + code;
                for (i = 0, paramPrefix = "?"; i < templateArgs.length; i++, paramPrefix = "&") {
                    message += paramPrefix + "p" + i + "=" + encodeURIComponent(templateArgs[i]);
                }
                return new ErrorConstructor(message);
            };
        }
        var REGEX_STRING_REGEXP = /^\/(.+)\/([a-z]*)$/;
        var VALIDITY_STATE_PROPERTY = "validity";
        var hasOwnProperty = Object.prototype.hasOwnProperty;
        var minErrConfig = { objectMaxDepth: 5 };
        function errorHandlingConfig(config) {
            if (isObject(config)) {
                if (isDefined(config.objectMaxDepth)) {
                    minErrConfig.objectMaxDepth = isValidObjectMaxDepth(config.objectMaxDepth) ? config.objectMaxDepth : NaN;
                }
            } else {
                return minErrConfig;
            }
        }
        function isValidObjectMaxDepth(maxDepth) {
            return isNumber(maxDepth) && maxDepth > 0;
        }
        var lowercase = function (string) {
            return isString(string) ? string.toLowerCase() : string;
        };
        var uppercase = function (string) {
            return isString(string) ? string.toUpperCase() : string;
        };
        var manualLowercase = function (s) {
            return isString(s)
                ? s.replace(/[A-Z]/g, function (ch) {
                    return String.fromCharCode(ch.charCodeAt(0) | 32);
                })
                : s;
        };
        var manualUppercase = function (s) {
            return isString(s)
                ? s.replace(/[a-z]/g, function (ch) {
                    return String.fromCharCode(ch.charCodeAt(0) & ~32);
                })
                : s;
        };
        if ("i" !== "I".toLowerCase()) {
            lowercase = manualLowercase;
            uppercase = manualUppercase;
        }
        var msie,
            jqLite,
            jQuery,
            slice = [].slice,
            splice = [].splice,
            push = [].push,
            toString = Object.prototype.toString,
            getPrototypeOf = Object.getPrototypeOf,
            ngMinErr = minErr("ng"),
            angular = window.angular || (window.angular = {}),
            angularModule,
            uid = 0;
        msie = window.document.documentMode;
        function isArrayLike(obj) {
            if (obj == null || isWindow(obj)) return false;
            if (isArray(obj) || isString(obj) || (jqLite && obj instanceof jqLite)) return true;
            var length = "length" in Object(obj) && obj.length;
            return isNumber(length) && ((length >= 0 && (length - 1 in obj || obj instanceof Array)) || typeof obj.item === "function");
        }
        function forEach(obj, iterator, context) {
            var key, length;
            if (obj) {
                if (isFunction(obj)) {
                    for (key in obj) {
                        if (key !== "prototype" && key !== "length" && key !== "name" && obj.hasOwnProperty(key)) {
                            iterator.call(context, obj[key], key, obj);
                        }
                    }
                } else if (isArray(obj) || isArrayLike(obj)) {
                    var isPrimitive = typeof obj !== "object";
                    for (key = 0, length = obj.length; key < length; key++) {
                        if (isPrimitive || key in obj) {
                            iterator.call(context, obj[key], key, obj);
                        }
                    }
                } else if (obj.forEach && obj.forEach !== forEach) {
                    obj.forEach(iterator, context, obj);
                } else if (isBlankObject(obj)) {
                    for (key in obj) {
                        iterator.call(context, obj[key], key, obj);
                    }
                } else if (typeof obj.hasOwnProperty === "function") {
                    for (key in obj) {
                        if (obj.hasOwnProperty(key)) {
                            iterator.call(context, obj[key], key, obj);
                        }
                    }
                } else {
                    for (key in obj) {
                        if (hasOwnProperty.call(obj, key)) {
                            iterator.call(context, obj[key], key, obj);
                        }
                    }
                }
            }
            return obj;
        }
        function forEachSorted(obj, iterator, context) {
            var keys = Object.keys(obj).sort();
            for (var i = 0; i < keys.length; i++) {
                iterator.call(context, obj[keys[i]], keys[i]);
            }
            return keys;
        }
        function reverseParams(iteratorFn) {
            return function (value, key) {
                iteratorFn(key, value);
            };
        }
        function nextUid() {
            return ++uid;
        }
        function setHashKey(obj, h) {
            if (h) {
                obj.$$hashKey = h;
            } else {
                delete obj.$$hashKey;
            }
        }
        function baseExtend(dst, objs, deep) {
            var h = dst.$$hashKey;
            for (var i = 0, ii = objs.length; i < ii; ++i) {
                var obj = objs[i];
                if (!isObject(obj) && !isFunction(obj)) continue;
                var keys = Object.keys(obj);
                for (var j = 0, jj = keys.length; j < jj; j++) {
                    var key = keys[j];
                    var src = obj[key];
                    if (deep && isObject(src)) {
                        if (isDate(src)) {
                            dst[key] = new Date(src.valueOf());
                        } else if (isRegExp(src)) {
                            dst[key] = new RegExp(src);
                        } else if (src.nodeName) {
                            dst[key] = src.cloneNode(true);
                        } else if (isElement(src)) {
                            dst[key] = src.clone();
                        } else {
                            if (!isObject(dst[key])) dst[key] = isArray(src) ? [] : {};
                            baseExtend(dst[key], [src], true);
                        }
                    } else {
                        dst[key] = src;
                    }
                }
            }
            setHashKey(dst, h);
            return dst;
        }
        function extend(dst) {
            return baseExtend(dst, slice.call(arguments, 1), false);
        }
        function merge(dst) {
            return baseExtend(dst, slice.call(arguments, 1), true);
        }
        function toInt(str) {
            return parseInt(str, 10);
        }
        var isNumberNaN =
            Number.isNaN ||
            function isNumberNaN(num) {
                return num !== num;
            };
        function inherit(parent, extra) {
            return extend(Object.create(parent), extra);
        }
        function noop() { }
        noop.$inject = [];
        function identity($) {
            return $;
        }
        identity.$inject = [];
        function valueFn(value) {
            return function valueRef() {
                return value;
            };
        }
        function hasCustomToString(obj) {
            return isFunction(obj.toString) && obj.toString !== toString;
        }
        function isUndefined(value) {
            return typeof value === "undefined";
        }
        function isDefined(value) {
            return typeof value !== "undefined";
        }
        function isObject(value) {
            return value !== null && typeof value === "object";
        }
        function isBlankObject(value) {
            return value !== null && typeof value === "object" && !getPrototypeOf(value);
        }
        function isString(value) {
            return typeof value === "string";
        }
        function isNumber(value) {
            return typeof value === "number";
        }
        function isDate(value) {
            return toString.call(value) === "[object Date]";
        }
        var isArray = Array.isArray;
        function isFunction(value) {
            return typeof value === "function";
        }
        function isRegExp(value) {
            return toString.call(value) === "[object RegExp]";
        }
        function isWindow(obj) {
            return obj && obj.window === obj;
        }
        function isScope(obj) {
            return obj && obj.$evalAsync && obj.$watch;
        }
        function isFile(obj) {
            return toString.call(obj) === "[object File]";
        }
        function isFormData(obj) {
            return toString.call(obj) === "[object FormData]";
        }
        function isBlob(obj) {
            return toString.call(obj) === "[object Blob]";
        }
        function isBoolean(value) {
            return typeof value === "boolean";
        }
        function isPromiseLike(obj) {
            return obj && isFunction(obj.then);
        }
        var TYPED_ARRAY_REGEXP = /^\[object (?:Uint8|Uint8Clamped|Uint16|Uint32|Int8|Int16|Int32|Float32|Float64)Array]$/;
        function isTypedArray(value) {
            return value && isNumber(value.length) && TYPED_ARRAY_REGEXP.test(toString.call(value));
        }
        function isArrayBuffer(obj) {
            return toString.call(obj) === "[object ArrayBuffer]";
        }
        var trim = function (value) {
            return isString(value) ? value.trim() : value;
        };
        var escapeForRegexp = function (s) {
            return s.replace(/([-()[\]{}+?*.$^|,:#<!\\])/g, "\\$1").replace(/\x08/g, "\\x08");
        };
        function isElement(node) {
            return !!(node && (node.nodeName || (node.prop && node.attr && node.find)));
        }
        function makeMap(str) {
            var obj = {},
                items = str.split(","),
                i;
            for (i = 0; i < items.length; i++) {
                obj[items[i]] = true;
            }
            return obj;
        }
        function nodeName_(element) {
            return lowercase(element.nodeName || (element[0] && element[0].nodeName));
        }
        function includes(array, obj) {
            return Array.prototype.indexOf.call(array, obj) !== -1;
        }
        function arrayRemove(array, value) {
            var index = array.indexOf(value);
            if (index >= 0) {
                array.splice(index, 1);
            }
            return index;
        }
        function copy(source, destination, maxDepth) {
            var stackSource = [];
            var stackDest = [];
            maxDepth = isValidObjectMaxDepth(maxDepth) ? maxDepth : NaN;
            if (destination) {
                if (isTypedArray(destination) || isArrayBuffer(destination)) {
                    throw ngMinErr("cpta", "Can't copy! TypedArray destination cannot be mutated.");
                }
                if (source === destination) {
                    throw ngMinErr("cpi", "Can't copy! Source and destination are identical.");
                }
                if (isArray(destination)) {
                    destination.length = 0;
                } else {
                    forEach(destination, function (value, key) {
                        if (key !== "$$hashKey") {
                            delete destination[key];
                        }
                    });
                }
                stackSource.push(source);
                stackDest.push(destination);
                return copyRecurse(source, destination, maxDepth);
            }
            return copyElement(source, maxDepth);
            function copyRecurse(source, destination, maxDepth) {
                maxDepth--;
                if (maxDepth < 0) {
                    return "...";
                }
                var h = destination.$$hashKey;
                var key;
                if (isArray(source)) {
                    for (var i = 0, ii = source.length; i < ii; i++) {
                        destination.push(copyElement(source[i], maxDepth));
                    }
                } else if (isBlankObject(source)) {
                    for (key in source) {
                        destination[key] = copyElement(source[key], maxDepth);
                    }
                } else if (source && typeof source.hasOwnProperty === "function") {
                    for (key in source) {
                        if (source.hasOwnProperty(key)) {
                            destination[key] = copyElement(source[key], maxDepth);
                        }
                    }
                } else {
                    for (key in source) {
                        if (hasOwnProperty.call(source, key)) {
                            destination[key] = copyElement(source[key], maxDepth);
                        }
                    }
                }
                setHashKey(destination, h);
                return destination;
            }
            function copyElement(source, maxDepth) {
                if (!isObject(source)) {
                    return source;
                }
                var index = stackSource.indexOf(source);
                if (index !== -1) {
                    return stackDest[index];
                }
                if (isWindow(source) || isScope(source)) {
                    throw ngMinErr("cpws", "Can't copy! Making copies of Window or Scope instances is not supported.");
                }
                var needsRecurse = false;
                var destination = copyType(source);
                if (destination === undefined) {
                    destination = isArray(source) ? [] : Object.create(getPrototypeOf(source));
                    needsRecurse = true;
                }
                stackSource.push(source);
                stackDest.push(destination);
                return needsRecurse ? copyRecurse(source, destination, maxDepth) : destination;
            }
            function copyType(source) {
                switch (toString.call(source)) {
                    case "[object Int8Array]":
                    case "[object Int16Array]":
                    case "[object Int32Array]":
                    case "[object Float32Array]":
                    case "[object Float64Array]":
                    case "[object Uint8Array]":
                    case "[object Uint8ClampedArray]":
                    case "[object Uint16Array]":
                    case "[object Uint32Array]":
                        return new source.constructor(copyElement(source.buffer), source.byteOffset, source.length);
                    case "[object ArrayBuffer]":
                        if (!source.slice) {
                            var copied = new ArrayBuffer(source.byteLength);
                            new Uint8Array(copied).set(new Uint8Array(source));
                            return copied;
                        }
                        return source.slice(0);
                    case "[object Boolean]":
                    case "[object Number]":
                    case "[object String]":
                    case "[object Date]":
                        return new source.constructor(source.valueOf());
                    case "[object RegExp]":
                        var re = new RegExp(source.source, source.toString().match(/[^\/]*$/)[0]);
                        re.lastIndex = source.lastIndex;
                        return re;
                    case "[object Blob]":
                        return new source.constructor([source], { type: source.type });
                }
                if (isFunction(source.cloneNode)) {
                    return source.cloneNode(true);
                }
            }
        }
        function simpleCompare(a, b) {
            return a === b || (a !== a && b !== b);
        }
        function equals(o1, o2) {
            if (o1 === o2) return true;
            if (o1 === null || o2 === null) return false;
            if (o1 !== o1 && o2 !== o2) return true;
            var t1 = typeof o1,
                t2 = typeof o2,
                length,
                key,
                keySet;
            if (t1 === t2 && t1 === "object") {
                if (isArray(o1)) {
                    if (!isArray(o2)) return false;
                    if ((length = o1.length) === o2.length) {
                        for (key = 0; key < length; key++) {
                            if (!equals(o1[key], o2[key])) return false;
                        }
                        return true;
                    }
                } else if (isDate(o1)) {
                    if (!isDate(o2)) return false;
                    return simpleCompare(o1.getTime(), o2.getTime());
                } else if (isRegExp(o1)) {
                    if (!isRegExp(o2)) return false;
                    return o1.toString() === o2.toString();
                } else {
                    if (isScope(o1) || isScope(o2) || isWindow(o1) || isWindow(o2) || isArray(o2) || isDate(o2) || isRegExp(o2)) return false;
                    keySet = createMap();
                    for (key in o1) {
                        if (key.charAt(0) === "$" || isFunction(o1[key])) continue;
                        if (!equals(o1[key], o2[key])) return false;
                        keySet[key] = true;
                    }
                    for (key in o2) {
                        if (!(key in keySet) && key.charAt(0) !== "$" && isDefined(o2[key]) && !isFunction(o2[key])) return false;
                    }
                    return true;
                }
            }
            return false;
        }
        var csp = function () {
            if (!isDefined(csp.rules)) {
                var ngCspElement = window.document.querySelector("[ng-csp]") || window.document.querySelector("[data-ng-csp]");
                if (ngCspElement) {
                    var ngCspAttribute = ngCspElement.getAttribute("ng-csp") || ngCspElement.getAttribute("data-ng-csp");
                    csp.rules = { noUnsafeEval: !ngCspAttribute || ngCspAttribute.indexOf("no-unsafe-eval") !== -1, noInlineStyle: !ngCspAttribute || ngCspAttribute.indexOf("no-inline-style") !== -1 };
                } else {
                    csp.rules = { noUnsafeEval: noUnsafeEval(), noInlineStyle: false };
                }
            }
            return csp.rules;
            function noUnsafeEval() {
                try {
                    new Function("");
                    return false;
                } catch (e) {
                    return true;
                }
            }
        };
        var jq = function () {
            if (isDefined(jq.name_)) return jq.name_;
            var el;
            var i,
                ii = ngAttrPrefixes.length,
                prefix,
                name;
            for (i = 0; i < ii; ++i) {
                prefix = ngAttrPrefixes[i];
                el = window.document.querySelector("[" + prefix.replace(":", "\\:") + "jq]");
                if (el) {
                    name = el.getAttribute(prefix + "jq");
                    break;
                }
            }
            return (jq.name_ = name);
        };
        function concat(array1, array2, index) {
            return array1.concat(slice.call(array2, index));
        }
        function sliceArgs(args, startIndex) {
            return slice.call(args, startIndex || 0);
        }
        function bind(self, fn) {
            var curryArgs = arguments.length > 2 ? sliceArgs(arguments, 2) : [];
            if (isFunction(fn) && !(fn instanceof RegExp)) {
                return curryArgs.length
                    ? function () {
                        return arguments.length ? fn.apply(self, concat(curryArgs, arguments, 0)) : fn.apply(self, curryArgs);
                    }
                    : function () {
                        return arguments.length ? fn.apply(self, arguments) : fn.call(self);
                    };
            } else {
                return fn;
            }
        }
        function toJsonReplacer(key, value) {
            var val = value;
            if (typeof key === "string" && key.charAt(0) === "$" && key.charAt(1) === "$") {
                val = undefined;
            } else if (isWindow(value)) {
                val = "$WINDOW";
            } else if (value && window.document === value) {
                val = "$DOCUMENT";
            } else if (isScope(value)) {
                val = "$SCOPE";
            }
            return val;
        }
        function toJson(obj, pretty) {
            if (isUndefined(obj)) return undefined;
            if (!isNumber(pretty)) {
                pretty = pretty ? 2 : null;
            }
            return JSON.stringify(obj, toJsonReplacer, pretty);
        }
        function fromJson(json) {
            return isString(json) ? JSON.parse(json) : json;
        }
        var ALL_COLONS = /:/g;
        function timezoneToOffset(timezone, fallback) {
            timezone = timezone.replace(ALL_COLONS, "");
            var requestedTimezoneOffset = Date.parse("Jan 01, 1970 00:00:00 " + timezone) / 6e4;
            return isNumberNaN(requestedTimezoneOffset) ? fallback : requestedTimezoneOffset;
        }
        function addDateMinutes(date, minutes) {
            date = new Date(date.getTime());
            date.setMinutes(date.getMinutes() + minutes);
            return date;
        }
        function convertTimezoneToLocal(date, timezone, reverse) {
            reverse = reverse ? -1 : 1;
            var dateTimezoneOffset = date.getTimezoneOffset();
            var timezoneOffset = timezoneToOffset(timezone, dateTimezoneOffset);
            return addDateMinutes(date, reverse * (timezoneOffset - dateTimezoneOffset));
        }
        function startingTag(element) {
            element = jqLite(element).clone();
            try {
                element.empty();
            } catch (e) { }
            var elemHtml = jqLite("<div>").append(element).html();
            try {
                return element[0].nodeType === NODE_TYPE_TEXT
                    ? lowercase(elemHtml)
                    : elemHtml.match(/^(<[^>]+>)/)[1].replace(/^<([\w-]+)/, function (match, nodeName) {
                        return "<" + lowercase(nodeName);
                    });
            } catch (e) {
                return lowercase(elemHtml);
            }
        }
        function tryDecodeURIComponent(value) {
            try {
                return decodeURIComponent(value);
            } catch (e) { }
        }
        function parseKeyValue(keyValue) {
            var obj = {};
            forEach((keyValue || "").split("&"), function (keyValue) {
                var splitPoint, key, val;
                if (keyValue) {
                    key = keyValue = keyValue.replace(/\+/g, "%20");
                    splitPoint = keyValue.indexOf("=");
                    if (splitPoint !== -1) {
                        key = keyValue.substring(0, splitPoint);
                        val = keyValue.substring(splitPoint + 1);
                    }
                    key = tryDecodeURIComponent(key);
                    if (isDefined(key)) {
                        val = isDefined(val) ? tryDecodeURIComponent(val) : true;
                        if (!hasOwnProperty.call(obj, key)) {
                            obj[key] = val;
                        } else if (isArray(obj[key])) {
                            obj[key].push(val);
                        } else {
                            obj[key] = [obj[key], val];
                        }
                    }
                }
            });
            return obj;
        }
        function toKeyValue(obj) {
            var parts = [];
            forEach(obj, function (value, key) {
                if (isArray(value)) {
                    forEach(value, function (arrayValue) {
                        parts.push(encodeUriQuery(key, true) + (arrayValue === true ? "" : "=" + encodeUriQuery(arrayValue, true)));
                    });
                } else {
                    parts.push(encodeUriQuery(key, true) + (value === true ? "" : "=" + encodeUriQuery(value, true)));
                }
            });
            return parts.length ? parts.join("&") : "";
        }
        function encodeUriSegment(val) {
            return encodeUriQuery(val, true).replace(/%26/gi, "&").replace(/%3D/gi, "=").replace(/%2B/gi, "+");
        }
        function encodeUriQuery(val, pctEncodeSpaces) {
            return encodeURIComponent(val)
                .replace(/%40/gi, "@")
                .replace(/%3A/gi, ":")
                .replace(/%24/g, "$")
                .replace(/%2C/gi, ",")
                .replace(/%3B/gi, ";")
                .replace(/%20/g, pctEncodeSpaces ? "%20" : "+");
        }
        var ngAttrPrefixes = ["ng-", "data-ng-", "ng:", "x-ng-"];
        function getNgAttribute(element, ngAttr) {
            var attr,
                i,
                ii = ngAttrPrefixes.length;
            for (i = 0; i < ii; ++i) {
                attr = ngAttrPrefixes[i] + ngAttr;
                if (isString((attr = element.getAttribute(attr)))) {
                    return attr;
                }
            }
            return null;
        }
        function allowAutoBootstrap(document) {
            var script = document.currentScript;
            if (!script) {
                return true;
            }
            if (!(script instanceof window.HTMLScriptElement || script instanceof window.SVGScriptElement)) {
                return false;
            }
            var attributes = script.attributes;
            var srcs = [attributes.getNamedItem("src"), attributes.getNamedItem("href"), attributes.getNamedItem("xlink:href")];
            return srcs.every(function (src) {
                if (!src) {
                    return true;
                }
                if (!src.value) {
                    return false;
                }
                var link = document.createElement("a");
                link.href = src.value;
                if (document.location.origin === link.origin) {
                    return true;
                }
                switch (link.protocol) {
                    case "http:":
                    case "https:":
                    case "ftp:":
                    case "blob:":
                    case "file:":
                    case "data:":
                        return true;
                    default:
                        return false;
                }
            });
        }
        var isAutoBootstrapAllowed = allowAutoBootstrap(window.document);
        function angularInit(element, bootstrap) {
            var appElement,
                module,
                config = {};
            forEach(ngAttrPrefixes, function (prefix) {
                var name = prefix + "app";
                if (!appElement && element.hasAttribute && element.hasAttribute(name)) {
                    appElement = element;
                    module = element.getAttribute(name);
                }
            });
            forEach(ngAttrPrefixes, function (prefix) {
                var name = prefix + "app";
                var candidate;
                if (!appElement && (candidate = element.querySelector("[" + name.replace(":", "\\:") + "]"))) {
                    appElement = candidate;
                    module = candidate.getAttribute(name);
                }
            });
            if (appElement) {
                if (!isAutoBootstrapAllowed) {
                    window.console.error("Angular: disabling automatic bootstrap. <script> protocol indicates " + "an extension, document.location.href does not match.");
                    return;
                }
                config.strictDi = getNgAttribute(appElement, "strict-di") !== null;
                bootstrap(appElement, module ? [module] : [], config);
            }
        }
        function bootstrap(element, modules, config) {
            if (!isObject(config)) config = {};
            var defaultConfig = { strictDi: false };
            config = extend(defaultConfig, config);
            var doBootstrap = function () {
                element = jqLite(element);
                if (element.injector()) {
                    var tag = element[0] === window.document ? "document" : startingTag(element);
                    throw ngMinErr("btstrpd", "App already bootstrapped with this element '{0}'", tag.replace(/</, "&lt;").replace(/>/, "&gt;"));
                }
                modules = modules || [];
                modules.unshift([
                    "$provide",
                    function ($provide) {
                        $provide.value("$rootElement", element);
                    },
                ]);
                if (config.debugInfoEnabled) {
                    modules.push([
                        "$compileProvider",
                        function ($compileProvider) {
                            $compileProvider.debugInfoEnabled(true);
                        },
                    ]);
                }
                modules.unshift("ng");
                var injector = createInjector(modules, config.strictDi);
                injector.invoke([
                    "$rootScope",
                    "$rootElement",
                    "$compile",
                    "$injector",
                    function bootstrapApply(scope, element, compile, injector) {
                        scope.$apply(function () {
                            element.data("$injector", injector);
                            compile(element)(scope);
                        });
                    },
                ]);
                return injector;
            };
            var NG_ENABLE_DEBUG_INFO = /^NG_ENABLE_DEBUG_INFO!/;
            var NG_DEFER_BOOTSTRAP = /^NG_DEFER_BOOTSTRAP!/;
            if (window && NG_ENABLE_DEBUG_INFO.test(window.name)) {
                config.debugInfoEnabled = true;
                window.name = window.name.replace(NG_ENABLE_DEBUG_INFO, "");
            }
            if (window && !NG_DEFER_BOOTSTRAP.test(window.name)) {
                return doBootstrap();
            }
            window.name = window.name.replace(NG_DEFER_BOOTSTRAP, "");
            angular.resumeBootstrap = function (extraModules) {
                forEach(extraModules, function (module) {
                    modules.push(module);
                });
                return doBootstrap();
            };
            if (isFunction(angular.resumeDeferredBootstrap)) {
                angular.resumeDeferredBootstrap();
            }
        }
        function reloadWithDebugInfo() {
            window.name = "NG_ENABLE_DEBUG_INFO!" + window.name;
            window.location.reload();
        }
        function getTestability(rootElement) {
            var injector = angular.element(rootElement).injector();
            if (!injector) {
                throw ngMinErr("test", "no injector found for element argument to getTestability");
            }
            return injector.get("$$testability");
        }
        var SNAKE_CASE_REGEXP = /[A-Z]/g;
        function snake_case(name, separator) {
            separator = separator || "_";
            return name.replace(SNAKE_CASE_REGEXP, function (letter, pos) {
                return (pos ? separator : "") + letter.toLowerCase();
            });
        }
        var bindJQueryFired = false;
        function bindJQuery() {
            var originalCleanData;
            if (bindJQueryFired) {
                return;
            }
            var jqName = jq();
            jQuery = isUndefined(jqName) ? window.jQuery : !jqName ? undefined : window[jqName];
            if (jQuery && jQuery.fn.on) {
                jqLite = jQuery;
                extend(jQuery.fn, { scope: JQLitePrototype.scope, isolateScope: JQLitePrototype.isolateScope, controller: JQLitePrototype.controller, injector: JQLitePrototype.injector, inheritedData: JQLitePrototype.inheritedData });
                originalCleanData = jQuery.cleanData;
                jQuery.cleanData = function (elems) {
                    var events;
                    for (var i = 0, elem; (elem = elems[i]) != null; i++) {
                        events = jQuery._data(elem, "events");
                        if (events && events.$destroy) {
                            jQuery(elem).triggerHandler("$destroy");
                        }
                    }
                    originalCleanData(elems);
                };
            } else {
                jqLite = JQLite;
            }
            angular.element = jqLite;
            bindJQueryFired = true;
        }
        function assertArg(arg, name, reason) {
            if (!arg) {
                throw ngMinErr("areq", "Argument '{0}' is {1}", name || "?", reason || "required");
            }
            return arg;
        }
        function assertArgFn(arg, name, acceptArrayAnnotation) {
            if (acceptArrayAnnotation && isArray(arg)) {
                arg = arg[arg.length - 1];
            }
            assertArg(isFunction(arg), name, "not a function, got " + (arg && typeof arg === "object" ? arg.constructor.name || "Object" : typeof arg));
            return arg;
        }
        function assertNotHasOwnProperty(name, context) {
            if (name === "hasOwnProperty") {
                throw ngMinErr("badname", "hasOwnProperty is not a valid {0} name", context);
            }
        }
        function getter(obj, path, bindFnToScope) {
            if (!path) return obj;
            var keys = path.split(".");
            var key;
            var lastInstance = obj;
            var len = keys.length;
            for (var i = 0; i < len; i++) {
                key = keys[i];
                if (obj) {
                    obj = (lastInstance = obj)[key];
                }
            }
            if (!bindFnToScope && isFunction(obj)) {
                return bind(lastInstance, obj);
            }
            return obj;
        }
        function getBlockNodes(nodes) {
            var node = nodes[0];
            var endNode = nodes[nodes.length - 1];
            var blockNodes;
            for (var i = 1; node !== endNode && (node = node.nextSibling); i++) {
                if (blockNodes || nodes[i] !== node) {
                    if (!blockNodes) {
                        blockNodes = jqLite(slice.call(nodes, 0, i));
                    }
                    blockNodes.push(node);
                }
            }
            return blockNodes || nodes;
        }
        function createMap() {
            return Object.create(null);
        }
        function stringify(value) {
            if (value == null) {
                return "";
            }
            switch (typeof value) {
                case "string":
                    break;
                case "number":
                    value = "" + value;
                    break;
                default:
                    if (hasCustomToString(value) && !isArray(value) && !isDate(value)) {
                        value = value.toString();
                    } else {
                        value = toJson(value);
                    }
            }
            return value;
        }
        var NODE_TYPE_ELEMENT = 1;
        var NODE_TYPE_ATTRIBUTE = 2;
        var NODE_TYPE_TEXT = 3;
        var NODE_TYPE_COMMENT = 8;
        var NODE_TYPE_DOCUMENT = 9;
        var NODE_TYPE_DOCUMENT_FRAGMENT = 11;
        function setupModuleLoader(window) {
            var $injectorMinErr = minErr("$injector");
            var ngMinErr = minErr("ng");
            function ensure(obj, name, factory) {
                return obj[name] || (obj[name] = factory());
            }
            var angular = ensure(window, "angular", Object);
            angular.$$minErr = angular.$$minErr || minErr;
            return ensure(angular, "module", function () {
                var modules = {};
                return function module(name, requires, configFn) {
                    var info = {};
                    var assertNotHasOwnProperty = function (name, context) {
                        if (name === "hasOwnProperty") {
                            throw ngMinErr("badname", "hasOwnProperty is not a valid {0} name", context);
                        }
                    };
                    assertNotHasOwnProperty(name, "module");
                    if (requires && modules.hasOwnProperty(name)) {
                        modules[name] = null;
                    }
                    return ensure(modules, name, function () {
                        if (!requires) {
                            throw $injectorMinErr(
                                "nomod",
                                "Module '{0}' is not available! You either misspelled " + "the module name or forgot to load it. If registering a module ensure that you " + "specify the dependencies as the second argument.",
                                name
                            );
                        }
                        var invokeQueue = [];
                        var configBlocks = [];
                        var runBlocks = [];
                        var config = invokeLater("$injector", "invoke", "push", configBlocks);
                        var moduleInstance = {
                            _invokeQueue: invokeQueue,
                            _configBlocks: configBlocks,
                            _runBlocks: runBlocks,
                            info: function (value) {
                                if (isDefined(value)) {
                                    if (!isObject(value)) throw ngMinErr("aobj", "Argument '{0}' must be an object", "value");
                                    info = value;
                                    return this;
                                }
                                return info;
                            },
                            requires: requires,
                            name: name,
                            provider: invokeLaterAndSetModuleName("$provide", "provider"),
                            factory: invokeLaterAndSetModuleName("$provide", "factory"),
                            service: invokeLaterAndSetModuleName("$provide", "service"),
                            value: invokeLater("$provide", "value"),
                            constant: invokeLater("$provide", "constant", "unshift"),
                            decorator: invokeLaterAndSetModuleName("$provide", "decorator", configBlocks),
                            animation: invokeLaterAndSetModuleName("$animateProvider", "register"),
                            filter: invokeLaterAndSetModuleName("$filterProvider", "register"),
                            controller: invokeLaterAndSetModuleName("$controllerProvider", "register"),
                            directive: invokeLaterAndSetModuleName("$compileProvider", "directive"),
                            component: invokeLaterAndSetModuleName("$compileProvider", "component"),
                            config: config,
                            run: function (block) {
                                runBlocks.push(block);
                                return this;
                            },
                        };
                        if (configFn) {
                            config(configFn);
                        }
                        return moduleInstance;
                        function invokeLater(provider, method, insertMethod, queue) {
                            if (!queue) queue = invokeQueue;
                            return function () {
                                queue[insertMethod || "push"]([provider, method, arguments]);
                                return moduleInstance;
                            };
                        }
                        function invokeLaterAndSetModuleName(provider, method, queue) {
                            if (!queue) queue = invokeQueue;
                            return function (recipeName, factoryFunction) {
                                if (factoryFunction && isFunction(factoryFunction)) factoryFunction.$$moduleName = name;
                                queue.push([provider, method, arguments]);
                                return moduleInstance;
                            };
                        }
                    });
                };
            });
        }
        function shallowCopy(src, dst) {
            if (isArray(src)) {
                dst = dst || [];
                for (var i = 0, ii = src.length; i < ii; i++) {
                    dst[i] = src[i];
                }
            } else if (isObject(src)) {
                dst = dst || {};
                for (var key in src) {
                    if (!(key.charAt(0) === "$" && key.charAt(1) === "$")) {
                        dst[key] = src[key];
                    }
                }
            }
            return dst || src;
        }
        function serializeObject(obj, maxDepth) {
            var seen = [];
            if (isValidObjectMaxDepth(maxDepth)) {
                obj = copy(obj, null, maxDepth);
            }
            return JSON.stringify(obj, function (key, val) {
                val = toJsonReplacer(key, val);
                if (isObject(val)) {
                    if (seen.indexOf(val) >= 0) return "...";
                    seen.push(val);
                }
                return val;
            });
        }
        function toDebugString(obj, maxDepth) {
            if (typeof obj === "function") {
                return obj.toString().replace(/ \{[\s\S]*$/, "");
            } else if (isUndefined(obj)) {
                return "undefined";
            } else if (typeof obj !== "string") {
                return serializeObject(obj, maxDepth);
            }
            return obj;
        }
        var version = { full: "1.6.4", major: 1, minor: 6, dot: 4, codeName: "phenomenal-footnote" };
        function publishExternalAPI(angular) {
            extend(angular, {
                errorHandlingConfig: errorHandlingConfig,
                bootstrap: bootstrap,
                copy: copy,
                extend: extend,
                merge: merge,
                equals: equals,
                element: jqLite,
                forEach: forEach,
                injector: createInjector,
                noop: noop,
                bind: bind,
                toJson: toJson,
                fromJson: fromJson,
                identity: identity,
                isUndefined: isUndefined,
                isDefined: isDefined,
                isString: isString,
                isFunction: isFunction,
                isObject: isObject,
                isNumber: isNumber,
                isElement: isElement,
                isArray: isArray,
                version: version,
                isDate: isDate,
                lowercase: lowercase,
                uppercase: uppercase,
                callbacks: { $$counter: 0 },
                getTestability: getTestability,
                reloadWithDebugInfo: reloadWithDebugInfo,
                $$minErr: minErr,
                $$csp: csp,
                $$encodeUriSegment: encodeUriSegment,
                $$encodeUriQuery: encodeUriQuery,
                $$stringify: stringify,
            });
            angularModule = setupModuleLoader(window);
            angularModule(
                "ng",
                ["ngLocale"],
                [
                    "$provide",
                    function ngModule($provide) {
                        $provide.provider({ $$sanitizeUri: $$SanitizeUriProvider });
                        $provide
                            .provider("$compile", $CompileProvider)
                            .directive({
                                a: htmlAnchorDirective,
                                input: inputDirective,
                                textarea: inputDirective,
                                form: formDirective,
                                script: scriptDirective,
                                select: selectDirective,
                                option: optionDirective,
                                ngBind: ngBindDirective,
                                ngBindHtml: ngBindHtmlDirective,
                                ngBindTemplate: ngBindTemplateDirective,
                                ngClass: ngClassDirective,
                                ngClassEven: ngClassEvenDirective,
                                ngClassOdd: ngClassOddDirective,
                                ngCloak: ngCloakDirective,
                                ngController: ngControllerDirective,
                                ngForm: ngFormDirective,
                                ngHide: ngHideDirective,
                                ngIf: ngIfDirective,
                                ngInclude: ngIncludeDirective,
                                ngInit: ngInitDirective,
                                ngNonBindable: ngNonBindableDirective,
                                ngPluralize: ngPluralizeDirective,
                                ngRepeat: ngRepeatDirective,
                                ngShow: ngShowDirective,
                                ngStyle: ngStyleDirective,
                                ngSwitch: ngSwitchDirective,
                                ngSwitchWhen: ngSwitchWhenDirective,
                                ngSwitchDefault: ngSwitchDefaultDirective,
                                ngOptions: ngOptionsDirective,
                                ngTransclude: ngTranscludeDirective,
                                ngModel: ngModelDirective,
                                ngList: ngListDirective,
                                ngChange: ngChangeDirective,
                                pattern: patternDirective,
                                ngPattern: patternDirective,
                                required: requiredDirective,
                                ngRequired: requiredDirective,
                                minlength: minlengthDirective,
                                ngMinlength: minlengthDirective,
                                maxlength: maxlengthDirective,
                                ngMaxlength: maxlengthDirective,
                                ngValue: ngValueDirective,
                                ngModelOptions: ngModelOptionsDirective,
                            })
                            .directive({ ngInclude: ngIncludeFillContentDirective })
                            .directive(ngAttributeAliasDirectives)
                            .directive(ngEventDirectives);
                        $provide.provider({
                            $anchorScroll: $AnchorScrollProvider,
                            $animate: $AnimateProvider,
                            $animateCss: $CoreAnimateCssProvider,
                            $$animateJs: $$CoreAnimateJsProvider,
                            $$animateQueue: $$CoreAnimateQueueProvider,
                            $$AnimateRunner: $$AnimateRunnerFactoryProvider,
                            $$animateAsyncRun: $$AnimateAsyncRunFactoryProvider,
                            $browser: $BrowserProvider,
                            $cacheFactory: $CacheFactoryProvider,
                            $controller: $ControllerProvider,
                            $document: $DocumentProvider,
                            $$isDocumentHidden: $$IsDocumentHiddenProvider,
                            $exceptionHandler: $ExceptionHandlerProvider,
                            $filter: $FilterProvider,
                            $$forceReflow: $$ForceReflowProvider,
                            $interpolate: $InterpolateProvider,
                            $interval: $IntervalProvider,
                            $http: $HttpProvider,
                            $httpParamSerializer: $HttpParamSerializerProvider,
                            $httpParamSerializerJQLike: $HttpParamSerializerJQLikeProvider,
                            $httpBackend: $HttpBackendProvider,
                            $xhrFactory: $xhrFactoryProvider,
                            $jsonpCallbacks: $jsonpCallbacksProvider,
                            $location: $LocationProvider,
                            $log: $LogProvider,
                            $parse: $ParseProvider,
                            $rootScope: $RootScopeProvider,
                            $q: $QProvider,
                            $$q: $$QProvider,
                            $sce: $SceProvider,
                            $sceDelegate: $SceDelegateProvider,
                            $sniffer: $SnifferProvider,
                            $templateCache: $TemplateCacheProvider,
                            $templateRequest: $TemplateRequestProvider,
                            $$testability: $$TestabilityProvider,
                            $timeout: $TimeoutProvider,
                            $window: $WindowProvider,
                            $$rAF: $$RAFProvider,
                            $$jqLite: $$jqLiteProvider,
                            $$Map: $$MapProvider,
                            $$cookieReader: $$CookieReaderProvider,
                        });
                    },
                ]
            ).info({ angularVersion: "1.6.4" });
        }
        JQLite.expando = "ng339";
        var jqCache = (JQLite.cache = {}),
            jqId = 1;
        JQLite._data = function (node) {
            return this.cache[node[this.expando]] || {};
        };
        function jqNextId() {
            return ++jqId;
        }
        var DASH_LOWERCASE_REGEXP = /-([a-z])/g;
        var MS_HACK_REGEXP = /^-ms-/;
        var MOUSE_EVENT_MAP = { mouseleave: "mouseout", mouseenter: "mouseover" };
        var jqLiteMinErr = minErr("jqLite");
        function cssKebabToCamel(name) {
            return kebabToCamel(name.replace(MS_HACK_REGEXP, "ms-"));
        }
        function fnCamelCaseReplace(all, letter) {
            return letter.toUpperCase();
        }
        function kebabToCamel(name) {
            return name.replace(DASH_LOWERCASE_REGEXP, fnCamelCaseReplace);
        }
        var SINGLE_TAG_REGEXP = /^<([\w-]+)\s*\/?>(?:<\/\1>|)$/;
        var HTML_REGEXP = /<|&#?\w+;/;
        var TAG_NAME_REGEXP = /<([\w:-]+)/;
        var XHTML_TAG_REGEXP = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:-]+)[^>]*)\/>/gi;
        var wrapMap = {
            option: [1, '<select multiple="multiple">', "</select>"],
            thead: [1, "<table>", "</table>"],
            col: [2, "<table><colgroup>", "</colgroup></table>"],
            tr: [2, "<table><tbody>", "</tbody></table>"],
            td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
            _default: [0, "", ""],
        };
        wrapMap.optgroup = wrapMap.option;
        wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
        wrapMap.th = wrapMap.td;
        function jqLiteIsTextNode(html) {
            return !HTML_REGEXP.test(html);
        }
        function jqLiteAcceptsData(node) {
            var nodeType = node.nodeType;
            return nodeType === NODE_TYPE_ELEMENT || !nodeType || nodeType === NODE_TYPE_DOCUMENT;
        }
        function jqLiteHasData(node) {
            for (var key in jqCache[node.ng339]) {
                return true;
            }
            return false;
        }
        function jqLiteBuildFragment(html, context) {
            var tmp,
                tag,
                wrap,
                fragment = context.createDocumentFragment(),
                nodes = [],
                i;
            if (jqLiteIsTextNode(html)) {
                nodes.push(context.createTextNode(html));
            } else {
                tmp = fragment.appendChild(context.createElement("div"));
                tag = (TAG_NAME_REGEXP.exec(html) || ["", ""])[1].toLowerCase();
                wrap = wrapMap[tag] || wrapMap._default;
                tmp.innerHTML = wrap[1] + html.replace(XHTML_TAG_REGEXP, "<$1></$2>") + wrap[2];
                i = wrap[0];
                while (i--) {
                    tmp = tmp.lastChild;
                }
                nodes = concat(nodes, tmp.childNodes);
                tmp = fragment.firstChild;
                tmp.textContent = "";
            }
            fragment.textContent = "";
            fragment.innerHTML = "";
            forEach(nodes, function (node) {
                fragment.appendChild(node);
            });
            return fragment;
        }
        function jqLiteParseHTML(html, context) {
            context = context || window.document;
            var parsed;
            if ((parsed = SINGLE_TAG_REGEXP.exec(html))) {
                return [context.createElement(parsed[1])];
            }
            if ((parsed = jqLiteBuildFragment(html, context))) {
                return parsed.childNodes;
            }
            return [];
        }
        function jqLiteWrapNode(node, wrapper) {
            var parent = node.parentNode;
            if (parent) {
                parent.replaceChild(wrapper, node);
            }
            wrapper.appendChild(node);
        }
        var jqLiteContains =
            window.Node.prototype.contains ||
            function (arg) {
                return !!(this.compareDocumentPosition(arg) & 16);
            };
        function JQLite(element) {
            if (element instanceof JQLite) {
                return element;
            }
            var argIsString;
            if (isString(element)) {
                element = trim(element);
                argIsString = true;
            }
            if (!(this instanceof JQLite)) {
                if (argIsString && element.charAt(0) !== "<") {
                    throw jqLiteMinErr("nosel", "Looking up elements via selectors is not supported by jqLite! See: http://docs.angularjs.org/api/angular.element");
                }
                return new JQLite(element);
            }
            if (argIsString) {
                jqLiteAddNodes(this, jqLiteParseHTML(element));
            } else if (isFunction(element)) {
                jqLiteReady(element);
            } else {
                jqLiteAddNodes(this, element);
            }
        }
        function jqLiteClone(element) {
            return element.cloneNode(true);
        }
        function jqLiteDealoc(element, onlyDescendants) {
            if (!onlyDescendants && jqLiteAcceptsData(element)) jqLite.cleanData([element]);
            if (element.querySelectorAll) {
                jqLite.cleanData(element.querySelectorAll("*"));
            }
        }
        function jqLiteOff(element, type, fn, unsupported) {
            if (isDefined(unsupported)) throw jqLiteMinErr("offargs", "jqLite#off() does not support the `selector` argument");
            var expandoStore = jqLiteExpandoStore(element);
            var events = expandoStore && expandoStore.events;
            var handle = expandoStore && expandoStore.handle;
            if (!handle) return;
            if (!type) {
                for (type in events) {
                    if (type !== "$destroy") {
                        element.removeEventListener(type, handle);
                    }
                    delete events[type];
                }
            } else {
                var removeHandler = function (type) {
                    var listenerFns = events[type];
                    if (isDefined(fn)) {
                        arrayRemove(listenerFns || [], fn);
                    }
                    if (!(isDefined(fn) && listenerFns && listenerFns.length > 0)) {
                        element.removeEventListener(type, handle);
                        delete events[type];
                    }
                };
                forEach(type.split(" "), function (type) {
                    removeHandler(type);
                    if (MOUSE_EVENT_MAP[type]) {
                        removeHandler(MOUSE_EVENT_MAP[type]);
                    }
                });
            }
        }
        function jqLiteRemoveData(element, name) {
            var expandoId = element.ng339;
            var expandoStore = expandoId && jqCache[expandoId];
            if (expandoStore) {
                if (name) {
                    delete expandoStore.data[name];
                    return;
                }
                if (expandoStore.handle) {
                    if (expandoStore.events.$destroy) {
                        expandoStore.handle({}, "$destroy");
                    }
                    jqLiteOff(element);
                }
                delete jqCache[expandoId];
                element.ng339 = undefined;
            }
        }
        function jqLiteExpandoStore(element, createIfNecessary) {
            var expandoId = element.ng339,
                expandoStore = expandoId && jqCache[expandoId];
            if (createIfNecessary && !expandoStore) {
                element.ng339 = expandoId = jqNextId();
                expandoStore = jqCache[expandoId] = { events: {}, data: {}, handle: undefined };
            }
            return expandoStore;
        }
        function jqLiteData(element, key, value) {
            if (jqLiteAcceptsData(element)) {
                var prop;
                var isSimpleSetter = isDefined(value);
                var isSimpleGetter = !isSimpleSetter && key && !isObject(key);
                var massGetter = !key;
                var expandoStore = jqLiteExpandoStore(element, !isSimpleGetter);
                var data = expandoStore && expandoStore.data;
                if (isSimpleSetter) {
                    data[kebabToCamel(key)] = value;
                } else {
                    if (massGetter) {
                        return data;
                    } else {
                        if (isSimpleGetter) {
                            return data && data[kebabToCamel(key)];
                        } else {
                            for (prop in key) {
                                data[kebabToCamel(prop)] = key[prop];
                            }
                        }
                    }
                }
            }
        }
        function jqLiteHasClass(element, selector) {
            if (!element.getAttribute) return false;
            return (" " + (element.getAttribute("class") || "") + " ").replace(/[\n\t]/g, " ").indexOf(" " + selector + " ") > -1;
        }
        function jqLiteRemoveClass(element, cssClasses) {
            if (cssClasses && element.setAttribute) {
                forEach(cssClasses.split(" "), function (cssClass) {
                    element.setAttribute("class", trim((" " + (element.getAttribute("class") || "") + " ").replace(/[\n\t]/g, " ").replace(" " + trim(cssClass) + " ", " ")));
                });
            }
        }
        function jqLiteAddClass(element, cssClasses) {
            if (cssClasses && element.setAttribute) {
                var existingClasses = (" " + (element.getAttribute("class") || "") + " ").replace(/[\n\t]/g, " ");
                forEach(cssClasses.split(" "), function (cssClass) {
                    cssClass = trim(cssClass);
                    if (existingClasses.indexOf(" " + cssClass + " ") === -1) {
                        existingClasses += cssClass + " ";
                    }
                });
                element.setAttribute("class", trim(existingClasses));
            }
        }
        function jqLiteAddNodes(root, elements) {
            if (elements) {
                if (elements.nodeType) {
                    root[root.length++] = elements;
                } else {
                    var length = elements.length;
                    if (typeof length === "number" && elements.window !== elements) {
                        if (length) {
                            for (var i = 0; i < length; i++) {
                                root[root.length++] = elements[i];
                            }
                        }
                    } else {
                        root[root.length++] = elements;
                    }
                }
            }
        }
        function jqLiteController(element, name) {
            return jqLiteInheritedData(element, "$" + (name || "ngController") + "Controller");
        }
        function jqLiteInheritedData(element, name, value) {
            if (element.nodeType === NODE_TYPE_DOCUMENT) {
                element = element.documentElement;
            }
            var names = isArray(name) ? name : [name];
            while (element) {
                for (var i = 0, ii = names.length; i < ii; i++) {
                    if (isDefined((value = jqLite.data(element, names[i])))) return value;
                }
                element = element.parentNode || (element.nodeType === NODE_TYPE_DOCUMENT_FRAGMENT && element.host);
            }
        }
        function jqLiteEmpty(element) {
            jqLiteDealoc(element, true);
            while (element.firstChild) {
                element.removeChild(element.firstChild);
            }
        }
        function jqLiteRemove(element, keepData) {
            if (!keepData) jqLiteDealoc(element);
            var parent = element.parentNode;
            if (parent) parent.removeChild(element);
        }
        function jqLiteDocumentLoaded(action, win) {
            win = win || window;
            if (win.document.readyState === "complete") {
                win.setTimeout(action);
            } else {
                jqLite(win).on("load", action);
            }
        }
        function jqLiteReady(fn) {
            function trigger() {
                window.document.removeEventListener("DOMContentLoaded", trigger);
                window.removeEventListener("load", trigger);
                fn();
            }
            if (window.document.readyState === "complete") {
                window.setTimeout(fn);
            } else {
                window.document.addEventListener("DOMContentLoaded", trigger);
                window.addEventListener("load", trigger);
            }
        }
        var JQLitePrototype = (JQLite.prototype = {
            ready: jqLiteReady,
            toString: function () {
                var value = [];
                forEach(this, function (e) {
                    value.push("" + e);
                });
                return "[" + value.join(", ") + "]";
            },
            eq: function (index) {
                return index >= 0 ? jqLite(this[index]) : jqLite(this[this.length + index]);
            },
            length: 0,
            push: push,
            sort: [].sort,
            splice: [].splice,
        });
        var BOOLEAN_ATTR = {};
        forEach("multiple,selected,checked,disabled,readOnly,required,open".split(","), function (value) {
            BOOLEAN_ATTR[lowercase(value)] = value;
        });
        var BOOLEAN_ELEMENTS = {};
        forEach("input,select,option,textarea,button,form,details".split(","), function (value) {
            BOOLEAN_ELEMENTS[value] = true;
        });
        var ALIASED_ATTR = { ngMinlength: "minlength", ngMaxlength: "maxlength", ngMin: "min", ngMax: "max", ngPattern: "pattern", ngStep: "step" };
        function getBooleanAttrName(element, name) {
            var booleanAttr = BOOLEAN_ATTR[name.toLowerCase()];
            return booleanAttr && BOOLEAN_ELEMENTS[nodeName_(element)] && booleanAttr;
        }
        function getAliasedAttrName(name) {
            return ALIASED_ATTR[name];
        }
        forEach(
            {
                data: jqLiteData,
                removeData: jqLiteRemoveData,
                hasData: jqLiteHasData,
                cleanData: function jqLiteCleanData(nodes) {
                    for (var i = 0, ii = nodes.length; i < ii; i++) {
                        jqLiteRemoveData(nodes[i]);
                    }
                },
            },
            function (fn, name) {
                JQLite[name] = fn;
            }
        );
        forEach(
            {
                data: jqLiteData,
                inheritedData: jqLiteInheritedData,
                scope: function (element) {
                    return jqLite.data(element, "$scope") || jqLiteInheritedData(element.parentNode || element, ["$isolateScope", "$scope"]);
                },
                isolateScope: function (element) {
                    return jqLite.data(element, "$isolateScope") || jqLite.data(element, "$isolateScopeNoTemplate");
                },
                controller: jqLiteController,
                injector: function (element) {
                    return jqLiteInheritedData(element, "$injector");
                },
                removeAttr: function (element, name) {
                    element.removeAttribute(name);
                },
                hasClass: jqLiteHasClass,
                css: function (element, name, value) {
                    name = cssKebabToCamel(name);
                    if (isDefined(value)) {
                        element.style[name] = value;
                    } else {
                        return element.style[name];
                    }
                },
                attr: function (element, name, value) {
                    var ret;
                    var nodeType = element.nodeType;
                    if (nodeType === NODE_TYPE_TEXT || nodeType === NODE_TYPE_ATTRIBUTE || nodeType === NODE_TYPE_COMMENT || !element.getAttribute) {
                        return;
                    }
                    var lowercasedName = lowercase(name);
                    var isBooleanAttr = BOOLEAN_ATTR[lowercasedName];
                    if (isDefined(value)) {
                        if (value === null || (value === false && isBooleanAttr)) {
                            element.removeAttribute(name);
                        } else {
                            element.setAttribute(name, isBooleanAttr ? lowercasedName : value);
                        }
                    } else {
                        ret = element.getAttribute(name);
                        if (isBooleanAttr && ret !== null) {
                            ret = lowercasedName;
                        }
                        return ret === null ? undefined : ret;
                    }
                },
                prop: function (element, name, value) {
                    if (isDefined(value)) {
                        element[name] = value;
                    } else {
                        return element[name];
                    }
                },
                text: (function () {
                    getText.$dv = "";
                    return getText;
                    function getText(element, value) {
                        if (isUndefined(value)) {
                            var nodeType = element.nodeType;
                            return nodeType === NODE_TYPE_ELEMENT || nodeType === NODE_TYPE_TEXT ? element.textContent : "";
                        }
                        element.textContent = value;
                    }
                })(),
                val: function (element, value) {
                    if (isUndefined(value)) {
                        if (element.multiple && nodeName_(element) === "select") {
                            var result = [];
                            forEach(element.options, function (option) {
                                if (option.selected) {
                                    result.push(option.value || option.text);
                                }
                            });
                            return result;
                        }
                        return element.value;
                    }
                    element.value = value;
                },
                html: function (element, value) {
                    if (isUndefined(value)) {
                        return element.innerHTML;
                    }
                    jqLiteDealoc(element, true);
                    element.innerHTML = value;
                },
                empty: jqLiteEmpty,
            },
            function (fn, name) {
                JQLite.prototype[name] = function (arg1, arg2) {
                    var i, key;
                    var nodeCount = this.length;
                    if (fn !== jqLiteEmpty && isUndefined(fn.length === 2 && fn !== jqLiteHasClass && fn !== jqLiteController ? arg1 : arg2)) {
                        if (isObject(arg1)) {
                            for (i = 0; i < nodeCount; i++) {
                                if (fn === jqLiteData) {
                                    fn(this[i], arg1);
                                } else {
                                    for (key in arg1) {
                                        fn(this[i], key, arg1[key]);
                                    }
                                }
                            }
                            return this;
                        } else {
                            var value = fn.$dv;
                            var jj = isUndefined(value) ? Math.min(nodeCount, 1) : nodeCount;
                            for (var j = 0; j < jj; j++) {
                                var nodeValue = fn(this[j], arg1, arg2);
                                value = value ? value + nodeValue : nodeValue;
                            }
                            return value;
                        }
                    } else {
                        for (i = 0; i < nodeCount; i++) {
                            fn(this[i], arg1, arg2);
                        }
                        return this;
                    }
                };
            }
        );
        function createEventHandler(element, events) {
            var eventHandler = function (event, type) {
                event.isDefaultPrevented = function () {
                    return event.defaultPrevented;
                };
                var eventFns = events[type || event.type];
                var eventFnsLength = eventFns ? eventFns.length : 0;
                if (!eventFnsLength) return;
                if (isUndefined(event.immediatePropagationStopped)) {
                    var originalStopImmediatePropagation = event.stopImmediatePropagation;
                    event.stopImmediatePropagation = function () {
                        event.immediatePropagationStopped = true;
                        if (event.stopPropagation) {
                            event.stopPropagation();
                        }
                        if (originalStopImmediatePropagation) {
                            originalStopImmediatePropagation.call(event);
                        }
                    };
                }
                event.isImmediatePropagationStopped = function () {
                    return event.immediatePropagationStopped === true;
                };
                var handlerWrapper = eventFns.specialHandlerWrapper || defaultHandlerWrapper;
                if (eventFnsLength > 1) {
                    eventFns = shallowCopy(eventFns);
                }
                for (var i = 0; i < eventFnsLength; i++) {
                    if (!event.isImmediatePropagationStopped()) {
                        handlerWrapper(element, event, eventFns[i]);
                    }
                }
            };
            eventHandler.elem = element;
            return eventHandler;
        }
        function defaultHandlerWrapper(element, event, handler) {
            handler.call(element, event);
        }
        function specialMouseHandlerWrapper(target, event, handler) {
            var related = event.relatedTarget;
            if (!related || (related !== target && !jqLiteContains.call(target, related))) {
                handler.call(target, event);
            }
        }
        forEach(
            {
                removeData: jqLiteRemoveData,
                on: function jqLiteOn(element, type, fn, unsupported) {
                    if (isDefined(unsupported)) throw jqLiteMinErr("onargs", "jqLite#on() does not support the `selector` or `eventData` parameters");
                    if (!jqLiteAcceptsData(element)) {
                        return;
                    }
                    var expandoStore = jqLiteExpandoStore(element, true);
                    var events = expandoStore.events;
                    var handle = expandoStore.handle;
                    if (!handle) {
                        handle = expandoStore.handle = createEventHandler(element, events);
                    }
                    var types = type.indexOf(" ") >= 0 ? type.split(" ") : [type];
                    var i = types.length;
                    var addHandler = function (type, specialHandlerWrapper, noEventListener) {
                        var eventFns = events[type];
                        if (!eventFns) {
                            eventFns = events[type] = [];
                            eventFns.specialHandlerWrapper = specialHandlerWrapper;
                            if (type !== "$destroy" && !noEventListener) {
                                element.addEventListener(type, handle);
                            }
                        }
                        eventFns.push(fn);
                    };
                    while (i--) {
                        type = types[i];
                        if (MOUSE_EVENT_MAP[type]) {
                            addHandler(MOUSE_EVENT_MAP[type], specialMouseHandlerWrapper);
                            addHandler(type, undefined, true);
                        } else {
                            addHandler(type);
                        }
                    }
                },
                off: jqLiteOff,
                one: function (element, type, fn) {
                    element = jqLite(element);
                    element.on(type, function onFn() {
                        element.off(type, fn);
                        element.off(type, onFn);
                    });
                    element.on(type, fn);
                },
                replaceWith: function (element, replaceNode) {
                    var index,
                        parent = element.parentNode;
                    jqLiteDealoc(element);
                    forEach(new JQLite(replaceNode), function (node) {
                        if (index) {
                            parent.insertBefore(node, index.nextSibling);
                        } else {
                            parent.replaceChild(node, element);
                        }
                        index = node;
                    });
                },
                children: function (element) {
                    var children = [];
                    forEach(element.childNodes, function (element) {
                        if (element.nodeType === NODE_TYPE_ELEMENT) {
                            children.push(element);
                        }
                    });
                    return children;
                },
                contents: function (element) {
                    return element.contentDocument || element.childNodes || [];
                },
                append: function (element, node) {
                    var nodeType = element.nodeType;
                    if (nodeType !== NODE_TYPE_ELEMENT && nodeType !== NODE_TYPE_DOCUMENT_FRAGMENT) return;
                    node = new JQLite(node);
                    for (var i = 0, ii = node.length; i < ii; i++) {
                        var child = node[i];
                        element.appendChild(child);
                    }
                },
                prepend: function (element, node) {
                    if (element.nodeType === NODE_TYPE_ELEMENT) {
                        var index = element.firstChild;
                        forEach(new JQLite(node), function (child) {
                            element.insertBefore(child, index);
                        });
                    }
                },
                wrap: function (element, wrapNode) {
                    jqLiteWrapNode(element, jqLite(wrapNode).eq(0).clone()[0]);
                },
                remove: jqLiteRemove,
                detach: function (element) {
                    jqLiteRemove(element, true);
                },
                after: function (element, newElement) {
                    var index = element,
                        parent = element.parentNode;
                    if (parent) {
                        newElement = new JQLite(newElement);
                        for (var i = 0, ii = newElement.length; i < ii; i++) {
                            var node = newElement[i];
                            parent.insertBefore(node, index.nextSibling);
                            index = node;
                        }
                    }
                },
                addClass: jqLiteAddClass,
                removeClass: jqLiteRemoveClass,
                toggleClass: function (element, selector, condition) {
                    if (selector) {
                        forEach(selector.split(" "), function (className) {
                            var classCondition = condition;
                            if (isUndefined(classCondition)) {
                                classCondition = !jqLiteHasClass(element, className);
                            }
                            (classCondition ? jqLiteAddClass : jqLiteRemoveClass)(element, className);
                        });
                    }
                },
                parent: function (element) {
                    var parent = element.parentNode;
                    return parent && parent.nodeType !== NODE_TYPE_DOCUMENT_FRAGMENT ? parent : null;
                },
                next: function (element) {
                    return element.nextElementSibling;
                },
                find: function (element, selector) {
                    if (element.getElementsByTagName) {
                        return element.getElementsByTagName(selector);
                    } else {
                        return [];
                    }
                },
                clone: jqLiteClone,
                triggerHandler: function (element, event, extraParameters) {
                    var dummyEvent, eventFnsCopy, handlerArgs;
                    var eventName = event.type || event;
                    var expandoStore = jqLiteExpandoStore(element);
                    var events = expandoStore && expandoStore.events;
                    var eventFns = events && events[eventName];
                    if (eventFns) {
                        dummyEvent = {
                            preventDefault: function () {
                                this.defaultPrevented = true;
                            },
                            isDefaultPrevented: function () {
                                return this.defaultPrevented === true;
                            },
                            stopImmediatePropagation: function () {
                                this.immediatePropagationStopped = true;
                            },
                            isImmediatePropagationStopped: function () {
                                return this.immediatePropagationStopped === true;
                            },
                            stopPropagation: noop,
                            type: eventName,
                            target: element,
                        };
                        if (event.type) {
                            dummyEvent = extend(dummyEvent, event);
                        }
                        eventFnsCopy = shallowCopy(eventFns);
                        handlerArgs = extraParameters ? [dummyEvent].concat(extraParameters) : [dummyEvent];
                        forEach(eventFnsCopy, function (fn) {
                            if (!dummyEvent.isImmediatePropagationStopped()) {
                                fn.apply(element, handlerArgs);
                            }
                        });
                    }
                },
            },
            function (fn, name) {
                JQLite.prototype[name] = function (arg1, arg2, arg3) {
                    var value;
                    for (var i = 0, ii = this.length; i < ii; i++) {
                        if (isUndefined(value)) {
                            value = fn(this[i], arg1, arg2, arg3);
                            if (isDefined(value)) {
                                value = jqLite(value);
                            }
                        } else {
                            jqLiteAddNodes(value, fn(this[i], arg1, arg2, arg3));
                        }
                    }
                    return isDefined(value) ? value : this;
                };
            }
        );
        JQLite.prototype.bind = JQLite.prototype.on;
        JQLite.prototype.unbind = JQLite.prototype.off;
        function $$jqLiteProvider() {
            this.$get = function $$jqLite() {
                return extend(JQLite, {
                    hasClass: function (node, classes) {
                        if (node.attr) node = node[0];
                        return jqLiteHasClass(node, classes);
                    },
                    addClass: function (node, classes) {
                        if (node.attr) node = node[0];
                        return jqLiteAddClass(node, classes);
                    },
                    removeClass: function (node, classes) {
                        if (node.attr) node = node[0];
                        return jqLiteRemoveClass(node, classes);
                    },
                });
            };
        }
        function hashKey(obj, nextUidFn) {
            var key = obj && obj.$$hashKey;
            if (key) {
                if (typeof key === "function") {
                    key = obj.$$hashKey();
                }
                return key;
            }
            var objType = typeof obj;
            if (objType === "function" || (objType === "object" && obj !== null)) {
                key = obj.$$hashKey = objType + ":" + (nextUidFn || nextUid)();
            } else {
                key = objType + ":" + obj;
            }
            return key;
        }
        var nanKey = Object.create(null);
        function NgMapShim() {
            this._keys = [];
            this._values = [];
            this._lastKey = NaN;
            this._lastIndex = -1;
        }
        NgMapShim.prototype = {
            _idx: function (key) {
                if (key === this._lastKey) {
                    return this._lastIndex;
                }
                this._lastKey = key;
                this._lastIndex = this._keys.indexOf(key);
                return this._lastIndex;
            },
            _transformKey: function (key) {
                return isNumberNaN(key) ? nanKey : key;
            },
            get: function (key) {
                key = this._transformKey(key);
                var idx = this._idx(key);
                if (idx !== -1) {
                    return this._values[idx];
                }
            },
            set: function (key, value) {
                key = this._transformKey(key);
                var idx = this._idx(key);
                if (idx === -1) {
                    idx = this._lastIndex = this._keys.length;
                }
                this._keys[idx] = key;
                this._values[idx] = value;
            },
            delete: function (key) {
                key = this._transformKey(key);
                var idx = this._idx(key);
                if (idx === -1) {
                    return false;
                }
                this._keys.splice(idx, 1);
                this._values.splice(idx, 1);
                this._lastKey = NaN;
                this._lastIndex = -1;
                return true;
            },
        };
        var NgMap = NgMapShim;
        var $$MapProvider = [
            function () {
                this.$get = [
                    function () {
                        return NgMap;
                    },
                ];
            },
        ];
        var ARROW_ARG = /^([^(]+?)=>/;
        var FN_ARGS = /^[^(]*\(\s*([^)]*)\)/m;
        var FN_ARG_SPLIT = /,/;
        var FN_ARG = /^\s*(_?)(\S+?)\1\s*$/;
        var STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/gm;
        var $injectorMinErr = minErr("$injector");
        function stringifyFn(fn) {
            return Function.prototype.toString.call(fn);
        }
        function extractArgs(fn) {
            var fnText = stringifyFn(fn).replace(STRIP_COMMENTS, ""),
                args = fnText.match(ARROW_ARG) || fnText.match(FN_ARGS);
            return args;
        }
        function anonFn(fn) {
            var args = extractArgs(fn);
            if (args) {
                return "function(" + (args[1] || "").replace(/[\s\r\n]+/, " ") + ")";
            }
            return "fn";
        }
        function annotate(fn, strictDi, name) {
            var $inject, argDecl, last;
            if (typeof fn === "function") {
                if (!($inject = fn.$inject)) {
                    $inject = [];
                    if (fn.length) {
                        if (strictDi) {
                            if (!isString(name) || !name) {
                                name = fn.name || anonFn(fn);
                            }
                            throw $injectorMinErr("strictdi", "{0} is not using explicit annotation and cannot be invoked in strict mode", name);
                        }
                        argDecl = extractArgs(fn);
                        forEach(argDecl[1].split(FN_ARG_SPLIT), function (arg) {
                            arg.replace(FN_ARG, function (all, underscore, name) {
                                $inject.push(name);
                            });
                        });
                    }
                    fn.$inject = $inject;
                }
            } else if (isArray(fn)) {
                last = fn.length - 1;
                assertArgFn(fn[last], "fn");
                $inject = fn.slice(0, last);
            } else {
                assertArgFn(fn, "fn", true);
            }
            return $inject;
        }
        function createInjector(modulesToLoad, strictDi) {
            strictDi = strictDi === true;
            var INSTANTIATING = {},
                providerSuffix = "Provider",
                path = [],
                loadedModules = new NgMap(),
                providerCache = { $provide: { provider: supportObject(provider), factory: supportObject(factory), service: supportObject(service), value: supportObject(value), constant: supportObject(constant), decorator: decorator } },
                providerInjector = (providerCache.$injector = createInternalInjector(providerCache, function (serviceName, caller) {
                    if (angular.isString(caller)) {
                        path.push(caller);
                    }
                    throw $injectorMinErr("unpr", "Unknown provider: {0}", path.join(" <- "));
                })),
                instanceCache = {},
                protoInstanceInjector = createInternalInjector(instanceCache, function (serviceName, caller) {
                    var provider = providerInjector.get(serviceName + providerSuffix, caller);
                    return instanceInjector.invoke(provider.$get, provider, undefined, serviceName);
                }),
                instanceInjector = protoInstanceInjector;
            providerCache["$injector" + providerSuffix] = { $get: valueFn(protoInstanceInjector) };
            instanceInjector.modules = providerInjector.modules = createMap();
            var runBlocks = loadModules(modulesToLoad);
            instanceInjector = protoInstanceInjector.get("$injector");
            instanceInjector.strictDi = strictDi;
            forEach(runBlocks, function (fn) {
                if (fn) instanceInjector.invoke(fn);
            });
            return instanceInjector;
            function supportObject(delegate) {
                return function (key, value) {
                    if (isObject(key)) {
                        forEach(key, reverseParams(delegate));
                    } else {
                        return delegate(key, value);
                    }
                };
            }
            function provider(name, provider_) {
                assertNotHasOwnProperty(name, "service");
                if (isFunction(provider_) || isArray(provider_)) {
                    provider_ = providerInjector.instantiate(provider_);
                }
                if (!provider_.$get) {
                    throw $injectorMinErr("pget", "Provider '{0}' must define $get factory method.", name);
                }
                return (providerCache[name + providerSuffix] = provider_);
            }
            function enforceReturnValue(name, factory) {
                return function enforcedReturnValue() {
                    var result = instanceInjector.invoke(factory, this);
                    if (isUndefined(result)) {
                        throw $injectorMinErr("undef", "Provider '{0}' must return a value from $get factory method.", name);
                    }
                    return result;
                };
            }
            function factory(name, factoryFn, enforce) {
                return provider(name, { $get: enforce !== false ? enforceReturnValue(name, factoryFn) : factoryFn });
            }
            function service(name, constructor) {
                return factory(name, [
                    "$injector",
                    function ($injector) {
                        return $injector.instantiate(constructor);
                    },
                ]);
            }
            function value(name, val) {
                return factory(name, valueFn(val), false);
            }
            function constant(name, value) {
                assertNotHasOwnProperty(name, "constant");
                providerCache[name] = value;
                instanceCache[name] = value;
            }
            function decorator(serviceName, decorFn) {
                var origProvider = providerInjector.get(serviceName + providerSuffix),
                    orig$get = origProvider.$get;
                origProvider.$get = function () {
                    var origInstance = instanceInjector.invoke(orig$get, origProvider);
                    return instanceInjector.invoke(decorFn, null, { $delegate: origInstance });
                };
            }
            function loadModules(modulesToLoad) {
                assertArg(isUndefined(modulesToLoad) || isArray(modulesToLoad), "modulesToLoad", "not an array");
                var runBlocks = [],
                    moduleFn;
                forEach(modulesToLoad, function (module) {
                    if (loadedModules.get(module)) return;
                    loadedModules.set(module, true);
                    function runInvokeQueue(queue) {
                        var i, ii;
                        for (i = 0, ii = queue.length; i < ii; i++) {
                            var invokeArgs = queue[i],
                                provider = providerInjector.get(invokeArgs[0]);
                            provider[invokeArgs[1]].apply(provider, invokeArgs[2]);
                        }
                    }
                    try {
                        if (isString(module)) {
                            moduleFn = angularModule(module);
                            instanceInjector.modules[module] = moduleFn;
                            runBlocks = runBlocks.concat(loadModules(moduleFn.requires)).concat(moduleFn._runBlocks);
                            runInvokeQueue(moduleFn._invokeQueue);
                            runInvokeQueue(moduleFn._configBlocks);
                        } else if (isFunction(module)) {
                            runBlocks.push(providerInjector.invoke(module));
                        } else if (isArray(module)) {
                            runBlocks.push(providerInjector.invoke(module));
                        } else {
                            assertArgFn(module, "module");
                        }
                    } catch (e) {
                        if (isArray(module)) {
                            module = module[module.length - 1];
                        }
                        if (e.message && e.stack && e.stack.indexOf(e.message) === -1) {
                            e = e.message + "\n" + e.stack;
                        }
                        throw $injectorMinErr("modulerr", "Failed to instantiate module {0} due to:\n{1}", module, e.stack || e.message || e);
                    }
                });
                return runBlocks;
            }
            function createInternalInjector(cache, factory) {
                function getService(serviceName, caller) {
                    if (cache.hasOwnProperty(serviceName)) {
                        if (cache[serviceName] === INSTANTIATING) {
                            throw $injectorMinErr("cdep", "Circular dependency found: {0}", serviceName + " <- " + path.join(" <- "));
                        }
                        return cache[serviceName];
                    } else {
                        try {
                            path.unshift(serviceName);
                            cache[serviceName] = INSTANTIATING;
                            cache[serviceName] = factory(serviceName, caller);
                            return cache[serviceName];
                        } catch (err) {
                            if (cache[serviceName] === INSTANTIATING) {
                                delete cache[serviceName];
                            }
                            throw err;
                        } finally {
                            path.shift();
                        }
                    }
                }
                function injectionArgs(fn, locals, serviceName) {
                    var args = [],
                        $inject = createInjector.$$annotate(fn, strictDi, serviceName);
                    for (var i = 0, length = $inject.length; i < length; i++) {
                        var key = $inject[i];
                        if (typeof key !== "string") {
                            throw $injectorMinErr("itkn", "Incorrect injection token! Expected service name as string, got {0}", key);
                        }
                        args.push(locals && locals.hasOwnProperty(key) ? locals[key] : getService(key, serviceName));
                    }
                    return args;
                }
                function isClass(func) {
                    if (msie || typeof func !== "function") {
                        return false;
                    }
                    var result = func.$$ngIsClass;
                    if (!isBoolean(result)) {
                        result = func.$$ngIsClass = /^(?:class\b|constructor\()/.test(stringifyFn(func));
                    }
                    return result;
                }
                function invoke(fn, self, locals, serviceName) {
                    if (typeof locals === "string") {
                        serviceName = locals;
                        locals = null;
                    }
                    var args = injectionArgs(fn, locals, serviceName);
                    if (isArray(fn)) {
                        fn = fn[fn.length - 1];
                    }
                    if (!isClass(fn)) {
                        return fn.apply(self, args);
                    } else {
                        args.unshift(null);
                        return new (Function.prototype.bind.apply(fn, args))();
                    }
                }
                function instantiate(Type, locals, serviceName) {
                    var ctor = isArray(Type) ? Type[Type.length - 1] : Type;
                    var args = injectionArgs(Type, locals, serviceName);
                    args.unshift(null);
                    return new (Function.prototype.bind.apply(ctor, args))();
                }
                return {
                    invoke: invoke,
                    instantiate: instantiate,
                    get: getService,
                    annotate: createInjector.$$annotate,
                    has: function (name) {
                        return providerCache.hasOwnProperty(name + providerSuffix) || cache.hasOwnProperty(name);
                    },
                };
            }
        }
        createInjector.$$annotate = annotate;
        function $AnchorScrollProvider() {
            var autoScrollingEnabled = true;
            this.disableAutoScrolling = function () {
                autoScrollingEnabled = false;
            };
            this.$get = [
                "$window",
                "$location",
                "$rootScope",
                function ($window, $location, $rootScope) {
                    var document = $window.document;
                    function getFirstAnchor(list) {
                        var result = null;
                        Array.prototype.some.call(list, function (element) {
                            if (nodeName_(element) === "a") {
                                result = element;
                                return true;
                            }
                        });
                        return result;
                    }
                    function getYOffset() {
                        var offset = scroll.yOffset;
                        if (isFunction(offset)) {
                            offset = offset();
                        } else if (isElement(offset)) {
                            var elem = offset[0];
                            var style = $window.getComputedStyle(elem);
                            if (style.position !== "fixed") {
                                offset = 0;
                            } else {
                                offset = elem.getBoundingClientRect().bottom;
                            }
                        } else if (!isNumber(offset)) {
                            offset = 0;
                        }
                        return offset;
                    }
                    function scrollTo(elem) {
                        if (elem) {
                            elem.scrollIntoView();
                            var offset = getYOffset();
                            if (offset) {
                                var elemTop = elem.getBoundingClientRect().top;
                                $window.scrollBy(0, elemTop - offset);
                            }
                        } else {
                            $window.scrollTo(0, 0);
                        }
                    }
                    function scroll(hash) {
                        hash = isString(hash) ? hash : isNumber(hash) ? hash.toString() : $location.hash();
                        var elm;
                        if (!hash) scrollTo(null);
                        else if ((elm = document.getElementById(hash))) scrollTo(elm);
                        else if ((elm = getFirstAnchor(document.getElementsByName(hash)))) scrollTo(elm);
                        else if (hash === "top") scrollTo(null);
                    }
                    if (autoScrollingEnabled) {
                        $rootScope.$watch(
                            function autoScrollWatch() {
                                return $location.hash();
                            },
                            function autoScrollWatchAction(newVal, oldVal) {
                                if (newVal === oldVal && newVal === "") return;
                                jqLiteDocumentLoaded(function () {
                                    $rootScope.$evalAsync(scroll);
                                });
                            }
                        );
                    }
                    return scroll;
                },
            ];
        }
        var $animateMinErr = minErr("$animate");
        var ELEMENT_NODE = 1;
        var NG_ANIMATE_CLASSNAME = "ng-animate";
        function mergeClasses(a, b) {
            if (!a && !b) return "";
            if (!a) return b;
            if (!b) return a;
            if (isArray(a)) a = a.join(" ");
            if (isArray(b)) b = b.join(" ");
            return a + " " + b;
        }
        function extractElementNode(element) {
            for (var i = 0; i < element.length; i++) {
                var elm = element[i];
                if (elm.nodeType === ELEMENT_NODE) {
                    return elm;
                }
            }
        }
        function splitClasses(classes) {
            if (isString(classes)) {
                classes = classes.split(" ");
            }
            var obj = createMap();
            forEach(classes, function (klass) {
                if (klass.length) {
                    obj[klass] = true;
                }
            });
            return obj;
        }
        function prepareAnimateOptions(options) {
            return isObject(options) ? options : {};
        }
        var $$CoreAnimateJsProvider = function () {
            this.$get = noop;
        };
        var $$CoreAnimateQueueProvider = function () {
            var postDigestQueue = new NgMap();
            var postDigestElements = [];
            this.$get = [
                "$$AnimateRunner",
                "$rootScope",
                function ($$AnimateRunner, $rootScope) {
                    return {
                        enabled: noop,
                        on: noop,
                        off: noop,
                        pin: noop,
                        push: function (element, event, options, domOperation) {
                            if (domOperation) {
                                domOperation();
                            }
                            options = options || {};
                            if (options.from) {
                                element.css(options.from);
                            }
                            if (options.to) {
                                element.css(options.to);
                            }
                            if (options.addClass || options.removeClass) {
                                addRemoveClassesPostDigest(element, options.addClass, options.removeClass);
                            }
                            var runner = new $$AnimateRunner();
                            runner.complete();
                            return runner;
                        },
                    };
                    function updateData(data, classes, value) {
                        var changed = false;
                        if (classes) {
                            classes = isString(classes) ? classes.split(" ") : isArray(classes) ? classes : [];
                            forEach(classes, function (className) {
                                if (className) {
                                    changed = true;
                                    data[className] = value;
                                }
                            });
                        }
                        return changed;
                    }
                    function handleCSSClassChanges() {
                        forEach(postDigestElements, function (element) {
                            var data = postDigestQueue.get(element);
                            if (data) {
                                var existing = splitClasses(element.attr("class"));
                                var toAdd = "";
                                var toRemove = "";
                                forEach(data, function (status, className) {
                                    var hasClass = !!existing[className];
                                    if (status !== hasClass) {
                                        if (status) {
                                            toAdd += (toAdd.length ? " " : "") + className;
                                        } else {
                                            toRemove += (toRemove.length ? " " : "") + className;
                                        }
                                    }
                                });
                                forEach(element, function (elm) {
                                    if (toAdd) {
                                        jqLiteAddClass(elm, toAdd);
                                    }
                                    if (toRemove) {
                                        jqLiteRemoveClass(elm, toRemove);
                                    }
                                });
                                postDigestQueue.delete(element);
                            }
                        });
                        postDigestElements.length = 0;
                    }
                    function addRemoveClassesPostDigest(element, add, remove) {
                        var data = postDigestQueue.get(element) || {};
                        var classesAdded = updateData(data, add, true);
                        var classesRemoved = updateData(data, remove, false);
                        if (classesAdded || classesRemoved) {
                            postDigestQueue.set(element, data);
                            postDigestElements.push(element);
                            if (postDigestElements.length === 1) {
                                $rootScope.$$postDigest(handleCSSClassChanges);
                            }
                        }
                    }
                },
            ];
        };
        var $AnimateProvider = [
            "$provide",
            function ($provide) {
                var provider = this;
                var classNameFilter = null;
                this.$$registeredAnimations = Object.create(null);
                this.register = function (name, factory) {
                    if (name && name.charAt(0) !== ".") {
                        throw $animateMinErr("notcsel", "Expecting class selector starting with '.' got '{0}'.", name);
                    }
                    var key = name + "-animation";
                    provider.$$registeredAnimations[name.substr(1)] = key;
                    $provide.factory(key, factory);
                };
                this.classNameFilter = function (expression) {
                    if (arguments.length === 1) {
                        classNameFilter = expression instanceof RegExp ? expression : null;
                        if (classNameFilter) {
                            var reservedRegex = new RegExp("[(\\s|\\/)]" + NG_ANIMATE_CLASSNAME + "[(\\s|\\/)]");
                            if (reservedRegex.test(classNameFilter.toString())) {
                                classNameFilter = null;
                                throw $animateMinErr("nongcls", '$animateProvider.classNameFilter(regex) prohibits accepting a regex value which matches/contains the "{0}" CSS class.', NG_ANIMATE_CLASSNAME);
                            }
                        }
                    }
                    return classNameFilter;
                };
                this.$get = [
                    "$$animateQueue",
                    function ($$animateQueue) {
                        function domInsert(element, parentElement, afterElement) {
                            if (afterElement) {
                                var afterNode = extractElementNode(afterElement);
                                if (afterNode && !afterNode.parentNode && !afterNode.previousElementSibling) {
                                    afterElement = null;
                                }
                            }
                            if (afterElement) {
                                afterElement.after(element);
                            } else {
                                parentElement.prepend(element);
                            }
                        }
                        return {
                            on: $$animateQueue.on,
                            off: $$animateQueue.off,
                            pin: $$animateQueue.pin,
                            enabled: $$animateQueue.enabled,
                            cancel: function (runner) {
                                if (runner.end) {
                                    runner.end();
                                }
                            },
                            enter: function (element, parent, after, options) {
                                parent = parent && jqLite(parent);
                                after = after && jqLite(after);
                                parent = parent || after.parent();
                                domInsert(element, parent, after);
                                return $$animateQueue.push(element, "enter", prepareAnimateOptions(options));
                            },
                            move: function (element, parent, after, options) {
                                parent = parent && jqLite(parent);
                                after = after && jqLite(after);
                                parent = parent || after.parent();
                                domInsert(element, parent, after);
                                return $$animateQueue.push(element, "move", prepareAnimateOptions(options));
                            },
                            leave: function (element, options) {
                                return $$animateQueue.push(element, "leave", prepareAnimateOptions(options), function () {
                                    element.remove();
                                });
                            },
                            addClass: function (element, className, options) {
                                options = prepareAnimateOptions(options);
                                options.addClass = mergeClasses(options.addclass, className);
                                return $$animateQueue.push(element, "addClass", options);
                            },
                            removeClass: function (element, className, options) {
                                options = prepareAnimateOptions(options);
                                options.removeClass = mergeClasses(options.removeClass, className);
                                return $$animateQueue.push(element, "removeClass", options);
                            },
                            setClass: function (element, add, remove, options) {
                                options = prepareAnimateOptions(options);
                                options.addClass = mergeClasses(options.addClass, add);
                                options.removeClass = mergeClasses(options.removeClass, remove);
                                return $$animateQueue.push(element, "setClass", options);
                            },
                            animate: function (element, from, to, className, options) {
                                options = prepareAnimateOptions(options);
                                options.from = options.from ? extend(options.from, from) : from;
                                options.to = options.to ? extend(options.to, to) : to;
                                className = className || "ng-inline-animate";
                                options.tempClasses = mergeClasses(options.tempClasses, className);
                                return $$animateQueue.push(element, "animate", options);
                            },
                        };
                    },
                ];
            },
        ];
        var $$AnimateAsyncRunFactoryProvider = function () {
            this.$get = [
                "$$rAF",
                function ($$rAF) {
                    var waitQueue = [];
                    function waitForTick(fn) {
                        waitQueue.push(fn);
                        if (waitQueue.length > 1) return;
                        $$rAF(function () {
                            for (var i = 0; i < waitQueue.length; i++) {
                                waitQueue[i]();
                            }
                            waitQueue = [];
                        });
                    }
                    return function () {
                        var passed = false;
                        waitForTick(function () {
                            passed = true;
                        });
                        return function (callback) {
                            if (passed) {
                                callback();
                            } else {
                                waitForTick(callback);
                            }
                        };
                    };
                },
            ];
        };
        var $$AnimateRunnerFactoryProvider = function () {
            this.$get = [
                "$q",
                "$sniffer",
                "$$animateAsyncRun",
                "$$isDocumentHidden",
                "$timeout",
                function ($q, $sniffer, $$animateAsyncRun, $$isDocumentHidden, $timeout) {
                    var INITIAL_STATE = 0;
                    var DONE_PENDING_STATE = 1;
                    var DONE_COMPLETE_STATE = 2;
                    AnimateRunner.chain = function (chain, callback) {
                        var index = 0;
                        next();
                        function next() {
                            if (index === chain.length) {
                                callback(true);
                                return;
                            }
                            chain[index](function (response) {
                                if (response === false) {
                                    callback(false);
                                    return;
                                }
                                index++;
                                next();
                            });
                        }
                    };
                    AnimateRunner.all = function (runners, callback) {
                        var count = 0;
                        var status = true;
                        forEach(runners, function (runner) {
                            runner.done(onProgress);
                        });
                        function onProgress(response) {
                            status = status && response;
                            if (++count === runners.length) {
                                callback(status);
                            }
                        }
                    };
                    function AnimateRunner(host) {
                        this.setHost(host);
                        var rafTick = $$animateAsyncRun();
                        var timeoutTick = function (fn) {
                            $timeout(fn, 0, false);
                        };
                        this._doneCallbacks = [];
                        this._tick = function (fn) {
                            if ($$isDocumentHidden()) {
                                timeoutTick(fn);
                            } else {
                                rafTick(fn);
                            }
                        };
                        this._state = 0;
                    }
                    AnimateRunner.prototype = {
                        setHost: function (host) {
                            this.host = host || {};
                        },
                        done: function (fn) {
                            if (this._state === DONE_COMPLETE_STATE) {
                                fn();
                            } else {
                                this._doneCallbacks.push(fn);
                            }
                        },
                        progress: noop,
                        getPromise: function () {
                            if (!this.promise) {
                                var self = this;
                                this.promise = $q(function (resolve, reject) {
                                    self.done(function (status) {
                                        if (status === false) {
                                            reject();
                                        } else {
                                            resolve();
                                        }
                                    });
                                });
                            }
                            return this.promise;
                        },
                        then: function (resolveHandler, rejectHandler) {
                            return this.getPromise().then(resolveHandler, rejectHandler);
                        },
                        catch: function (handler) {
                            return this.getPromise()["catch"](handler);
                        },
                        finally: function (handler) {
                            return this.getPromise()["finally"](handler);
                        },
                        pause: function () {
                            if (this.host.pause) {
                                this.host.pause();
                            }
                        },
                        resume: function () {
                            if (this.host.resume) {
                                this.host.resume();
                            }
                        },
                        end: function () {
                            if (this.host.end) {
                                this.host.end();
                            }
                            this._resolve(true);
                        },
                        cancel: function () {
                            if (this.host.cancel) {
                                this.host.cancel();
                            }
                            this._resolve(false);
                        },
                        complete: function (response) {
                            var self = this;
                            if (self._state === INITIAL_STATE) {
                                self._state = DONE_PENDING_STATE;
                                self._tick(function () {
                                    self._resolve(response);
                                });
                            }
                        },
                        _resolve: function (response) {
                            if (this._state !== DONE_COMPLETE_STATE) {
                                forEach(this._doneCallbacks, function (fn) {
                                    fn(response);
                                });
                                this._doneCallbacks.length = 0;
                                this._state = DONE_COMPLETE_STATE;
                            }
                        },
                    };
                    return AnimateRunner;
                },
            ];
        };
        var $CoreAnimateCssProvider = function () {
            this.$get = [
                "$$rAF",
                "$q",
                "$$AnimateRunner",
                function ($$rAF, $q, $$AnimateRunner) {
                    return function (element, initialOptions) {
                        var options = initialOptions || {};
                        if (!options.$$prepared) {
                            options = copy(options);
                        }
                        if (options.cleanupStyles) {
                            options.from = options.to = null;
                        }
                        if (options.from) {
                            element.css(options.from);
                            options.from = null;
                        }
                        var closed,
                            runner = new $$AnimateRunner();
                        return { start: run, end: run };
                        function run() {
                            $$rAF(function () {
                                applyAnimationContents();
                                if (!closed) {
                                    runner.complete();
                                }
                                closed = true;
                            });
                            return runner;
                        }
                        function applyAnimationContents() {
                            if (options.addClass) {
                                element.addClass(options.addClass);
                                options.addClass = null;
                            }
                            if (options.removeClass) {
                                element.removeClass(options.removeClass);
                                options.removeClass = null;
                            }
                            if (options.to) {
                                element.css(options.to);
                                options.to = null;
                            }
                        }
                    };
                },
            ];
        };
        function Browser(window, document, $log, $sniffer) {
            var self = this,
                location = window.location,
                history = window.history,
                setTimeout = window.setTimeout,
                clearTimeout = window.clearTimeout,
                pendingDeferIds = {};
            self.isMock = false;
            var outstandingRequestCount = 0;
            var outstandingRequestCallbacks = [];
            self.$$completeOutstandingRequest = completeOutstandingRequest;
            self.$$incOutstandingRequestCount = function () {
                outstandingRequestCount++;
            };
            function completeOutstandingRequest(fn) {
                try {
                    fn.apply(null, sliceArgs(arguments, 1));
                } finally {
                    outstandingRequestCount--;
                    if (outstandingRequestCount === 0) {
                        while (outstandingRequestCallbacks.length) {
                            try {
                                outstandingRequestCallbacks.pop()();
                            } catch (e) {
                                $log.error(e);
                            }
                        }
                    }
                }
            }
            function getHash(url) {
                var index = url.indexOf("#");
                return index === -1 ? "" : url.substr(index);
            }
            self.notifyWhenNoOutstandingRequests = function (callback) {
                if (outstandingRequestCount === 0) {
                    callback();
                } else {
                    outstandingRequestCallbacks.push(callback);
                }
            };
            var cachedState,
                lastHistoryState,
                lastBrowserUrl = location.href,
                baseElement = document.find("base"),
                pendingLocation = null,
                getCurrentState = !$sniffer.history
                    ? noop
                    : function getCurrentState() {
                        try {
                            return history.state;
                        } catch (e) { }
                    };
            cacheState();
            self.url = function (url, replace, state) {
                if (isUndefined(state)) {
                    state = null;
                }
                if (location !== window.location) location = window.location;
                if (history !== window.history) history = window.history;
                if (url) {
                    var sameState = lastHistoryState === state;
                    if (lastBrowserUrl === url && (!$sniffer.history || sameState)) {
                        return self;
                    }
                    var sameBase = lastBrowserUrl && stripHash(lastBrowserUrl) === stripHash(url);
                    lastBrowserUrl = url;
                    lastHistoryState = state;
                    if ($sniffer.history && (!sameBase || !sameState)) {
                        history[replace ? "replaceState" : "pushState"](state, "", url);
                        cacheState();
                    } else {
                        if (!sameBase) {
                            pendingLocation = url;
                        }
                        if (replace) {
                            location.replace(url);
                        } else if (!sameBase) {
                            location.href = url;
                        } else {
                            location.hash = getHash(url);
                        }
                        if (location.href !== url) {
                            pendingLocation = url;
                        }
                    }
                    if (pendingLocation) {
                        pendingLocation = url;
                    }
                    return self;
                } else {
                    return pendingLocation || location.href.replace(/%27/g, "'");
                }
            };
            self.state = function () {
                return cachedState;
            };
            var urlChangeListeners = [],
                urlChangeInit = false;
            function cacheStateAndFireUrlChange() {
                pendingLocation = null;
                fireStateOrUrlChange();
            }
            var lastCachedState = null;
            function cacheState() {
                cachedState = getCurrentState();
                cachedState = isUndefined(cachedState) ? null : cachedState;
                if (equals(cachedState, lastCachedState)) {
                    cachedState = lastCachedState;
                }
                lastCachedState = cachedState;
                lastHistoryState = cachedState;
            }
            function fireStateOrUrlChange() {
                var prevLastHistoryState = lastHistoryState;
                cacheState();
                if (lastBrowserUrl === self.url() && prevLastHistoryState === cachedState) {
                    return;
                }
                lastBrowserUrl = self.url();
                lastHistoryState = cachedState;
                forEach(urlChangeListeners, function (listener) {
                    listener(self.url(), cachedState);
                });
            }
            self.onUrlChange = function (callback) {
                if (!urlChangeInit) {
                    if ($sniffer.history) jqLite(window).on("popstate", cacheStateAndFireUrlChange);
                    jqLite(window).on("hashchange", cacheStateAndFireUrlChange);
                    urlChangeInit = true;
                }
                urlChangeListeners.push(callback);
                return callback;
            };
            self.$$applicationDestroyed = function () {
                jqLite(window).off("hashchange popstate", cacheStateAndFireUrlChange);
            };
            self.$$checkUrlChange = fireStateOrUrlChange;
            self.baseHref = function () {
                var href = baseElement.attr("href");
                return href ? href.replace(/^(https?:)?\/\/[^\/]*/, "") : "";
            };
            self.defer = function (fn, delay) {
                var timeoutId;
                outstandingRequestCount++;
                timeoutId = setTimeout(function () {
                    delete pendingDeferIds[timeoutId];
                    completeOutstandingRequest(fn);
                }, delay || 0);
                pendingDeferIds[timeoutId] = true;
                return timeoutId;
            };
            self.defer.cancel = function (deferId) {
                if (pendingDeferIds[deferId]) {
                    delete pendingDeferIds[deferId];
                    clearTimeout(deferId);
                    completeOutstandingRequest(noop);
                    return true;
                }
                return false;
            };
        }
        function $BrowserProvider() {
            this.$get = [
                "$window",
                "$log",
                "$sniffer",
                "$document",
                function ($window, $log, $sniffer, $document) {
                    return new Browser($window, $document, $log, $sniffer);
                },
            ];
        }
        function $CacheFactoryProvider() {
            this.$get = function () {
                var caches = {};
                function cacheFactory(cacheId, options) {
                    if (cacheId in caches) {
                        throw minErr("$cacheFactory")("iid", "CacheId '{0}' is already taken!", cacheId);
                    }
                    var size = 0,
                        stats = extend({}, options, { id: cacheId }),
                        data = createMap(),
                        capacity = (options && options.capacity) || Number.MAX_VALUE,
                        lruHash = createMap(),
                        freshEnd = null,
                        staleEnd = null;
                    return (caches[cacheId] = {
                        put: function (key, value) {
                            if (isUndefined(value)) return;
                            if (capacity < Number.MAX_VALUE) {
                                var lruEntry = lruHash[key] || (lruHash[key] = { key: key });
                                refresh(lruEntry);
                            }
                            if (!(key in data)) size++;
                            data[key] = value;
                            if (size > capacity) {
                                this.remove(staleEnd.key);
                            }
                            return value;
                        },
                        get: function (key) {
                            if (capacity < Number.MAX_VALUE) {
                                var lruEntry = lruHash[key];
                                if (!lruEntry) return;
                                refresh(lruEntry);
                            }
                            return data[key];
                        },
                        remove: function (key) {
                            if (capacity < Number.MAX_VALUE) {
                                var lruEntry = lruHash[key];
                                if (!lruEntry) return;
                                if (lruEntry === freshEnd) freshEnd = lruEntry.p;
                                if (lruEntry === staleEnd) staleEnd = lruEntry.n;
                                link(lruEntry.n, lruEntry.p);
                                delete lruHash[key];
                            }
                            if (!(key in data)) return;
                            delete data[key];
                            size--;
                        },
                        removeAll: function () {
                            data = createMap();
                            size = 0;
                            lruHash = createMap();
                            freshEnd = staleEnd = null;
                        },
                        destroy: function () {
                            data = null;
                            stats = null;
                            lruHash = null;
                            delete caches[cacheId];
                        },
                        info: function () {
                            return extend({}, stats, { size: size });
                        },
                    });
                    function refresh(entry) {
                        if (entry !== freshEnd) {
                            if (!staleEnd) {
                                staleEnd = entry;
                            } else if (staleEnd === entry) {
                                staleEnd = entry.n;
                            }
                            link(entry.n, entry.p);
                            link(entry, freshEnd);
                            freshEnd = entry;
                            freshEnd.n = null;
                        }
                    }
                    function link(nextEntry, prevEntry) {
                        if (nextEntry !== prevEntry) {
                            if (nextEntry) nextEntry.p = prevEntry;
                            if (prevEntry) prevEntry.n = nextEntry;
                        }
                    }
                }
                cacheFactory.info = function () {
                    var info = {};
                    forEach(caches, function (cache, cacheId) {
                        info[cacheId] = cache.info();
                    });
                    return info;
                };
                cacheFactory.get = function (cacheId) {
                    return caches[cacheId];
                };
                return cacheFactory;
            };
        }
        function $TemplateCacheProvider() {
            this.$get = [
                "$cacheFactory",
                function ($cacheFactory) {
                    return $cacheFactory("templates");
                },
            ];
        }
        var $compileMinErr = minErr("$compile");
        function UNINITIALIZED_VALUE() { }
        var _UNINITIALIZED_VALUE = new UNINITIALIZED_VALUE();
        $CompileProvider.$inject = ["$provide", "$$sanitizeUriProvider"];
        function $CompileProvider($provide, $$sanitizeUriProvider) {
            var hasDirectives = {},
                Suffix = "Directive",
                COMMENT_DIRECTIVE_REGEXP = /^\s*directive:\s*([\w-]+)\s+(.*)$/,
                CLASS_DIRECTIVE_REGEXP = /(([\w-]+)(?::([^;]+))?;?)/,
                ALL_OR_NOTHING_ATTRS = makeMap("ngSrc,ngSrcset,src,srcset"),
                REQUIRE_PREFIX_REGEXP = /^(?:(\^\^?)?(\?)?(\^\^?)?)?/;
            var EVENT_HANDLER_ATTR_REGEXP = /^(on[a-z]+|formaction)$/;
            var bindingCache = createMap();
            function parseIsolateBindings(scope, directiveName, isController) {
                var LOCAL_REGEXP = /^\s*([@&<]|=(\*?))(\??)\s*([\w$]*)\s*$/;
                var bindings = createMap();
                forEach(scope, function (definition, scopeName) {
                    if (definition in bindingCache) {
                        bindings[scopeName] = bindingCache[definition];
                        return;
                    }
                    var match = definition.match(LOCAL_REGEXP);
                    if (!match) {
                        throw $compileMinErr(
                            "iscp",
                            "Invalid {3} for directive '{0}'." + " Definition: {... {1}: '{2}' ...}",
                            directiveName,
                            scopeName,
                            definition,
                            isController ? "controller bindings definition" : "isolate scope definition"
                        );
                    }
                    bindings[scopeName] = { mode: match[1][0], collection: match[2] === "*", optional: match[3] === "?", attrName: match[4] || scopeName };
                    if (match[4]) {
                        bindingCache[definition] = bindings[scopeName];
                    }
                });
                return bindings;
            }
            function parseDirectiveBindings(directive, directiveName) {
                var bindings = { isolateScope: null, bindToController: null };
                if (isObject(directive.scope)) {
                    if (directive.bindToController === true) {
                        bindings.bindToController = parseIsolateBindings(directive.scope, directiveName, true);
                        bindings.isolateScope = {};
                    } else {
                        bindings.isolateScope = parseIsolateBindings(directive.scope, directiveName, false);
                    }
                }
                if (isObject(directive.bindToController)) {
                    bindings.bindToController = parseIsolateBindings(directive.bindToController, directiveName, true);
                }
                if (bindings.bindToController && !directive.controller) {
                    throw $compileMinErr("noctrl", "Cannot bind to controller without directive '{0}'s controller.", directiveName);
                }
                return bindings;
            }
            function assertValidDirectiveName(name) {
                var letter = name.charAt(0);
                if (!letter || letter !== lowercase(letter)) {
                    throw $compileMinErr("baddir", "Directive/Component name '{0}' is invalid. The first character must be a lowercase letter", name);
                }
                if (name !== name.trim()) {
                    throw $compileMinErr("baddir", "Directive/Component name '{0}' is invalid. The name should not contain leading or trailing whitespaces", name);
                }
            }
            function getDirectiveRequire(directive) {
                var require = directive.require || (directive.controller && directive.name);
                if (!isArray(require) && isObject(require)) {
                    forEach(require, function (value, key) {
                        var match = value.match(REQUIRE_PREFIX_REGEXP);
                        var name = value.substring(match[0].length);
                        if (!name) require[key] = match[0] + key;
                    });
                }
                return require;
            }
            function getDirectiveRestrict(restrict, name) {
                if (restrict && !(isString(restrict) && /[EACM]/.test(restrict))) {
                    throw $compileMinErr("badrestrict", "Restrict property '{0}' of directive '{1}' is invalid", restrict, name);
                }
                return restrict || "EA";
            }
            this.directive = function registerDirective(name, directiveFactory) {
                assertArg(name, "name");
                assertNotHasOwnProperty(name, "directive");
                if (isString(name)) {
                    assertValidDirectiveName(name);
                    assertArg(directiveFactory, "directiveFactory");
                    if (!hasDirectives.hasOwnProperty(name)) {
                        hasDirectives[name] = [];
                        $provide.factory(name + Suffix, [
                            "$injector",
                            "$exceptionHandler",
                            function ($injector, $exceptionHandler) {
                                var directives = [];
                                forEach(hasDirectives[name], function (directiveFactory, index) {
                                    try {
                                        var directive = $injector.invoke(directiveFactory);
                                        if (isFunction(directive)) {
                                            directive = { compile: valueFn(directive) };
                                        } else if (!directive.compile && directive.link) {
                                            directive.compile = valueFn(directive.link);
                                        }
                                        directive.priority = directive.priority || 0;
                                        directive.index = index;
                                        directive.name = directive.name || name;
                                        directive.require = getDirectiveRequire(directive);
                                        directive.restrict = getDirectiveRestrict(directive.restrict, name);
                                        directive.$$moduleName = directiveFactory.$$moduleName;
                                        directives.push(directive);
                                    } catch (e) {
                                        $exceptionHandler(e);
                                    }
                                });
                                return directives;
                            },
                        ]);
                    }
                    hasDirectives[name].push(directiveFactory);
                } else {
                    forEach(name, reverseParams(registerDirective));
                }
                return this;
            };
            this.component = function registerComponent(name, options) {
                var controller = options.controller || function () { };
                function factory($injector) {
                    function makeInjectable(fn) {
                        if (isFunction(fn) || isArray(fn)) {
                            return function (tElement, tAttrs) {
                                return $injector.invoke(fn, this, { $element: tElement, $attrs: tAttrs });
                            };
                        } else {
                            return fn;
                        }
                    }
                    var template = !options.template && !options.templateUrl ? "" : options.template;
                    var ddo = {
                        controller: controller,
                        controllerAs: identifierForController(options.controller) || options.controllerAs || "$ctrl",
                        template: makeInjectable(template),
                        templateUrl: makeInjectable(options.templateUrl),
                        transclude: options.transclude,
                        scope: {},
                        bindToController: options.bindings || {},
                        restrict: "E",
                        require: options.require,
                    };
                    forEach(options, function (val, key) {
                        if (key.charAt(0) === "$") ddo[key] = val;
                    });
                    return ddo;
                }
                forEach(options, function (val, key) {
                    if (key.charAt(0) === "$") {
                        factory[key] = val;
                        if (isFunction(controller)) controller[key] = val;
                    }
                });
                factory.$inject = ["$injector"];
                return this.directive(name, factory);
            };
            this.aHrefSanitizationWhitelist = function (regexp) {
                if (isDefined(regexp)) {
                    $$sanitizeUriProvider.aHrefSanitizationWhitelist(regexp);
                    return this;
                } else {
                    return $$sanitizeUriProvider.aHrefSanitizationWhitelist();
                }
            };
            this.imgSrcSanitizationWhitelist = function (regexp) {
                if (isDefined(regexp)) {
                    $$sanitizeUriProvider.imgSrcSanitizationWhitelist(regexp);
                    return this;
                } else {
                    return $$sanitizeUriProvider.imgSrcSanitizationWhitelist();
                }
            };
            var debugInfoEnabled = true;
            this.debugInfoEnabled = function (enabled) {
                if (isDefined(enabled)) {
                    debugInfoEnabled = enabled;
                    return this;
                }
                return debugInfoEnabled;
            };
            var preAssignBindingsEnabled = false;
            this.preAssignBindingsEnabled = function (enabled) {
                if (isDefined(enabled)) {
                    preAssignBindingsEnabled = enabled;
                    return this;
                }
                return preAssignBindingsEnabled;
            };
            var TTL = 10;
            this.onChangesTtl = function (value) {
                if (arguments.length) {
                    TTL = value;
                    return this;
                }
                return TTL;
            };
            var commentDirectivesEnabledConfig = true;
            this.commentDirectivesEnabled = function (value) {
                if (arguments.length) {
                    commentDirectivesEnabledConfig = value;
                    return this;
                }
                return commentDirectivesEnabledConfig;
            };
            var cssClassDirectivesEnabledConfig = true;
            this.cssClassDirectivesEnabled = function (value) {
                if (arguments.length) {
                    cssClassDirectivesEnabledConfig = value;
                    return this;
                }
                return cssClassDirectivesEnabledConfig;
            };
            this.$get = [
                "$injector",
                "$interpolate",
                "$exceptionHandler",
                "$templateRequest",
                "$parse",
                "$controller",
                "$rootScope",
                "$sce",
                "$animate",
                "$$sanitizeUri",
                function ($injector, $interpolate, $exceptionHandler, $templateRequest, $parse, $controller, $rootScope, $sce, $animate, $$sanitizeUri) {
                    var SIMPLE_ATTR_NAME = /^\w/;
                    var specialAttrHolder = window.document.createElement("div");
                    var commentDirectivesEnabled = commentDirectivesEnabledConfig;
                    var cssClassDirectivesEnabled = cssClassDirectivesEnabledConfig;
                    var onChangesTtl = TTL;
                    var onChangesQueue;
                    function flushOnChangesQueue() {
                        try {
                            if (!--onChangesTtl) {
                                onChangesQueue = undefined;
                                throw $compileMinErr("infchng", "{0} $onChanges() iterations reached. Aborting!\n", TTL);
                            }
                            $rootScope.$apply(function () {
                                var errors = [];
                                for (var i = 0, ii = onChangesQueue.length; i < ii; ++i) {
                                    try {
                                        onChangesQueue[i]();
                                    } catch (e) {
                                        errors.push(e);
                                    }
                                }
                                onChangesQueue = undefined;
                                if (errors.length) {
                                    throw errors;
                                }
                            });
                        } finally {
                            onChangesTtl++;
                        }
                    }
                    function Attributes(element, attributesToCopy) {
                        if (attributesToCopy) {
                            var keys = Object.keys(attributesToCopy);
                            var i, l, key;
                            for (i = 0, l = keys.length; i < l; i++) {
                                key = keys[i];
                                this[key] = attributesToCopy[key];
                            }
                        } else {
                            this.$attr = {};
                        }
                        this.$$element = element;
                    }
                    Attributes.prototype = {
                        $normalize: directiveNormalize,
                        $addClass: function (classVal) {
                            if (classVal && classVal.length > 0) {
                                $animate.addClass(this.$$element, classVal);
                            }
                        },
                        $removeClass: function (classVal) {
                            if (classVal && classVal.length > 0) {
                                $animate.removeClass(this.$$element, classVal);
                            }
                        },
                        $updateClass: function (newClasses, oldClasses) {
                            var toAdd = tokenDifference(newClasses, oldClasses);
                            if (toAdd && toAdd.length) {
                                $animate.addClass(this.$$element, toAdd);
                            }
                            var toRemove = tokenDifference(oldClasses, newClasses);
                            if (toRemove && toRemove.length) {
                                $animate.removeClass(this.$$element, toRemove);
                            }
                        },
                        $set: function (key, value, writeAttr, attrName) {
                            var node = this.$$element[0],
                                booleanKey = getBooleanAttrName(node, key),
                                aliasedKey = getAliasedAttrName(key),
                                observer = key,
                                nodeName;
                            if (booleanKey) {
                                this.$$element.prop(key, value);
                                attrName = booleanKey;
                            } else if (aliasedKey) {
                                this[aliasedKey] = value;
                                observer = aliasedKey;
                            }
                            this[key] = value;
                            if (attrName) {
                                this.$attr[key] = attrName;
                            } else {
                                attrName = this.$attr[key];
                                if (!attrName) {
                                    this.$attr[key] = attrName = snake_case(key, "-");
                                }
                            }
                            nodeName = nodeName_(this.$$element);
                            if ((nodeName === "a" && (key === "href" || key === "xlinkHref")) || (nodeName === "img" && key === "src")) {
                                this[key] = value = $$sanitizeUri(value, key === "src");
                            } else if (nodeName === "img" && key === "srcset" && isDefined(value)) {
                                var result = "";
                                var trimmedSrcset = trim(value);
                                var srcPattern = /(\s+\d+x\s*,|\s+\d+w\s*,|\s+,|,\s+)/;
                                var pattern = /\s/.test(trimmedSrcset) ? srcPattern : /(,)/;
                                var rawUris = trimmedSrcset.split(pattern);
                                var nbrUrisWith2parts = Math.floor(rawUris.length / 2);
                                for (var i = 0; i < nbrUrisWith2parts; i++) {
                                    var innerIdx = i * 2;
                                    result += $$sanitizeUri(trim(rawUris[innerIdx]), true);
                                    result += " " + trim(rawUris[innerIdx + 1]);
                                }
                                var lastTuple = trim(rawUris[i * 2]).split(/\s/);
                                result += $$sanitizeUri(trim(lastTuple[0]), true);
                                if (lastTuple.length === 2) {
                                    result += " " + trim(lastTuple[1]);
                                }
                                this[key] = value = result;
                            }
                            if (writeAttr !== false) {
                                if (value === null || isUndefined(value)) {
                                    this.$$element.removeAttr(attrName);
                                } else {
                                    if (SIMPLE_ATTR_NAME.test(attrName)) {
                                        this.$$element.attr(attrName, value);
                                    } else {
                                        setSpecialAttr(this.$$element[0], attrName, value);
                                    }
                                }
                            }
                            var $$observers = this.$$observers;
                            if ($$observers) {
                                forEach($$observers[observer], function (fn) {
                                    try {
                                        fn(value);
                                    } catch (e) {
                                        $exceptionHandler(e);
                                    }
                                });
                            }
                        },
                        $observe: function (key, fn) {
                            var attrs = this,
                                $$observers = attrs.$$observers || (attrs.$$observers = createMap()),
                                listeners = $$observers[key] || ($$observers[key] = []);
                            listeners.push(fn);
                            $rootScope.$evalAsync(function () {
                                if (!listeners.$$inter && attrs.hasOwnProperty(key) && !isUndefined(attrs[key])) {
                                    fn(attrs[key]);
                                }
                            });
                            return function () {
                                arrayRemove(listeners, fn);
                            };
                        },
                    };
                    function setSpecialAttr(element, attrName, value) {
                        specialAttrHolder.innerHTML = "<span " + attrName + ">";
                        var attributes = specialAttrHolder.firstChild.attributes;
                        var attribute = attributes[0];
                        attributes.removeNamedItem(attribute.name);
                        attribute.value = value;
                        element.attributes.setNamedItem(attribute);
                    }
                    function safeAddClass($element, className) {
                        try {
                            $element.addClass(className);
                        } catch (e) { }
                    }
                    var startSymbol = $interpolate.startSymbol(),
                        endSymbol = $interpolate.endSymbol(),
                        denormalizeTemplate =
                            startSymbol === "{{" && endSymbol === "}}"
                                ? identity
                                : function denormalizeTemplate(template) {
                                    return template.replace(/\{\{/g, startSymbol).replace(/}}/g, endSymbol);
                                },
                        NG_ATTR_BINDING = /^ngAttr[A-Z]/;
                    var MULTI_ELEMENT_DIR_RE = /^(.+)Start$/;
                    compile.$$addBindingInfo = debugInfoEnabled
                        ? function $$addBindingInfo($element, binding) {
                            var bindings = $element.data("$binding") || [];
                            if (isArray(binding)) {
                                bindings = bindings.concat(binding);
                            } else {
                                bindings.push(binding);
                            }
                            $element.data("$binding", bindings);
                        }
                        : noop;
                    compile.$$addBindingClass = debugInfoEnabled
                        ? function $$addBindingClass($element) {
                            safeAddClass($element, "ng-binding");
                        }
                        : noop;
                    compile.$$addScopeInfo = debugInfoEnabled
                        ? function $$addScopeInfo($element, scope, isolated, noTemplate) {
                            var dataName = isolated ? (noTemplate ? "$isolateScopeNoTemplate" : "$isolateScope") : "$scope";
                            $element.data(dataName, scope);
                        }
                        : noop;
                    compile.$$addScopeClass = debugInfoEnabled
                        ? function $$addScopeClass($element, isolated) {
                            safeAddClass($element, isolated ? "ng-isolate-scope" : "ng-scope");
                        }
                        : noop;
                    compile.$$createComment = function (directiveName, comment) {
                        var content = "";
                        if (debugInfoEnabled) {
                            content = " " + (directiveName || "") + ": ";
                            if (comment) content += comment + " ";
                        }
                        return window.document.createComment(content);
                    };
                    return compile;
                    function compile($compileNodes, transcludeFn, maxPriority, ignoreDirective, previousCompileContext) {
                        if (!($compileNodes instanceof jqLite)) {
                            $compileNodes = jqLite($compileNodes);
                        }
                        var compositeLinkFn = compileNodes($compileNodes, transcludeFn, $compileNodes, maxPriority, ignoreDirective, previousCompileContext);
                        compile.$$addScopeClass($compileNodes);
                        var namespace = null;
                        return function publicLinkFn(scope, cloneConnectFn, options) {
                            if (!$compileNodes) {
                                throw $compileMinErr("multilink", "This element has already been linked.");
                            }
                            assertArg(scope, "scope");
                            if (previousCompileContext && previousCompileContext.needsNewScope) {
                                scope = scope.$parent.$new();
                            }
                            options = options || {};
                            var parentBoundTranscludeFn = options.parentBoundTranscludeFn,
                                transcludeControllers = options.transcludeControllers,
                                futureParentElement = options.futureParentElement;
                            if (parentBoundTranscludeFn && parentBoundTranscludeFn.$$boundTransclude) {
                                parentBoundTranscludeFn = parentBoundTranscludeFn.$$boundTransclude;
                            }
                            if (!namespace) {
                                namespace = detectNamespaceForChildElements(futureParentElement);
                            }
                            var $linkNode;
                            if (namespace !== "html") {
                                $linkNode = jqLite(wrapTemplate(namespace, jqLite("<div>").append($compileNodes).html()));
                            } else if (cloneConnectFn) {
                                $linkNode = JQLitePrototype.clone.call($compileNodes);
                            } else {
                                $linkNode = $compileNodes;
                            }
                            if (transcludeControllers) {
                                for (var controllerName in transcludeControllers) {
                                    $linkNode.data("$" + controllerName + "Controller", transcludeControllers[controllerName].instance);
                                }
                            }
                            compile.$$addScopeInfo($linkNode, scope);
                            if (cloneConnectFn) cloneConnectFn($linkNode, scope);
                            if (compositeLinkFn) compositeLinkFn(scope, $linkNode, $linkNode, parentBoundTranscludeFn);
                            if (!cloneConnectFn) {
                                $compileNodes = compositeLinkFn = null;
                            }
                            return $linkNode;
                        };
                    }
                    function detectNamespaceForChildElements(parentElement) {
                        var node = parentElement && parentElement[0];
                        if (!node) {
                            return "html";
                        } else {
                            return nodeName_(node) !== "foreignobject" && toString.call(node).match(/SVG/) ? "svg" : "html";
                        }
                    }
                    function compileNodes(nodeList, transcludeFn, $rootElement, maxPriority, ignoreDirective, previousCompileContext) {
                        var linkFns = [],
                            notLiveList = isArray(nodeList) || nodeList instanceof jqLite,
                            attrs,
                            directives,
                            nodeLinkFn,
                            childNodes,
                            childLinkFn,
                            linkFnFound,
                            nodeLinkFnFound;
                        for (var i = 0; i < nodeList.length; i++) {
                            attrs = new Attributes();
                            if (msie === 11) {
                                mergeConsecutiveTextNodes(nodeList, i, notLiveList);
                            }
                            directives = collectDirectives(nodeList[i], [], attrs, i === 0 ? maxPriority : undefined, ignoreDirective);
                            nodeLinkFn = directives.length ? applyDirectivesToNode(directives, nodeList[i], attrs, transcludeFn, $rootElement, null, [], [], previousCompileContext) : null;
                            if (nodeLinkFn && nodeLinkFn.scope) {
                                compile.$$addScopeClass(attrs.$$element);
                            }
                            childLinkFn =
                                (nodeLinkFn && nodeLinkFn.terminal) || !(childNodes = nodeList[i].childNodes) || !childNodes.length
                                    ? null
                                    : compileNodes(childNodes, nodeLinkFn ? (nodeLinkFn.transcludeOnThisElement || !nodeLinkFn.templateOnThisElement) && nodeLinkFn.transclude : transcludeFn);
                            if (nodeLinkFn || childLinkFn) {
                                linkFns.push(i, nodeLinkFn, childLinkFn);
                                linkFnFound = true;
                                nodeLinkFnFound = nodeLinkFnFound || nodeLinkFn;
                            }
                            previousCompileContext = null;
                        }
                        return linkFnFound ? compositeLinkFn : null;
                        function compositeLinkFn(scope, nodeList, $rootElement, parentBoundTranscludeFn) {
                            var nodeLinkFn, childLinkFn, node, childScope, i, ii, idx, childBoundTranscludeFn;
                            var stableNodeList;
                            if (nodeLinkFnFound) {
                                var nodeListLength = nodeList.length;
                                stableNodeList = new Array(nodeListLength);
                                for (i = 0; i < linkFns.length; i += 3) {
                                    idx = linkFns[i];
                                    stableNodeList[idx] = nodeList[idx];
                                }
                            } else {
                                stableNodeList = nodeList;
                            }
                            for (i = 0, ii = linkFns.length; i < ii;) {
                                node = stableNodeList[linkFns[i++]];
                                nodeLinkFn = linkFns[i++];
                                childLinkFn = linkFns[i++];
                                if (nodeLinkFn) {
                                    if (nodeLinkFn.scope) {
                                        childScope = scope.$new();
                                        compile.$$addScopeInfo(jqLite(node), childScope);
                                    } else {
                                        childScope = scope;
                                    }
                                    if (nodeLinkFn.transcludeOnThisElement) {
                                        childBoundTranscludeFn = createBoundTranscludeFn(scope, nodeLinkFn.transclude, parentBoundTranscludeFn);
                                    } else if (!nodeLinkFn.templateOnThisElement && parentBoundTranscludeFn) {
                                        childBoundTranscludeFn = parentBoundTranscludeFn;
                                    } else if (!parentBoundTranscludeFn && transcludeFn) {
                                        childBoundTranscludeFn = createBoundTranscludeFn(scope, transcludeFn);
                                    } else {
                                        childBoundTranscludeFn = null;
                                    }
                                    nodeLinkFn(childLinkFn, childScope, node, $rootElement, childBoundTranscludeFn);
                                } else if (childLinkFn) {
                                    childLinkFn(scope, node.childNodes, undefined, parentBoundTranscludeFn);
                                }
                            }
                        }
                    }
                    function mergeConsecutiveTextNodes(nodeList, idx, notLiveList) {
                        var node = nodeList[idx];
                        var parent = node.parentNode;
                        var sibling;
                        if (node.nodeType !== NODE_TYPE_TEXT) {
                            return;
                        }
                        while (true) {
                            sibling = parent ? node.nextSibling : nodeList[idx + 1];
                            if (!sibling || sibling.nodeType !== NODE_TYPE_TEXT) {
                                break;
                            }
                            node.nodeValue = node.nodeValue + sibling.nodeValue;
                            if (sibling.parentNode) {
                                sibling.parentNode.removeChild(sibling);
                            }
                            if (notLiveList && sibling === nodeList[idx + 1]) {
                                nodeList.splice(idx + 1, 1);
                            }
                        }
                    }
                    function createBoundTranscludeFn(scope, transcludeFn, previousBoundTranscludeFn) {
                        function boundTranscludeFn(transcludedScope, cloneFn, controllers, futureParentElement, containingScope) {
                            if (!transcludedScope) {
                                transcludedScope = scope.$new(false, containingScope);
                                transcludedScope.$$transcluded = true;
                            }
                            return transcludeFn(transcludedScope, cloneFn, { parentBoundTranscludeFn: previousBoundTranscludeFn, transcludeControllers: controllers, futureParentElement: futureParentElement });
                        }
                        var boundSlots = (boundTranscludeFn.$$slots = createMap());
                        for (var slotName in transcludeFn.$$slots) {
                            if (transcludeFn.$$slots[slotName]) {
                                boundSlots[slotName] = createBoundTranscludeFn(scope, transcludeFn.$$slots[slotName], previousBoundTranscludeFn);
                            } else {
                                boundSlots[slotName] = null;
                            }
                        }
                        return boundTranscludeFn;
                    }
                    function collectDirectives(node, directives, attrs, maxPriority, ignoreDirective) {
                        var nodeType = node.nodeType,
                            attrsMap = attrs.$attr,
                            match,
                            nodeName,
                            className;
                        switch (nodeType) {
                            case NODE_TYPE_ELEMENT:
                                nodeName = nodeName_(node);
                                addDirective(directives, directiveNormalize(nodeName), "E", maxPriority, ignoreDirective);
                                for (var attr, name, nName, ngAttrName, value, isNgAttr, nAttrs = node.attributes, j = 0, jj = nAttrs && nAttrs.length; j < jj; j++) {
                                    var attrStartName = false;
                                    var attrEndName = false;
                                    attr = nAttrs[j];
                                    name = attr.name;
                                    value = attr.value;
                                    ngAttrName = directiveNormalize(name);
                                    isNgAttr = NG_ATTR_BINDING.test(ngAttrName);
                                    if (isNgAttr) {
                                        name = name
                                            .replace(PREFIX_REGEXP, "")
                                            .substr(8)
                                            .replace(/_(.)/g, function (match, letter) {
                                                return letter.toUpperCase();
                                            });
                                    }
                                    var multiElementMatch = ngAttrName.match(MULTI_ELEMENT_DIR_RE);
                                    if (multiElementMatch && directiveIsMultiElement(multiElementMatch[1])) {
                                        attrStartName = name;
                                        attrEndName = name.substr(0, name.length - 5) + "end";
                                        name = name.substr(0, name.length - 6);
                                    }
                                    nName = directiveNormalize(name.toLowerCase());
                                    attrsMap[nName] = name;
                                    if (isNgAttr || !attrs.hasOwnProperty(nName)) {
                                        attrs[nName] = value;
                                        if (getBooleanAttrName(node, nName)) {
                                            attrs[nName] = true;
                                        }
                                    }
                                    addAttrInterpolateDirective(node, directives, value, nName, isNgAttr);
                                    addDirective(directives, nName, "A", maxPriority, ignoreDirective, attrStartName, attrEndName);
                                }
                                if (nodeName === "input" && node.getAttribute("type") === "hidden") {
                                    node.setAttribute("autocomplete", "off");
                                }
                                if (!cssClassDirectivesEnabled) break;
                                className = node.className;
                                if (isObject(className)) {
                                    className = className.animVal;
                                }
                                if (isString(className) && className !== "") {
                                    while ((match = CLASS_DIRECTIVE_REGEXP.exec(className))) {
                                        nName = directiveNormalize(match[2]);
                                        if (addDirective(directives, nName, "C", maxPriority, ignoreDirective)) {
                                            attrs[nName] = trim(match[3]);
                                        }
                                        className = className.substr(match.index + match[0].length);
                                    }
                                }
                                break;
                            case NODE_TYPE_TEXT:
                                addTextInterpolateDirective(directives, node.nodeValue);
                                break;
                            case NODE_TYPE_COMMENT:
                                if (!commentDirectivesEnabled) break;
                                collectCommentDirectives(node, directives, attrs, maxPriority, ignoreDirective);
                                break;
                        }
                        directives.sort(byPriority);
                        return directives;
                    }
                    function collectCommentDirectives(node, directives, attrs, maxPriority, ignoreDirective) {
                        try {
                            var match = COMMENT_DIRECTIVE_REGEXP.exec(node.nodeValue);
                            if (match) {
                                var nName = directiveNormalize(match[1]);
                                if (addDirective(directives, nName, "M", maxPriority, ignoreDirective)) {
                                    attrs[nName] = trim(match[2]);
                                }
                            }
                        } catch (e) { }
                    }
                    function groupScan(node, attrStart, attrEnd) {
                        var nodes = [];
                        var depth = 0;
                        if (attrStart && node.hasAttribute && node.hasAttribute(attrStart)) {
                            do {
                                if (!node) {
                                    throw $compileMinErr("uterdir", "Unterminated attribute, found '{0}' but no matching '{1}' found.", attrStart, attrEnd);
                                }
                                if (node.nodeType === NODE_TYPE_ELEMENT) {
                                    if (node.hasAttribute(attrStart)) depth++;
                                    if (node.hasAttribute(attrEnd)) depth--;
                                }
                                nodes.push(node);
                                node = node.nextSibling;
                            } while (depth > 0);
                        } else {
                            nodes.push(node);
                        }
                        return jqLite(nodes);
                    }
                    function groupElementsLinkFnWrapper(linkFn, attrStart, attrEnd) {
                        return function groupedElementsLink(scope, element, attrs, controllers, transcludeFn) {
                            element = groupScan(element[0], attrStart, attrEnd);
                            return linkFn(scope, element, attrs, controllers, transcludeFn);
                        };
                    }
                    function compilationGenerator(eager, $compileNodes, transcludeFn, maxPriority, ignoreDirective, previousCompileContext) {
                        var compiled;
                        if (eager) {
                            return compile($compileNodes, transcludeFn, maxPriority, ignoreDirective, previousCompileContext);
                        }
                        return function lazyCompilation() {
                            if (!compiled) {
                                compiled = compile($compileNodes, transcludeFn, maxPriority, ignoreDirective, previousCompileContext);
                                $compileNodes = transcludeFn = previousCompileContext = null;
                            }
                            return compiled.apply(this, arguments);
                        };
                    }
                    function applyDirectivesToNode(directives, compileNode, templateAttrs, transcludeFn, jqCollection, originalReplaceDirective, preLinkFns, postLinkFns, previousCompileContext) {
                        previousCompileContext = previousCompileContext || {};
                        var terminalPriority = -Number.MAX_VALUE,
                            newScopeDirective = previousCompileContext.newScopeDirective,
                            controllerDirectives = previousCompileContext.controllerDirectives,
                            newIsolateScopeDirective = previousCompileContext.newIsolateScopeDirective,
                            templateDirective = previousCompileContext.templateDirective,
                            nonTlbTranscludeDirective = previousCompileContext.nonTlbTranscludeDirective,
                            hasTranscludeDirective = false,
                            hasTemplate = false,
                            hasElementTranscludeDirective = previousCompileContext.hasElementTranscludeDirective,
                            $compileNode = (templateAttrs.$$element = jqLite(compileNode)),
                            directive,
                            directiveName,
                            $template,
                            replaceDirective = originalReplaceDirective,
                            childTranscludeFn = transcludeFn,
                            linkFn,
                            didScanForMultipleTransclusion = false,
                            mightHaveMultipleTransclusionError = false,
                            directiveValue;
                        for (var i = 0, ii = directives.length; i < ii; i++) {
                            directive = directives[i];
                            var attrStart = directive.$$start;
                            var attrEnd = directive.$$end;
                            if (attrStart) {
                                $compileNode = groupScan(compileNode, attrStart, attrEnd);
                            }
                            $template = undefined;
                            if (terminalPriority > directive.priority) {
                                break;
                            }
                            directiveValue = directive.scope;
                            if (directiveValue) {
                                if (!directive.templateUrl) {
                                    if (isObject(directiveValue)) {
                                        assertNoDuplicate("new/isolated scope", newIsolateScopeDirective || newScopeDirective, directive, $compileNode);
                                        newIsolateScopeDirective = directive;
                                    } else {
                                        assertNoDuplicate("new/isolated scope", newIsolateScopeDirective, directive, $compileNode);
                                    }
                                }
                                newScopeDirective = newScopeDirective || directive;
                            }
                            directiveName = directive.name;
                            if (!didScanForMultipleTransclusion && ((directive.replace && (directive.templateUrl || directive.template)) || (directive.transclude && !directive.$$tlb))) {
                                var candidateDirective;
                                for (var scanningIndex = i + 1; (candidateDirective = directives[scanningIndex++]);) {
                                    if ((candidateDirective.transclude && !candidateDirective.$$tlb) || (candidateDirective.replace && (candidateDirective.templateUrl || candidateDirective.template))) {
                                        mightHaveMultipleTransclusionError = true;
                                        break;
                                    }
                                }
                                didScanForMultipleTransclusion = true;
                            }
                            if (!directive.templateUrl && directive.controller) {
                                controllerDirectives = controllerDirectives || createMap();
                                assertNoDuplicate("'" + directiveName + "' controller", controllerDirectives[directiveName], directive, $compileNode);
                                controllerDirectives[directiveName] = directive;
                            }
                            directiveValue = directive.transclude;
                            if (directiveValue) {
                                hasTranscludeDirective = true;
                                if (!directive.$$tlb) {
                                    assertNoDuplicate("transclusion", nonTlbTranscludeDirective, directive, $compileNode);
                                    nonTlbTranscludeDirective = directive;
                                }
                                if (directiveValue === "element") {
                                    hasElementTranscludeDirective = true;
                                    terminalPriority = directive.priority;
                                    $template = $compileNode;
                                    $compileNode = templateAttrs.$$element = jqLite(compile.$$createComment(directiveName, templateAttrs[directiveName]));
                                    compileNode = $compileNode[0];
                                    replaceWith(jqCollection, sliceArgs($template), compileNode);
                                    $template[0].$$parentNode = $template[0].parentNode;
                                    childTranscludeFn = compilationGenerator(mightHaveMultipleTransclusionError, $template, transcludeFn, terminalPriority, replaceDirective && replaceDirective.name, {
                                        nonTlbTranscludeDirective: nonTlbTranscludeDirective,
                                    });
                                } else {
                                    var slots = createMap();
                                    if (!isObject(directiveValue)) {
                                        $template = jqLite(jqLiteClone(compileNode)).contents();
                                    } else {
                                        $template = [];
                                        var slotMap = createMap();
                                        var filledSlots = createMap();
                                        forEach(directiveValue, function (elementSelector, slotName) {
                                            var optional = elementSelector.charAt(0) === "?";
                                            elementSelector = optional ? elementSelector.substring(1) : elementSelector;
                                            slotMap[elementSelector] = slotName;
                                            slots[slotName] = null;
                                            filledSlots[slotName] = optional;
                                        });
                                        forEach($compileNode.contents(), function (node) {
                                            var slotName = slotMap[directiveNormalize(nodeName_(node))];
                                            if (slotName) {
                                                filledSlots[slotName] = true;
                                                slots[slotName] = slots[slotName] || [];
                                                slots[slotName].push(node);
                                            } else {
                                                $template.push(node);
                                            }
                                        });
                                        forEach(filledSlots, function (filled, slotName) {
                                            if (!filled) {
                                                throw $compileMinErr("reqslot", "Required transclusion slot `{0}` was not filled.", slotName);
                                            }
                                        });
                                        for (var slotName in slots) {
                                            if (slots[slotName]) {
                                                slots[slotName] = compilationGenerator(mightHaveMultipleTransclusionError, slots[slotName], transcludeFn);
                                            }
                                        }
                                    }
                                    $compileNode.empty();
                                    childTranscludeFn = compilationGenerator(mightHaveMultipleTransclusionError, $template, transcludeFn, undefined, undefined, { needsNewScope: directive.$$isolateScope || directive.$$newScope });
                                    childTranscludeFn.$$slots = slots;
                                }
                            }
                            if (directive.template) {
                                hasTemplate = true;
                                assertNoDuplicate("template", templateDirective, directive, $compileNode);
                                templateDirective = directive;
                                directiveValue = isFunction(directive.template) ? directive.template($compileNode, templateAttrs) : directive.template;
                                directiveValue = denormalizeTemplate(directiveValue);
                                if (directive.replace) {
                                    replaceDirective = directive;
                                    if (jqLiteIsTextNode(directiveValue)) {
                                        $template = [];
                                    } else {
                                        $template = removeComments(wrapTemplate(directive.templateNamespace, trim(directiveValue)));
                                    }
                                    compileNode = $template[0];
                                    if ($template.length !== 1 || compileNode.nodeType !== NODE_TYPE_ELEMENT) {
                                        throw $compileMinErr("tplrt", "Template for directive '{0}' must have exactly one root element. {1}", directiveName, "");
                                    }
                                    replaceWith(jqCollection, $compileNode, compileNode);
                                    var newTemplateAttrs = { $attr: {} };
                                    var templateDirectives = collectDirectives(compileNode, [], newTemplateAttrs);
                                    var unprocessedDirectives = directives.splice(i + 1, directives.length - (i + 1));
                                    if (newIsolateScopeDirective || newScopeDirective) {
                                        markDirectiveScope(templateDirectives, newIsolateScopeDirective, newScopeDirective);
                                    }
                                    directives = directives.concat(templateDirectives).concat(unprocessedDirectives);
                                    mergeTemplateAttributes(templateAttrs, newTemplateAttrs);
                                    ii = directives.length;
                                } else {
                                    $compileNode.html(directiveValue);
                                }
                            }
                            if (directive.templateUrl) {
                                hasTemplate = true;
                                assertNoDuplicate("template", templateDirective, directive, $compileNode);
                                templateDirective = directive;
                                if (directive.replace) {
                                    replaceDirective = directive;
                                }
                                nodeLinkFn = compileTemplateUrl(directives.splice(i, directives.length - i), $compileNode, templateAttrs, jqCollection, hasTranscludeDirective && childTranscludeFn, preLinkFns, postLinkFns, {
                                    controllerDirectives: controllerDirectives,
                                    newScopeDirective: newScopeDirective !== directive && newScopeDirective,
                                    newIsolateScopeDirective: newIsolateScopeDirective,
                                    templateDirective: templateDirective,
                                    nonTlbTranscludeDirective: nonTlbTranscludeDirective,
                                });
                                ii = directives.length;
                            } else if (directive.compile) {
                                try {
                                    linkFn = directive.compile($compileNode, templateAttrs, childTranscludeFn);
                                    var context = directive.$$originalDirective || directive;
                                    if (isFunction(linkFn)) {
                                        addLinkFns(null, bind(context, linkFn), attrStart, attrEnd);
                                    } else if (linkFn) {
                                        addLinkFns(bind(context, linkFn.pre), bind(context, linkFn.post), attrStart, attrEnd);
                                    }
                                } catch (e) {
                                    $exceptionHandler(e, startingTag($compileNode));
                                }
                            }
                            if (directive.terminal) {
                                nodeLinkFn.terminal = true;
                                terminalPriority = Math.max(terminalPriority, directive.priority);
                            }
                        }
                        nodeLinkFn.scope = newScopeDirective && newScopeDirective.scope === true;
                        nodeLinkFn.transcludeOnThisElement = hasTranscludeDirective;
                        nodeLinkFn.templateOnThisElement = hasTemplate;
                        nodeLinkFn.transclude = childTranscludeFn;
                        previousCompileContext.hasElementTranscludeDirective = hasElementTranscludeDirective;
                        return nodeLinkFn;
                        function addLinkFns(pre, post, attrStart, attrEnd) {
                            if (pre) {
                                if (attrStart) pre = groupElementsLinkFnWrapper(pre, attrStart, attrEnd);
                                pre.require = directive.require;
                                pre.directiveName = directiveName;
                                if (newIsolateScopeDirective === directive || directive.$$isolateScope) {
                                    pre = cloneAndAnnotateFn(pre, { isolateScope: true });
                                }
                                preLinkFns.push(pre);
                            }
                            if (post) {
                                if (attrStart) post = groupElementsLinkFnWrapper(post, attrStart, attrEnd);
                                post.require = directive.require;
                                post.directiveName = directiveName;
                                if (newIsolateScopeDirective === directive || directive.$$isolateScope) {
                                    post = cloneAndAnnotateFn(post, { isolateScope: true });
                                }
                                postLinkFns.push(post);
                            }
                        }
                        function nodeLinkFn(childLinkFn, scope, linkNode, $rootElement, boundTranscludeFn) {
                            var i, ii, linkFn, isolateScope, controllerScope, elementControllers, transcludeFn, $element, attrs, scopeBindingInfo;
                            if (compileNode === linkNode) {
                                attrs = templateAttrs;
                                $element = templateAttrs.$$element;
                            } else {
                                $element = jqLite(linkNode);
                                attrs = new Attributes($element, templateAttrs);
                            }
                            controllerScope = scope;
                            if (newIsolateScopeDirective) {
                                isolateScope = scope.$new(true);
                            } else if (newScopeDirective) {
                                controllerScope = scope.$parent;
                            }
                            if (boundTranscludeFn) {
                                transcludeFn = controllersBoundTransclude;
                                transcludeFn.$$boundTransclude = boundTranscludeFn;
                                transcludeFn.isSlotFilled = function (slotName) {
                                    return !!boundTranscludeFn.$$slots[slotName];
                                };
                            }
                            if (controllerDirectives) {
                                elementControllers = setupControllers($element, attrs, transcludeFn, controllerDirectives, isolateScope, scope, newIsolateScopeDirective);
                            }
                            if (newIsolateScopeDirective) {
                                compile.$$addScopeInfo($element, isolateScope, true, !(templateDirective && (templateDirective === newIsolateScopeDirective || templateDirective === newIsolateScopeDirective.$$originalDirective)));
                                compile.$$addScopeClass($element, true);
                                isolateScope.$$isolateBindings = newIsolateScopeDirective.$$isolateBindings;
                                scopeBindingInfo = initializeDirectiveBindings(scope, attrs, isolateScope, isolateScope.$$isolateBindings, newIsolateScopeDirective);
                                if (scopeBindingInfo.removeWatches) {
                                    isolateScope.$on("$destroy", scopeBindingInfo.removeWatches);
                                }
                            }
                            for (var name in elementControllers) {
                                var controllerDirective = controllerDirectives[name];
                                var controller = elementControllers[name];
                                var bindings = controllerDirective.$$bindings.bindToController;
                                if (preAssignBindingsEnabled) {
                                    if (bindings) {
                                        controller.bindingInfo = initializeDirectiveBindings(controllerScope, attrs, controller.instance, bindings, controllerDirective);
                                    } else {
                                        controller.bindingInfo = {};
                                    }
                                    var controllerResult = controller();
                                    if (controllerResult !== controller.instance) {
                                        controller.instance = controllerResult;
                                        $element.data("$" + controllerDirective.name + "Controller", controllerResult);
                                        if (controller.bindingInfo.removeWatches) {
                                            controller.bindingInfo.removeWatches();
                                        }
                                        controller.bindingInfo = initializeDirectiveBindings(controllerScope, attrs, controller.instance, bindings, controllerDirective);
                                    }
                                } else {
                                    controller.instance = controller();
                                    $element.data("$" + controllerDirective.name + "Controller", controller.instance);
                                    controller.bindingInfo = initializeDirectiveBindings(controllerScope, attrs, controller.instance, bindings, controllerDirective);
                                }
                            }
                            forEach(controllerDirectives, function (controllerDirective, name) {
                                var require = controllerDirective.require;
                                if (controllerDirective.bindToController && !isArray(require) && isObject(require)) {
                                    extend(elementControllers[name].instance, getControllers(name, require, $element, elementControllers));
                                }
                            });
                            forEach(elementControllers, function (controller) {
                                var controllerInstance = controller.instance;
                                if (isFunction(controllerInstance.$onChanges)) {
                                    try {
                                        controllerInstance.$onChanges(controller.bindingInfo.initialChanges);
                                    } catch (e) {
                                        $exceptionHandler(e);
                                    }
                                }
                                if (isFunction(controllerInstance.$onInit)) {
                                    try {
                                        controllerInstance.$onInit();
                                    } catch (e) {
                                        $exceptionHandler(e);
                                    }
                                }
                                if (isFunction(controllerInstance.$doCheck)) {
                                    controllerScope.$watch(function () {
                                        controllerInstance.$doCheck();
                                    });
                                    controllerInstance.$doCheck();
                                }
                                if (isFunction(controllerInstance.$onDestroy)) {
                                    controllerScope.$on("$destroy", function callOnDestroyHook() {
                                        controllerInstance.$onDestroy();
                                    });
                                }
                            });
                            for (i = 0, ii = preLinkFns.length; i < ii; i++) {
                                linkFn = preLinkFns[i];
                                invokeLinkFn(linkFn, linkFn.isolateScope ? isolateScope : scope, $element, attrs, linkFn.require && getControllers(linkFn.directiveName, linkFn.require, $element, elementControllers), transcludeFn);
                            }
                            var scopeToChild = scope;
                            if (newIsolateScopeDirective && (newIsolateScopeDirective.template || newIsolateScopeDirective.templateUrl === null)) {
                                scopeToChild = isolateScope;
                            }
                            if (childLinkFn) {
                                childLinkFn(scopeToChild, linkNode.childNodes, undefined, boundTranscludeFn);
                            }
                            for (i = postLinkFns.length - 1; i >= 0; i--) {
                                linkFn = postLinkFns[i];
                                invokeLinkFn(linkFn, linkFn.isolateScope ? isolateScope : scope, $element, attrs, linkFn.require && getControllers(linkFn.directiveName, linkFn.require, $element, elementControllers), transcludeFn);
                            }
                            forEach(elementControllers, function (controller) {
                                var controllerInstance = controller.instance;
                                if (isFunction(controllerInstance.$postLink)) {
                                    controllerInstance.$postLink();
                                }
                            });
                            function controllersBoundTransclude(scope, cloneAttachFn, futureParentElement, slotName) {
                                var transcludeControllers;
                                if (!isScope(scope)) {
                                    slotName = futureParentElement;
                                    futureParentElement = cloneAttachFn;
                                    cloneAttachFn = scope;
                                    scope = undefined;
                                }
                                if (hasElementTranscludeDirective) {
                                    transcludeControllers = elementControllers;
                                }
                                if (!futureParentElement) {
                                    futureParentElement = hasElementTranscludeDirective ? $element.parent() : $element;
                                }
                                if (slotName) {
                                    var slotTranscludeFn = boundTranscludeFn.$$slots[slotName];
                                    if (slotTranscludeFn) {
                                        return slotTranscludeFn(scope, cloneAttachFn, transcludeControllers, futureParentElement, scopeToChild);
                                    } else if (isUndefined(slotTranscludeFn)) {
                                        throw $compileMinErr("noslot", 'No parent directive that requires a transclusion with slot name "{0}". ' + "Element: {1}", slotName, startingTag($element));
                                    }
                                } else {
                                    return boundTranscludeFn(scope, cloneAttachFn, transcludeControllers, futureParentElement, scopeToChild);
                                }
                            }
                        }
                    }
                    function getControllers(directiveName, require, $element, elementControllers) {
                        var value;
                        if (isString(require)) {
                            var match = require.match(REQUIRE_PREFIX_REGEXP);
                            var name = require.substring(match[0].length);
                            var inheritType = match[1] || match[3];
                            var optional = match[2] === "?";
                            if (inheritType === "^^") {
                                $element = $element.parent();
                            } else {
                                value = elementControllers && elementControllers[name];
                                value = value && value.instance;
                            }
                            if (!value) {
                                var dataName = "$" + name + "Controller";
                                value = inheritType ? $element.inheritedData(dataName) : $element.data(dataName);
                            }
                            if (!value && !optional) {
                                throw $compileMinErr("ctreq", "Controller '{0}', required by directive '{1}', can't be found!", name, directiveName);
                            }
                        } else if (isArray(require)) {
                            value = [];
                            for (var i = 0, ii = require.length; i < ii; i++) {
                                value[i] = getControllers(directiveName, require[i], $element, elementControllers);
                            }
                        } else if (isObject(require)) {
                            value = {};
                            forEach(require, function (controller, property) {
                                value[property] = getControllers(directiveName, controller, $element, elementControllers);
                            });
                        }
                        return value || null;
                    }
                    function setupControllers($element, attrs, transcludeFn, controllerDirectives, isolateScope, scope, newIsolateScopeDirective) {
                        var elementControllers = createMap();
                        for (var controllerKey in controllerDirectives) {
                            var directive = controllerDirectives[controllerKey];
                            var locals = { $scope: directive === newIsolateScopeDirective || directive.$$isolateScope ? isolateScope : scope, $element: $element, $attrs: attrs, $transclude: transcludeFn };
                            var controller = directive.controller;
                            if (controller === "@") {
                                controller = attrs[directive.name];
                            }
                            var controllerInstance = $controller(controller, locals, true, directive.controllerAs);
                            elementControllers[directive.name] = controllerInstance;
                            $element.data("$" + directive.name + "Controller", controllerInstance.instance);
                        }
                        return elementControllers;
                    }
                    function markDirectiveScope(directives, isolateScope, newScope) {
                        for (var j = 0, jj = directives.length; j < jj; j++) {
                            directives[j] = inherit(directives[j], { $$isolateScope: isolateScope, $$newScope: newScope });
                        }
                    }
                    function addDirective(tDirectives, name, location, maxPriority, ignoreDirective, startAttrName, endAttrName) {
                        if (name === ignoreDirective) return null;
                        var match = null;
                        if (hasDirectives.hasOwnProperty(name)) {
                            for (var directive, directives = $injector.get(name + Suffix), i = 0, ii = directives.length; i < ii; i++) {
                                directive = directives[i];
                                if ((isUndefined(maxPriority) || maxPriority > directive.priority) && directive.restrict.indexOf(location) !== -1) {
                                    if (startAttrName) {
                                        directive = inherit(directive, { $$start: startAttrName, $$end: endAttrName });
                                    }
                                    if (!directive.$$bindings) {
                                        var bindings = (directive.$$bindings = parseDirectiveBindings(directive, directive.name));
                                        if (isObject(bindings.isolateScope)) {
                                            directive.$$isolateBindings = bindings.isolateScope;
                                        }
                                    }
                                    tDirectives.push(directive);
                                    match = directive;
                                }
                            }
                        }
                        return match;
                    }
                    function directiveIsMultiElement(name) {
                        if (hasDirectives.hasOwnProperty(name)) {
                            for (var directive, directives = $injector.get(name + Suffix), i = 0, ii = directives.length; i < ii; i++) {
                                directive = directives[i];
                                if (directive.multiElement) {
                                    return true;
                                }
                            }
                        }
                        return false;
                    }
                    function mergeTemplateAttributes(dst, src) {
                        var srcAttr = src.$attr,
                            dstAttr = dst.$attr;
                        forEach(dst, function (value, key) {
                            if (key.charAt(0) !== "$") {
                                if (src[key] && src[key] !== value) {
                                    if (value.length) {
                                        value += (key === "style" ? ";" : " ") + src[key];
                                    } else {
                                        value = src[key];
                                    }
                                }
                                dst.$set(key, value, true, srcAttr[key]);
                            }
                        });
                        forEach(src, function (value, key) {
                            if (!dst.hasOwnProperty(key) && key.charAt(0) !== "$") {
                                dst[key] = value;
                                if (key !== "class" && key !== "style") {
                                    dstAttr[key] = srcAttr[key];
                                }
                            }
                        });
                    }
                    function compileTemplateUrl(directives, $compileNode, tAttrs, $rootElement, childTranscludeFn, preLinkFns, postLinkFns, previousCompileContext) {
                        var linkQueue = [],
                            afterTemplateNodeLinkFn,
                            afterTemplateChildLinkFn,
                            beforeTemplateCompileNode = $compileNode[0],
                            origAsyncDirective = directives.shift(),
                            derivedSyncDirective = inherit(origAsyncDirective, { templateUrl: null, transclude: null, replace: null, $$originalDirective: origAsyncDirective }),
                            templateUrl = isFunction(origAsyncDirective.templateUrl) ? origAsyncDirective.templateUrl($compileNode, tAttrs) : origAsyncDirective.templateUrl,
                            templateNamespace = origAsyncDirective.templateNamespace;
                        $compileNode.empty();
                        $templateRequest(templateUrl)
                            .then(function (content) {
                                var compileNode, tempTemplateAttrs, $template, childBoundTranscludeFn;
                                content = denormalizeTemplate(content);
                                if (origAsyncDirective.replace) {
                                    if (jqLiteIsTextNode(content)) {
                                        $template = [];
                                    } else {
                                        $template = removeComments(wrapTemplate(templateNamespace, trim(content)));
                                    }
                                    compileNode = $template[0];
                                    if ($template.length !== 1 || compileNode.nodeType !== NODE_TYPE_ELEMENT) {
                                        throw $compileMinErr("tplrt", "Template for directive '{0}' must have exactly one root element. {1}", origAsyncDirective.name, templateUrl);
                                    }
                                    tempTemplateAttrs = { $attr: {} };
                                    replaceWith($rootElement, $compileNode, compileNode);
                                    var templateDirectives = collectDirectives(compileNode, [], tempTemplateAttrs);
                                    if (isObject(origAsyncDirective.scope)) {
                                        markDirectiveScope(templateDirectives, true);
                                    }
                                    directives = templateDirectives.concat(directives);
                                    mergeTemplateAttributes(tAttrs, tempTemplateAttrs);
                                } else {
                                    compileNode = beforeTemplateCompileNode;
                                    $compileNode.html(content);
                                }
                                directives.unshift(derivedSyncDirective);
                                afterTemplateNodeLinkFn = applyDirectivesToNode(directives, compileNode, tAttrs, childTranscludeFn, $compileNode, origAsyncDirective, preLinkFns, postLinkFns, previousCompileContext);
                                forEach($rootElement, function (node, i) {
                                    if (node === compileNode) {
                                        $rootElement[i] = $compileNode[0];
                                    }
                                });
                                afterTemplateChildLinkFn = compileNodes($compileNode[0].childNodes, childTranscludeFn);
                                while (linkQueue.length) {
                                    var scope = linkQueue.shift(),
                                        beforeTemplateLinkNode = linkQueue.shift(),
                                        linkRootElement = linkQueue.shift(),
                                        boundTranscludeFn = linkQueue.shift(),
                                        linkNode = $compileNode[0];
                                    if (scope.$$destroyed) continue;
                                    if (beforeTemplateLinkNode !== beforeTemplateCompileNode) {
                                        var oldClasses = beforeTemplateLinkNode.className;
                                        if (!(previousCompileContext.hasElementTranscludeDirective && origAsyncDirective.replace)) {
                                            linkNode = jqLiteClone(compileNode);
                                        }
                                        replaceWith(linkRootElement, jqLite(beforeTemplateLinkNode), linkNode);
                                        safeAddClass(jqLite(linkNode), oldClasses);
                                    }
                                    if (afterTemplateNodeLinkFn.transcludeOnThisElement) {
                                        childBoundTranscludeFn = createBoundTranscludeFn(scope, afterTemplateNodeLinkFn.transclude, boundTranscludeFn);
                                    } else {
                                        childBoundTranscludeFn = boundTranscludeFn;
                                    }
                                    afterTemplateNodeLinkFn(afterTemplateChildLinkFn, scope, linkNode, $rootElement, childBoundTranscludeFn);
                                }
                                linkQueue = null;
                            })
                            .catch(function (error) {
                                if (error instanceof Error) {
                                    $exceptionHandler(error);
                                }
                            });
                        return function delayedNodeLinkFn(ignoreChildLinkFn, scope, node, rootElement, boundTranscludeFn) {
                            var childBoundTranscludeFn = boundTranscludeFn;
                            if (scope.$$destroyed) return;
                            if (linkQueue) {
                                linkQueue.push(scope, node, rootElement, childBoundTranscludeFn);
                            } else {
                                if (afterTemplateNodeLinkFn.transcludeOnThisElement) {
                                    childBoundTranscludeFn = createBoundTranscludeFn(scope, afterTemplateNodeLinkFn.transclude, boundTranscludeFn);
                                }
                                afterTemplateNodeLinkFn(afterTemplateChildLinkFn, scope, node, rootElement, childBoundTranscludeFn);
                            }
                        };
                    }
                    function byPriority(a, b) {
                        var diff = b.priority - a.priority;
                        if (diff !== 0) return diff;
                        if (a.name !== b.name) return a.name < b.name ? -1 : 1;
                        return a.index - b.index;
                    }
                    function assertNoDuplicate(what, previousDirective, directive, element) {
                        function wrapModuleNameIfDefined(moduleName) {
                            return moduleName ? " (module: " + moduleName + ")" : "";
                        }
                        if (previousDirective) {
                            throw $compileMinErr(
                                "multidir",
                                "Multiple directives [{0}{1}, {2}{3}] asking for {4} on: {5}",
                                previousDirective.name,
                                wrapModuleNameIfDefined(previousDirective.$$moduleName),
                                directive.name,
                                wrapModuleNameIfDefined(directive.$$moduleName),
                                what,
                                startingTag(element)
                            );
                        }
                    }
                    function addTextInterpolateDirective(directives, text) {
                        var interpolateFn = $interpolate(text, true);
                        if (interpolateFn) {
                            directives.push({
                                priority: 0,
                                compile: function textInterpolateCompileFn(templateNode) {
                                    var templateNodeParent = templateNode.parent(),
                                        hasCompileParent = !!templateNodeParent.length;
                                    if (hasCompileParent) compile.$$addBindingClass(templateNodeParent);
                                    return function textInterpolateLinkFn(scope, node) {
                                        var parent = node.parent();
                                        if (!hasCompileParent) compile.$$addBindingClass(parent);
                                        compile.$$addBindingInfo(parent, interpolateFn.expressions);
                                        scope.$watch(interpolateFn, function interpolateFnWatchAction(value) {
                                            node[0].nodeValue = value;
                                        });
                                    };
                                },
                            });
                        }
                    }
                    function wrapTemplate(type, template) {
                        type = lowercase(type || "html");
                        switch (type) {
                            case "svg":
                            case "math":
                                var wrapper = window.document.createElement("div");
                                wrapper.innerHTML = "<" + type + ">" + template + "</" + type + ">";
                                return wrapper.childNodes[0].childNodes;
                            default:
                                return template;
                        }
                    }
                    function getTrustedContext(node, attrNormalizedName) {
                        if (attrNormalizedName === "srcdoc") {
                            return $sce.HTML;
                        }
                        var tag = nodeName_(node);
                        if (attrNormalizedName === "src" || attrNormalizedName === "ngSrc") {
                            if (["img", "video", "audio", "source", "track"].indexOf(tag) === -1) {
                                return $sce.RESOURCE_URL;
                            }
                        } else if (attrNormalizedName === "xlinkHref" || (tag === "form" && attrNormalizedName === "action") || (tag === "link" && attrNormalizedName === "href")) {
                            return $sce.RESOURCE_URL;
                        }
                    }
                    function addAttrInterpolateDirective(node, directives, value, name, isNgAttr) {
                        var trustedContext = getTrustedContext(node, name);
                        var mustHaveExpression = !isNgAttr;
                        var allOrNothing = ALL_OR_NOTHING_ATTRS[name] || isNgAttr;
                        var interpolateFn = $interpolate(value, mustHaveExpression, trustedContext, allOrNothing);
                        if (!interpolateFn) return;
                        if (name === "multiple" && nodeName_(node) === "select") {
                            throw $compileMinErr("selmulti", "Binding to the 'multiple' attribute is not supported. Element: {0}", startingTag(node));
                        }
                        if (EVENT_HANDLER_ATTR_REGEXP.test(name)) {
                            throw $compileMinErr("nodomevents", "Interpolations for HTML DOM event attributes are disallowed.  Please use the " + "ng- versions (such as ng-click instead of onclick) instead.");
                        }
                        directives.push({
                            priority: 100,
                            compile: function () {
                                return {
                                    pre: function attrInterpolatePreLinkFn(scope, element, attr) {
                                        var $$observers = attr.$$observers || (attr.$$observers = createMap());
                                        var newValue = attr[name];
                                        if (newValue !== value) {
                                            interpolateFn = newValue && $interpolate(newValue, true, trustedContext, allOrNothing);
                                            value = newValue;
                                        }
                                        if (!interpolateFn) return;
                                        attr[name] = interpolateFn(scope);
                                        ($$observers[name] || ($$observers[name] = [])).$$inter = true;
                                        ((attr.$$observers && attr.$$observers[name].$$scope) || scope).$watch(interpolateFn, function interpolateFnWatchAction(newValue, oldValue) {
                                            if (name === "class" && newValue !== oldValue) {
                                                attr.$updateClass(newValue, oldValue);
                                            } else {
                                                attr.$set(name, newValue);
                                            }
                                        });
                                    },
                                };
                            },
                        });
                    }
                    function replaceWith($rootElement, elementsToRemove, newNode) {
                        var firstElementToRemove = elementsToRemove[0],
                            removeCount = elementsToRemove.length,
                            parent = firstElementToRemove.parentNode,
                            i,
                            ii;
                        if ($rootElement) {
                            for (i = 0, ii = $rootElement.length; i < ii; i++) {
                                if ($rootElement[i] === firstElementToRemove) {
                                    $rootElement[i++] = newNode;
                                    for (var j = i, j2 = j + removeCount - 1, jj = $rootElement.length; j < jj; j++, j2++) {
                                        if (j2 < jj) {
                                            $rootElement[j] = $rootElement[j2];
                                        } else {
                                            delete $rootElement[j];
                                        }
                                    }
                                    $rootElement.length -= removeCount - 1;
                                    if ($rootElement.context === firstElementToRemove) {
                                        $rootElement.context = newNode;
                                    }
                                    break;
                                }
                            }
                        }
                        if (parent) {
                            parent.replaceChild(newNode, firstElementToRemove);
                        }
                        var fragment = window.document.createDocumentFragment();
                        for (i = 0; i < removeCount; i++) {
                            fragment.appendChild(elementsToRemove[i]);
                        }
                        if (jqLite.hasData(firstElementToRemove)) {
                            jqLite.data(newNode, jqLite.data(firstElementToRemove));
                            jqLite(firstElementToRemove).off("$destroy");
                        }
                        jqLite.cleanData(fragment.querySelectorAll("*"));
                        for (i = 1; i < removeCount; i++) {
                            delete elementsToRemove[i];
                        }
                        elementsToRemove[0] = newNode;
                        elementsToRemove.length = 1;
                    }
                    function cloneAndAnnotateFn(fn, annotation) {
                        return extend(
                            function () {
                                return fn.apply(null, arguments);
                            },
                            fn,
                            annotation
                        );
                    }
                    function invokeLinkFn(linkFn, scope, $element, attrs, controllers, transcludeFn) {
                        try {
                            linkFn(scope, $element, attrs, controllers, transcludeFn);
                        } catch (e) {
                            $exceptionHandler(e, startingTag($element));
                        }
                    }
                    function initializeDirectiveBindings(scope, attrs, destination, bindings, directive) {
                        var removeWatchCollection = [];
                        var initialChanges = {};
                        var changes;
                        forEach(bindings, function initializeBinding(definition, scopeName) {
                            var attrName = definition.attrName,
                                optional = definition.optional,
                                mode = definition.mode,
                                lastValue,
                                parentGet,
                                parentSet,
                                compare,
                                removeWatch;
                            switch (mode) {
                                case "@":
                                    if (!optional && !hasOwnProperty.call(attrs, attrName)) {
                                        destination[scopeName] = attrs[attrName] = undefined;
                                    }
                                    removeWatch = attrs.$observe(attrName, function (value) {
                                        if (isString(value) || isBoolean(value)) {
                                            var oldValue = destination[scopeName];
                                            recordChanges(scopeName, value, oldValue);
                                            destination[scopeName] = value;
                                        }
                                    });
                                    attrs.$$observers[attrName].$$scope = scope;
                                    lastValue = attrs[attrName];
                                    if (isString(lastValue)) {
                                        destination[scopeName] = $interpolate(lastValue)(scope);
                                    } else if (isBoolean(lastValue)) {
                                        destination[scopeName] = lastValue;
                                    }
                                    initialChanges[scopeName] = new SimpleChange(_UNINITIALIZED_VALUE, destination[scopeName]);
                                    removeWatchCollection.push(removeWatch);
                                    break;
                                case "=":
                                    if (!hasOwnProperty.call(attrs, attrName)) {
                                        if (optional) break;
                                        attrs[attrName] = undefined;
                                    }
                                    if (optional && !attrs[attrName]) break;
                                    parentGet = $parse(attrs[attrName]);
                                    if (parentGet.literal) {
                                        compare = equals;
                                    } else {
                                        compare = simpleCompare;
                                    }
                                    parentSet =
                                        parentGet.assign ||
                                        function () {
                                            lastValue = destination[scopeName] = parentGet(scope);
                                            throw $compileMinErr("nonassign", "Expression '{0}' in attribute '{1}' used with directive '{2}' is non-assignable!", attrs[attrName], attrName, directive.name);
                                        };
                                    lastValue = destination[scopeName] = parentGet(scope);
                                    var parentValueWatch = function parentValueWatch(parentValue) {
                                        if (!compare(parentValue, destination[scopeName])) {
                                            if (!compare(parentValue, lastValue)) {
                                                destination[scopeName] = parentValue;
                                            } else {
                                                parentSet(scope, (parentValue = destination[scopeName]));
                                            }
                                        }
                                        lastValue = parentValue;
                                        return lastValue;
                                    };
                                    parentValueWatch.$stateful = true;
                                    if (definition.collection) {
                                        removeWatch = scope.$watchCollection(attrs[attrName], parentValueWatch);
                                    } else {
                                        removeWatch = scope.$watch($parse(attrs[attrName], parentValueWatch), null, parentGet.literal);
                                    }
                                    removeWatchCollection.push(removeWatch);
                                    break;
                                case "<":
                                    if (!hasOwnProperty.call(attrs, attrName)) {
                                        if (optional) break;
                                        attrs[attrName] = undefined;
                                    }
                                    if (optional && !attrs[attrName]) break;
                                    parentGet = $parse(attrs[attrName]);
                                    var deepWatch = parentGet.literal;
                                    var initialValue = (destination[scopeName] = parentGet(scope));
                                    initialChanges[scopeName] = new SimpleChange(_UNINITIALIZED_VALUE, destination[scopeName]);
                                    removeWatch = scope.$watch(
                                        parentGet,
                                        function parentValueWatchAction(newValue, oldValue) {
                                            if (oldValue === newValue) {
                                                if (oldValue === initialValue || (deepWatch && equals(oldValue, initialValue))) {
                                                    return;
                                                }
                                                oldValue = initialValue;
                                            }
                                            recordChanges(scopeName, newValue, oldValue);
                                            destination[scopeName] = newValue;
                                        },
                                        deepWatch
                                    );
                                    removeWatchCollection.push(removeWatch);
                                    break;
                                case "&":
                                    parentGet = attrs.hasOwnProperty(attrName) ? $parse(attrs[attrName]) : noop;
                                    if (parentGet === noop && optional) break;
                                    destination[scopeName] = function (locals) {
                                        return parentGet(scope, locals);
                                    };
                                    break;
                            }
                        });
                        function recordChanges(key, currentValue, previousValue) {
                            if (isFunction(destination.$onChanges) && !simpleCompare(currentValue, previousValue)) {
                                if (!onChangesQueue) {
                                    scope.$$postDigest(flushOnChangesQueue);
                                    onChangesQueue = [];
                                }
                                if (!changes) {
                                    changes = {};
                                    onChangesQueue.push(triggerOnChangesHook);
                                }
                                if (changes[key]) {
                                    previousValue = changes[key].previousValue;
                                }
                                changes[key] = new SimpleChange(previousValue, currentValue);
                            }
                        }
                        function triggerOnChangesHook() {
                            destination.$onChanges(changes);
                            changes = undefined;
                        }
                        return {
                            initialChanges: initialChanges,
                            removeWatches:
                                removeWatchCollection.length &&
                                function removeWatches() {
                                    for (var i = 0, ii = removeWatchCollection.length; i < ii; ++i) {
                                        removeWatchCollection[i]();
                                    }
                                },
                        };
                    }
                },
            ];
        }
        function SimpleChange(previous, current) {
            this.previousValue = previous;
            this.currentValue = current;
        }
        SimpleChange.prototype.isFirstChange = function () {
            return this.previousValue === _UNINITIALIZED_VALUE;
        };
        var PREFIX_REGEXP = /^((?:x|data)[:\-_])/i;
        var SPECIAL_CHARS_REGEXP = /[:\-_]+(.)/g;
        function directiveNormalize(name) {
            return name.replace(PREFIX_REGEXP, "").replace(SPECIAL_CHARS_REGEXP, fnCamelCaseReplace);
        }
        function tokenDifference(str1, str2) {
            var values = "",
                tokens1 = str1.split(/\s+/),
                tokens2 = str2.split(/\s+/);
            outer: for (var i = 0; i < tokens1.length; i++) {
                var token = tokens1[i];
                for (var j = 0; j < tokens2.length; j++) {
                    if (token === tokens2[j]) continue outer;
                }
                values += (values.length > 0 ? " " : "") + token;
            }
            return values;
        }
        function removeComments(jqNodes) {
            jqNodes = jqLite(jqNodes);
            var i = jqNodes.length;
            if (i <= 1) {
                return jqNodes;
            }
            while (i--) {
                var node = jqNodes[i];
                if (node.nodeType === NODE_TYPE_COMMENT || (node.nodeType === NODE_TYPE_TEXT && node.nodeValue.trim() === "")) {
                    splice.call(jqNodes, i, 1);
                }
            }
            return jqNodes;
        }
        var $controllerMinErr = minErr("$controller");
        var CNTRL_REG = /^(\S+)(\s+as\s+([\w$]+))?$/;
        function identifierForController(controller, ident) {
            if (ident && isString(ident)) return ident;
            if (isString(controller)) {
                var match = CNTRL_REG.exec(controller);
                if (match) return match[3];
            }
        }
        function $ControllerProvider() {
            var controllers = {},
                globals = false;
            this.has = function (name) {
                return controllers.hasOwnProperty(name);
            };
            this.register = function (name, constructor) {
                assertNotHasOwnProperty(name, "controller");
                if (isObject(name)) {
                    extend(controllers, name);
                } else {
                    controllers[name] = constructor;
                }
            };
            this.allowGlobals = function () {
                globals = true;
            };
            this.$get = [
                "$injector",
                "$window",
                function ($injector, $window) {
                    return function $controller(expression, locals, later, ident) {
                        var instance, match, constructor, identifier;
                        later = later === true;
                        if (ident && isString(ident)) {
                            identifier = ident;
                        }
                        if (isString(expression)) {
                            match = expression.match(CNTRL_REG);
                            if (!match) {
                                throw $controllerMinErr("ctrlfmt", "Badly formed controller string '{0}'. " + "Must match `__name__ as __id__` or `__name__`.", expression);
                            }
                            constructor = match[1];
                            identifier = identifier || match[3];
                            expression = controllers.hasOwnProperty(constructor) ? controllers[constructor] : getter(locals.$scope, constructor, true) || (globals ? getter($window, constructor, true) : undefined);
                            if (!expression) {
                                throw $controllerMinErr("ctrlreg", "The controller with the name '{0}' is not registered.", constructor);
                            }
                            assertArgFn(expression, constructor, true);
                        }
                        if (later) {
                            var controllerPrototype = (isArray(expression) ? expression[expression.length - 1] : expression).prototype;
                            instance = Object.create(controllerPrototype || null);
                            if (identifier) {
                                addIdentifier(locals, identifier, instance, constructor || expression.name);
                            }
                            return extend(
                                function $controllerInit() {
                                    var result = $injector.invoke(expression, instance, locals, constructor);
                                    if (result !== instance && (isObject(result) || isFunction(result))) {
                                        instance = result;
                                        if (identifier) {
                                            addIdentifier(locals, identifier, instance, constructor || expression.name);
                                        }
                                    }
                                    return instance;
                                },
                                { instance: instance, identifier: identifier }
                            );
                        }
                        instance = $injector.instantiate(expression, locals, constructor);
                        if (identifier) {
                            addIdentifier(locals, identifier, instance, constructor || expression.name);
                        }
                        return instance;
                    };
                    function addIdentifier(locals, identifier, instance, name) {
                        if (!(locals && isObject(locals.$scope))) {
                            throw minErr("$controller")("noscp", "Cannot export controller '{0}' as '{1}'! No $scope object provided via `locals`.", name, identifier);
                        }
                        locals.$scope[identifier] = instance;
                    }
                },
            ];
        }
        function $DocumentProvider() {
            this.$get = [
                "$window",
                function (window) {
                    return jqLite(window.document);
                },
            ];
        }
        function $$IsDocumentHiddenProvider() {
            this.$get = [
                "$document",
                "$rootScope",
                function ($document, $rootScope) {
                    var doc = $document[0];
                    var hidden = doc && doc.hidden;
                    $document.on("visibilitychange", changeListener);
                    $rootScope.$on("$destroy", function () {
                        $document.off("visibilitychange", changeListener);
                    });
                    function changeListener() {
                        hidden = doc.hidden;
                    }
                    return function () {
                        return hidden;
                    };
                },
            ];
        }
        function $ExceptionHandlerProvider() {
            this.$get = [
                "$log",
                function ($log) {
                    return function (exception, cause) {
                        $log.error.apply($log, arguments);
                    };
                },
            ];
        }
        var $$ForceReflowProvider = function () {
            this.$get = [
                "$document",
                function ($document) {
                    return function (domNode) {
                        if (domNode) {
                            if (!domNode.nodeType && domNode instanceof jqLite) {
                                domNode = domNode[0];
                            }
                        } else {
                            domNode = $document[0].body;
                        }
                        return domNode.offsetWidth + 1;
                    };
                },
            ];
        };
        var APPLICATION_JSON = "application/json";
        var CONTENT_TYPE_APPLICATION_JSON = { "Content-Type": APPLICATION_JSON + ";charset=utf-8" };
        var JSON_START = /^\[|^\{(?!\{)/;
        var JSON_ENDS = { "[": /]$/, "{": /}$/ };
        var JSON_PROTECTION_PREFIX = /^\)]\}',?\n/;
        var $httpMinErr = minErr("$http");
        function serializeValue(v) {
            if (isObject(v)) {
                return isDate(v) ? v.toISOString() : toJson(v);
            }
            return v;
        }
        function $HttpParamSerializerProvider() {
            this.$get = function () {
                return function ngParamSerializer(params) {
                    if (!params) return "";
                    var parts = [];
                    forEachSorted(params, function (value, key) {
                        if (value === null || isUndefined(value)) return;
                        if (isArray(value)) {
                            forEach(value, function (v) {
                                parts.push(encodeUriQuery(key) + "=" + encodeUriQuery(serializeValue(v)));
                            });
                        } else {
                            parts.push(encodeUriQuery(key) + "=" + encodeUriQuery(serializeValue(value)));
                        }
                    });
                    return parts.join("&");
                };
            };
        }
        function $HttpParamSerializerJQLikeProvider() {
            this.$get = function () {
                return function jQueryLikeParamSerializer(params) {
                    if (!params) return "";
                    var parts = [];
                    serialize(params, "", true);
                    return parts.join("&");
                    function serialize(toSerialize, prefix, topLevel) {
                        if (toSerialize === null || isUndefined(toSerialize)) return;
                        if (isArray(toSerialize)) {
                            forEach(toSerialize, function (value, index) {
                                serialize(value, prefix + "[" + (isObject(value) ? index : "") + "]");
                            });
                        } else if (isObject(toSerialize) && !isDate(toSerialize)) {
                            forEachSorted(toSerialize, function (value, key) {
                                serialize(value, prefix + (topLevel ? "" : "[") + key + (topLevel ? "" : "]"));
                            });
                        } else {
                            parts.push(encodeUriQuery(prefix) + "=" + encodeUriQuery(serializeValue(toSerialize)));
                        }
                    }
                };
            };
        }
        function defaultHttpResponseTransform(data, headers) {
            if (isString(data)) {
                var tempData = data.replace(JSON_PROTECTION_PREFIX, "").trim();
                if (tempData) {
                    var contentType = headers("Content-Type");
                    if ((contentType && contentType.indexOf(APPLICATION_JSON) === 0) || isJsonLike(tempData)) {
                        try {
                            data = fromJson(tempData);
                        } catch (e) {
                            throw $httpMinErr("baddata", 'Data must be a valid JSON object. Received: "{0}". ' + 'Parse error: "{1}"', data, e);
                        }
                    }
                }
            }
            return data;
        }
        function isJsonLike(str) {
            var jsonStart = str.match(JSON_START);
            return jsonStart && JSON_ENDS[jsonStart[0]].test(str);
        }
        function parseHeaders(headers) {
            var parsed = createMap(),
                i;
            function fillInParsed(key, val) {
                if (key) {
                    parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
                }
            }
            if (isString(headers)) {
                forEach(headers.split("\n"), function (line) {
                    i = line.indexOf(":");
                    fillInParsed(lowercase(trim(line.substr(0, i))), trim(line.substr(i + 1)));
                });
            } else if (isObject(headers)) {
                forEach(headers, function (headerVal, headerKey) {
                    fillInParsed(lowercase(headerKey), trim(headerVal));
                });
            }
            return parsed;
        }
        function headersGetter(headers) {
            var headersObj;
            return function (name) {
                if (!headersObj) headersObj = parseHeaders(headers);
                if (name) {
                    var value = headersObj[lowercase(name)];
                    if (value === undefined) {
                        value = null;
                    }
                    return value;
                }
                return headersObj;
            };
        }
        function transformData(data, headers, status, fns) {
            if (isFunction(fns)) {
                return fns(data, headers, status);
            }
            forEach(fns, function (fn) {
                data = fn(data, headers, status);
            });
            return data;
        }
        function isSuccess(status) {
            return 200 <= status && status < 300;
        }
        function $HttpProvider() {
            var defaults = (this.defaults = {
                transformResponse: [defaultHttpResponseTransform],
                transformRequest: [
                    function (d) {
                        return isObject(d) && !isFile(d) && !isBlob(d) && !isFormData(d) ? toJson(d) : d;
                    },
                ],
                headers: { common: { Accept: "application/json, text/plain, */*" }, post: shallowCopy(CONTENT_TYPE_APPLICATION_JSON), put: shallowCopy(CONTENT_TYPE_APPLICATION_JSON), patch: shallowCopy(CONTENT_TYPE_APPLICATION_JSON) },
                xsrfCookieName: "XSRF-TOKEN",
                xsrfHeaderName: "X-XSRF-TOKEN",
                paramSerializer: "$httpParamSerializer",
                jsonpCallbackParam: "callback",
            });
            var useApplyAsync = false;
            this.useApplyAsync = function (value) {
                if (isDefined(value)) {
                    useApplyAsync = !!value;
                    return this;
                }
                return useApplyAsync;
            };
            var interceptorFactories = (this.interceptors = []);
            this.$get = [
                "$browser",
                "$httpBackend",
                "$$cookieReader",
                "$cacheFactory",
                "$rootScope",
                "$q",
                "$injector",
                "$sce",
                function ($browser, $httpBackend, $$cookieReader, $cacheFactory, $rootScope, $q, $injector, $sce) {
                    var defaultCache = $cacheFactory("$http");
                    defaults.paramSerializer = isString(defaults.paramSerializer) ? $injector.get(defaults.paramSerializer) : defaults.paramSerializer;
                    var reversedInterceptors = [];
                    forEach(interceptorFactories, function (interceptorFactory) {
                        reversedInterceptors.unshift(isString(interceptorFactory) ? $injector.get(interceptorFactory) : $injector.invoke(interceptorFactory));
                    });
                    function $http(requestConfig) {
                        if (!isObject(requestConfig)) {
                            throw minErr("$http")("badreq", "Http request configuration must be an object.  Received: {0}", requestConfig);
                        }
                        if (!isString($sce.valueOf(requestConfig.url))) {
                            throw minErr("$http")("badreq", "Http request configuration url must be a string or a $sce trusted object.  Received: {0}", requestConfig.url);
                        }
                        var config = extend(
                            { method: "get", transformRequest: defaults.transformRequest, transformResponse: defaults.transformResponse, paramSerializer: defaults.paramSerializer, jsonpCallbackParam: defaults.jsonpCallbackParam },
                            requestConfig
                        );
                        config.headers = mergeHeaders(requestConfig);
                        config.method = uppercase(config.method);
                        config.paramSerializer = isString(config.paramSerializer) ? $injector.get(config.paramSerializer) : config.paramSerializer;
                        $browser.$$incOutstandingRequestCount();
                        var requestInterceptors = [];
                        var responseInterceptors = [];
                        var promise = $q.resolve(config);
                        forEach(reversedInterceptors, function (interceptor) {
                            if (interceptor.request || interceptor.requestError) {
                                requestInterceptors.unshift(interceptor.request, interceptor.requestError);
                            }
                            if (interceptor.response || interceptor.responseError) {
                                responseInterceptors.push(interceptor.response, interceptor.responseError);
                            }
                        });
                        promise = chainInterceptors(promise, requestInterceptors);
                        promise = promise.then(serverRequest);
                        promise = chainInterceptors(promise, responseInterceptors);
                        promise = promise.finally(completeOutstandingRequest);
                        return promise;
                        function chainInterceptors(promise, interceptors) {
                            for (var i = 0, ii = interceptors.length; i < ii;) {
                                var thenFn = interceptors[i++];
                                var rejectFn = interceptors[i++];
                                promise = promise.then(thenFn, rejectFn);
                            }
                            interceptors.length = 0;
                            return promise;
                        }
                        function completeOutstandingRequest() {
                            $browser.$$completeOutstandingRequest(noop);
                        }
                        function executeHeaderFns(headers, config) {
                            var headerContent,
                                processedHeaders = {};
                            forEach(headers, function (headerFn, header) {
                                if (isFunction(headerFn)) {
                                    headerContent = headerFn(config);
                                    if (headerContent != null) {
                                        processedHeaders[header] = headerContent;
                                    }
                                } else {
                                    processedHeaders[header] = headerFn;
                                }
                            });
                            return processedHeaders;
                        }
                        function mergeHeaders(config) {
                            var defHeaders = defaults.headers,
                                reqHeaders = extend({}, config.headers),
                                defHeaderName,
                                lowercaseDefHeaderName,
                                reqHeaderName;
                            defHeaders = extend({}, defHeaders.common, defHeaders[lowercase(config.method)]);
                            defaultHeadersIteration: for (defHeaderName in defHeaders) {
                                lowercaseDefHeaderName = lowercase(defHeaderName);
                                for (reqHeaderName in reqHeaders) {
                                    if (lowercase(reqHeaderName) === lowercaseDefHeaderName) {
                                        continue defaultHeadersIteration;
                                    }
                                }
                                reqHeaders[defHeaderName] = defHeaders[defHeaderName];
                            }
                            return executeHeaderFns(reqHeaders, shallowCopy(config));
                        }
                        function serverRequest(config) {
                            var headers = config.headers;
                            var reqData = transformData(config.data, headersGetter(headers), undefined, config.transformRequest);
                            if (isUndefined(reqData)) {
                                forEach(headers, function (value, header) {
                                    if (lowercase(header) === "content-type") {
                                        delete headers[header];
                                    }
                                });
                            }
                            if (isUndefined(config.withCredentials) && !isUndefined(defaults.withCredentials)) {
                                config.withCredentials = defaults.withCredentials;
                            }
                            return sendReq(config, reqData).then(transformResponse, transformResponse);
                        }
                        function transformResponse(response) {
                            var resp = extend({}, response);
                            resp.data = transformData(response.data, response.headers, response.status, config.transformResponse);
                            return isSuccess(response.status) ? resp : $q.reject(resp);
                        }
                    }
                    $http.pendingRequests = [];
                    createShortMethods("get", "delete", "head", "jsonp");
                    createShortMethodsWithData("post", "put", "patch");
                    $http.defaults = defaults;
                    return $http;
                    function createShortMethods(names) {
                        forEach(arguments, function (name) {
                            $http[name] = function (url, config) {
                                return $http(extend({}, config || {}, { method: name, url: url }));
                            };
                        });
                    }
                    function createShortMethodsWithData(name) {
                        forEach(arguments, function (name) {
                            $http[name] = function (url, data, config) {
                                return $http(extend({}, config || {}, { method: name, url: url, data: data }));
                            };
                        });
                    }
                    function sendReq(config, reqData) {
                        var deferred = $q.defer(),
                            promise = deferred.promise,
                            cache,
                            cachedResp,
                            reqHeaders = config.headers,
                            isJsonp = lowercase(config.method) === "jsonp",
                            url = config.url;
                        if (isJsonp) {
                            url = $sce.getTrustedResourceUrl(url);
                        } else if (!isString(url)) {
                            url = $sce.valueOf(url);
                        }
                        url = buildUrl(url, config.paramSerializer(config.params));
                        if (isJsonp) {
                            url = sanitizeJsonpCallbackParam(url, config.jsonpCallbackParam);
                        }
                        $http.pendingRequests.push(config);
                        promise.then(removePendingReq, removePendingReq);
                        if ((config.cache || defaults.cache) && config.cache !== false && (config.method === "GET" || config.method === "JSONP")) {
                            cache = isObject(config.cache) ? config.cache : isObject(defaults.cache) ? defaults.cache : defaultCache;
                        }
                        if (cache) {
                            cachedResp = cache.get(url);
                            if (isDefined(cachedResp)) {
                                if (isPromiseLike(cachedResp)) {
                                    cachedResp.then(resolvePromiseWithResult, resolvePromiseWithResult);
                                } else {
                                    if (isArray(cachedResp)) {
                                        resolvePromise(cachedResp[1], cachedResp[0], shallowCopy(cachedResp[2]), cachedResp[3]);
                                    } else {
                                        resolvePromise(cachedResp, 200, {}, "OK");
                                    }
                                }
                            } else {
                                cache.put(url, promise);
                            }
                        }
                        if (isUndefined(cachedResp)) {
                            var xsrfValue = urlIsSameOrigin(config.url) ? $$cookieReader()[config.xsrfCookieName || defaults.xsrfCookieName] : undefined;
                            if (xsrfValue) {
                                reqHeaders[config.xsrfHeaderName || defaults.xsrfHeaderName] = xsrfValue;
                            }
                            $httpBackend(
                                config.method,
                                url,
                                reqData,
                                done,
                                reqHeaders,
                                config.timeout,
                                config.withCredentials,
                                config.responseType,
                                createApplyHandlers(config.eventHandlers),
                                createApplyHandlers(config.uploadEventHandlers)
                            );
                        }
                        return promise;
                        function createApplyHandlers(eventHandlers) {
                            if (eventHandlers) {
                                var applyHandlers = {};
                                forEach(eventHandlers, function (eventHandler, key) {
                                    applyHandlers[key] = function (event) {
                                        if (useApplyAsync) {
                                            $rootScope.$applyAsync(callEventHandler);
                                        } else if ($rootScope.$$phase) {
                                            callEventHandler();
                                        } else {
                                            $rootScope.$apply(callEventHandler);
                                        }
                                        function callEventHandler() {
                                            eventHandler(event);
                                        }
                                    };
                                });
                                return applyHandlers;
                            }
                        }
                        function done(status, response, headersString, statusText) {
                            if (cache) {
                                if (isSuccess(status)) {
                                    cache.put(url, [status, response, parseHeaders(headersString), statusText]);
                                } else {
                                    cache.remove(url);
                                }
                            }
                            function resolveHttpPromise() {
                                resolvePromise(response, status, headersString, statusText);
                            }
                            if (useApplyAsync) {
                                $rootScope.$applyAsync(resolveHttpPromise);
                            } else {
                                resolveHttpPromise();
                                if (!$rootScope.$$phase) $rootScope.$apply();
                            }
                        }
                        function resolvePromise(response, status, headers, statusText) {
                            status = status >= -1 ? status : 0;
                            (isSuccess(status) ? deferred.resolve : deferred.reject)({ data: response, status: status, headers: headersGetter(headers), config: config, statusText: statusText });
                        }
                        function resolvePromiseWithResult(result) {
                            resolvePromise(result.data, result.status, shallowCopy(result.headers()), result.statusText);
                        }
                        function removePendingReq() {
                            var idx = $http.pendingRequests.indexOf(config);
                            if (idx !== -1) $http.pendingRequests.splice(idx, 1);
                        }
                    }
                    function buildUrl(url, serializedParams) {
                        if (serializedParams.length > 0) {
                            url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
                        }
                        return url;
                    }
                    function sanitizeJsonpCallbackParam(url, key) {
                        if (/[&?][^=]+=JSON_CALLBACK/.test(url)) {
                            throw $httpMinErr("badjsonp", 'Illegal use of JSON_CALLBACK in url, "{0}"', url);
                        }
                        var callbackParamRegex = new RegExp("[&?]" + key + "=");
                        if (callbackParamRegex.test(url)) {
                            throw $httpMinErr("badjsonp", 'Illegal use of callback param, "{0}", in url, "{1}"', key, url);
                        }
                        url += (url.indexOf("?") === -1 ? "?" : "&") + key + "=JSON_CALLBACK";
                        return url;
                    }
                },
            ];
        }
        function $xhrFactoryProvider() {
            this.$get = function () {
                return function createXhr() {
                    return new window.XMLHttpRequest();
                };
            };
        }
        function $HttpBackendProvider() {
            this.$get = [
                "$browser",
                "$jsonpCallbacks",
                "$document",
                "$xhrFactory",
                function ($browser, $jsonpCallbacks, $document, $xhrFactory) {
                    return createHttpBackend($browser, $xhrFactory, $browser.defer, $jsonpCallbacks, $document[0]);
                },
            ];
        }
        function createHttpBackend($browser, createXhr, $browserDefer, callbacks, rawDocument) {
            return function (method, url, post, callback, headers, timeout, withCredentials, responseType, eventHandlers, uploadEventHandlers) {
                url = url || $browser.url();
                if (lowercase(method) === "jsonp") {
                    var callbackPath = callbacks.createCallback(url);
                    var jsonpDone = jsonpReq(url, callbackPath, function (status, text) {
                        var response = status === 200 && callbacks.getResponse(callbackPath);
                        completeRequest(callback, status, response, "", text);
                        callbacks.removeCallback(callbackPath);
                    });
                } else {
                    var xhr = createXhr(method, url);
                    xhr.open(method, url, true);
                    forEach(headers, function (value, key) {
                        if (isDefined(value)) {
                            xhr.setRequestHeader(key, value);
                        }
                    });
                    xhr.onload = function requestLoaded() {
                        var statusText = xhr.statusText || "";
                        var response = "response" in xhr ? xhr.response : xhr.responseText;
                        var status = xhr.status === 1223 ? 204 : xhr.status;
                        if (status === 0) {
                            status = response ? 200 : urlResolve(url).protocol === "file" ? 404 : 0;
                        }
                        completeRequest(callback, status, response, xhr.getAllResponseHeaders(), statusText);
                    };
                    var requestError = function () {
                        completeRequest(callback, -1, null, null, "");
                    };
                    xhr.onerror = requestError;
                    xhr.onabort = requestError;
                    xhr.ontimeout = requestError;
                    forEach(eventHandlers, function (value, key) {
                        xhr.addEventListener(key, value);
                    });
                    forEach(uploadEventHandlers, function (value, key) {
                        xhr.upload.addEventListener(key, value);
                    });
                    if (withCredentials) {
                        xhr.withCredentials = true;
                    }
                    if (responseType) {
                        try {
                            xhr.responseType = responseType;
                        } catch (e) {
                            if (responseType !== "json") {
                                throw e;
                            }
                        }
                    }
                    xhr.send(isUndefined(post) ? null : post);
                }
                if (timeout > 0) {
                    var timeoutId = $browserDefer(timeoutRequest, timeout);
                } else if (isPromiseLike(timeout)) {
                    timeout.then(timeoutRequest);
                }
                function timeoutRequest() {
                    if (jsonpDone) {
                        jsonpDone();
                    }
                    if (xhr) {
                        xhr.abort();
                    }
                }
                function completeRequest(callback, status, response, headersString, statusText) {
                    if (isDefined(timeoutId)) {
                        $browserDefer.cancel(timeoutId);
                    }
                    jsonpDone = xhr = null;
                    callback(status, response, headersString, statusText);
                }
            };
            function jsonpReq(url, callbackPath, done) {
                url = url.replace("JSON_CALLBACK", callbackPath);
                var script = rawDocument.createElement("script"),
                    callback = null;
                script.type = "text/javascript";
                script.src = url;
                script.async = true;
                callback = function (event) {
                    script.removeEventListener("load", callback);
                    script.removeEventListener("error", callback);
                    rawDocument.body.removeChild(script);
                    script = null;
                    var status = -1;
                    var text = "unknown";
                    if (event) {
                        if (event.type === "load" && !callbacks.wasCalled(callbackPath)) {
                            event = { type: "error" };
                        }
                        text = event.type;
                        status = event.type === "error" ? 404 : 200;
                    }
                    if (done) {
                        done(status, text);
                    }
                };
                script.addEventListener("load", callback);
                script.addEventListener("error", callback);
                rawDocument.body.appendChild(script);
                return callback;
            }
        }
        var $interpolateMinErr = (angular.$interpolateMinErr = minErr("$interpolate"));
        $interpolateMinErr.throwNoconcat = function (text) {
            throw $interpolateMinErr(
                "noconcat",
                "Error while interpolating: {0}\nStrict Contextual Escaping disallows " + "interpolations that concatenate multiple expressions when a trusted value is " + "required.  See http://docs.angularjs.org/api/ng.$sce",
                text
            );
        };
        $interpolateMinErr.interr = function (text, err) {
            return $interpolateMinErr("interr", "Can't interpolate: {0}\n{1}", text, err.toString());
        };
        function $InterpolateProvider() {
            var startSymbol = "{{";
            var endSymbol = "}}";
            this.startSymbol = function (value) {
                if (value) {
                    startSymbol = value;
                    return this;
                } else {
                    return startSymbol;
                }
            };
            this.endSymbol = function (value) {
                if (value) {
                    endSymbol = value;
                    return this;
                } else {
                    return endSymbol;
                }
            };
            this.$get = [
                "$parse",
                "$exceptionHandler",
                "$sce",
                function ($parse, $exceptionHandler, $sce) {
                    var startSymbolLength = startSymbol.length,
                        endSymbolLength = endSymbol.length,
                        escapedStartRegexp = new RegExp(startSymbol.replace(/./g, escape), "g"),
                        escapedEndRegexp = new RegExp(endSymbol.replace(/./g, escape), "g");
                    function escape(ch) {
                        return "\\\\\\" + ch;
                    }
                    function unescapeText(text) {
                        return text.replace(escapedStartRegexp, startSymbol).replace(escapedEndRegexp, endSymbol);
                    }
                    function constantWatchDelegate(scope, listener, objectEquality, constantInterp) {
                        var unwatch = scope.$watch(
                            function constantInterpolateWatch(scope) {
                                unwatch();
                                return constantInterp(scope);
                            },
                            listener,
                            objectEquality
                        );
                        return unwatch;
                    }
                    function $interpolate(text, mustHaveExpression, trustedContext, allOrNothing) {
                        if (!text.length || text.indexOf(startSymbol) === -1) {
                            var constantInterp;
                            if (!mustHaveExpression) {
                                var unescapedText = unescapeText(text);
                                constantInterp = valueFn(unescapedText);
                                constantInterp.exp = text;
                                constantInterp.expressions = [];
                                constantInterp.$$watchDelegate = constantWatchDelegate;
                            }
                            return constantInterp;
                        }
                        allOrNothing = !!allOrNothing;
                        var startIndex,
                            endIndex,
                            index = 0,
                            expressions = [],
                            parseFns = [],
                            textLength = text.length,
                            exp,
                            concat = [],
                            expressionPositions = [];
                        while (index < textLength) {
                            if ((startIndex = text.indexOf(startSymbol, index)) !== -1 && (endIndex = text.indexOf(endSymbol, startIndex + startSymbolLength)) !== -1) {
                                if (index !== startIndex) {
                                    concat.push(unescapeText(text.substring(index, startIndex)));
                                }
                                exp = text.substring(startIndex + startSymbolLength, endIndex);
                                expressions.push(exp);
                                parseFns.push($parse(exp, parseStringifyInterceptor));
                                index = endIndex + endSymbolLength;
                                expressionPositions.push(concat.length);
                                concat.push("");
                            } else {
                                if (index !== textLength) {
                                    concat.push(unescapeText(text.substring(index)));
                                }
                                break;
                            }
                        }
                        if (trustedContext && concat.length > 1) {
                            $interpolateMinErr.throwNoconcat(text);
                        }
                        if (!mustHaveExpression || expressions.length) {
                            var compute = function (values) {
                                for (var i = 0, ii = expressions.length; i < ii; i++) {
                                    if (allOrNothing && isUndefined(values[i])) return;
                                    concat[expressionPositions[i]] = values[i];
                                }
                                return concat.join("");
                            };
                            var getValue = function (value) {
                                return trustedContext ? $sce.getTrusted(trustedContext, value) : $sce.valueOf(value);
                            };
                            return extend(
                                function interpolationFn(context) {
                                    var i = 0;
                                    var ii = expressions.length;
                                    var values = new Array(ii);
                                    try {
                                        for (; i < ii; i++) {
                                            values[i] = parseFns[i](context);
                                        }
                                        return compute(values);
                                    } catch (err) {
                                        $exceptionHandler($interpolateMinErr.interr(text, err));
                                    }
                                },
                                {
                                    exp: text,
                                    expressions: expressions,
                                    $$watchDelegate: function (scope, listener) {
                                        var lastValue;
                                        return scope.$watchGroup(parseFns, function interpolateFnWatcher(values, oldValues) {
                                            var currValue = compute(values);
                                            if (isFunction(listener)) {
                                                listener.call(this, currValue, values !== oldValues ? lastValue : currValue, scope);
                                            }
                                            lastValue = currValue;
                                        });
                                    },
                                }
                            );
                        }
                        function parseStringifyInterceptor(value) {
                            try {
                                value = getValue(value);
                                return allOrNothing && !isDefined(value) ? value : stringify(value);
                            } catch (err) {
                                $exceptionHandler($interpolateMinErr.interr(text, err));
                            }
                        }
                    }
                    $interpolate.startSymbol = function () {
                        return startSymbol;
                    };
                    $interpolate.endSymbol = function () {
                        return endSymbol;
                    };
                    return $interpolate;
                },
            ];
        }
        function $IntervalProvider() {
            this.$get = [
                "$rootScope",
                "$window",
                "$q",
                "$$q",
                "$browser",
                function ($rootScope, $window, $q, $$q, $browser) {
                    var intervals = {};
                    function interval(fn, delay, count, invokeApply) {
                        var hasParams = arguments.length > 4,
                            args = hasParams ? sliceArgs(arguments, 4) : [],
                            setInterval = $window.setInterval,
                            clearInterval = $window.clearInterval,
                            iteration = 0,
                            skipApply = isDefined(invokeApply) && !invokeApply,
                            deferred = (skipApply ? $$q : $q).defer(),
                            promise = deferred.promise;
                        count = isDefined(count) ? count : 0;
                        promise.$$intervalId = setInterval(function tick() {
                            if (skipApply) {
                                $browser.defer(callback);
                            } else {
                                $rootScope.$evalAsync(callback);
                            }
                            deferred.notify(iteration++);
                            if (count > 0 && iteration >= count) {
                                deferred.resolve(iteration);
                                clearInterval(promise.$$intervalId);
                                delete intervals[promise.$$intervalId];
                            }
                            if (!skipApply) $rootScope.$apply();
                        }, delay);
                        intervals[promise.$$intervalId] = deferred;
                        return promise;
                        function callback() {
                            if (!hasParams) {
                                fn(iteration);
                            } else {
                                fn.apply(null, args);
                            }
                        }
                    }
                    interval.cancel = function (promise) {
                        if (promise && promise.$$intervalId in intervals) {
                            intervals[promise.$$intervalId].promise.catch(noop);
                            intervals[promise.$$intervalId].reject("canceled");
                            $window.clearInterval(promise.$$intervalId);
                            delete intervals[promise.$$intervalId];
                            return true;
                        }
                        return false;
                    };
                    return interval;
                },
            ];
        }
        var $jsonpCallbacksProvider = function () {
            this.$get = function () {
                var callbacks = angular.callbacks;
                var callbackMap = {};
                function createCallback(callbackId) {
                    var callback = function (data) {
                        callback.data = data;
                        callback.called = true;
                    };
                    callback.id = callbackId;
                    return callback;
                }
                return {
                    createCallback: function (url) {
                        var callbackId = "_" + (callbacks.$$counter++).toString(36);
                        var callbackPath = "angular.callbacks." + callbackId;
                        var callback = createCallback(callbackId);
                        callbackMap[callbackPath] = callbacks[callbackId] = callback;
                        return callbackPath;
                    },
                    wasCalled: function (callbackPath) {
                        return callbackMap[callbackPath].called;
                    },
                    getResponse: function (callbackPath) {
                        return callbackMap[callbackPath].data;
                    },
                    removeCallback: function (callbackPath) {
                        var callback = callbackMap[callbackPath];
                        delete callbacks[callback.id];
                        delete callbackMap[callbackPath];
                    },
                };
            };
        };
        var PATH_MATCH = /^([^?#]*)(\?([^#]*))?(#(.*))?$/,
            DEFAULT_PORTS = { http: 80, https: 443, ftp: 21 };
        var $locationMinErr = minErr("$location");
        function encodePath(path) {
            var segments = path.split("/"),
                i = segments.length;
            while (i--) {
                segments[i] = encodeUriSegment(segments[i]);
            }
            return segments.join("/");
        }
        function parseAbsoluteUrl(absoluteUrl, locationObj) {
            var parsedUrl = urlResolve(absoluteUrl);
            locationObj.$$protocol = parsedUrl.protocol;
            locationObj.$$host = parsedUrl.hostname;
            locationObj.$$port = toInt(parsedUrl.port) || DEFAULT_PORTS[parsedUrl.protocol] || null;
        }
        var DOUBLE_SLASH_REGEX = /^\s*[\\/]{2,}/;
        function parseAppUrl(url, locationObj) {
            if (DOUBLE_SLASH_REGEX.test(url)) {
                throw $locationMinErr("badpath", 'Invalid url "{0}".', url);
            }
            var prefixed = url.charAt(0) !== "/";
            if (prefixed) {
                url = "/" + url;
            }
            var match = urlResolve(url);
            locationObj.$$path = decodeURIComponent(prefixed && match.pathname.charAt(0) === "/" ? match.pathname.substring(1) : match.pathname);
            locationObj.$$search = parseKeyValue(match.search);
            locationObj.$$hash = decodeURIComponent(match.hash);
            if (locationObj.$$path && locationObj.$$path.charAt(0) !== "/") {
                locationObj.$$path = "/" + locationObj.$$path;
            }
        }
        function startsWith(str, search) {
            return str.slice(0, search.length) === search;
        }
        function stripBaseUrl(base, url) {
            if (startsWith(url, base)) {
                return url.substr(base.length);
            }
        }
        function stripHash(url) {
            var index = url.indexOf("#");
            return index === -1 ? url : url.substr(0, index);
        }
        function trimEmptyHash(url) {
            return url.replace(/(#.+)|#$/, "$1");
        }
        function stripFile(url) {
            return url.substr(0, stripHash(url).lastIndexOf("/") + 1);
        }
        function serverBase(url) {
            return url.substring(0, url.indexOf("/", url.indexOf("//") + 2));
        }
        function LocationHtml5Url(appBase, appBaseNoFile, basePrefix) {
            this.$$html5 = true;
            basePrefix = basePrefix || "";
            parseAbsoluteUrl(appBase, this);
            this.$$parse = function (url) {
                var pathUrl = stripBaseUrl(appBaseNoFile, url);
                if (!isString(pathUrl)) {
                    throw $locationMinErr("ipthprfx", 'Invalid url "{0}", missing path prefix "{1}".', url, appBaseNoFile);
                }
                parseAppUrl(pathUrl, this);
                if (!this.$$path) {
                    this.$$path = "/";
                }
                this.$$compose();
            };
            this.$$compose = function () {
                var search = toKeyValue(this.$$search),
                    hash = this.$$hash ? "#" + encodeUriSegment(this.$$hash) : "";
                this.$$url = encodePath(this.$$path) + (search ? "?" + search : "") + hash;
                this.$$absUrl = appBaseNoFile + this.$$url.substr(1);
                this.$$urlUpdatedByLocation = true;
            };
            this.$$parseLinkUrl = function (url, relHref) {
                if (relHref && relHref[0] === "#") {
                    this.hash(relHref.slice(1));
                    return true;
                }
                var appUrl, prevAppUrl;
                var rewrittenUrl;
                if (isDefined((appUrl = stripBaseUrl(appBase, url)))) {
                    prevAppUrl = appUrl;
                    if (basePrefix && isDefined((appUrl = stripBaseUrl(basePrefix, appUrl)))) {
                        rewrittenUrl = appBaseNoFile + (stripBaseUrl("/", appUrl) || appUrl);
                    } else {
                        rewrittenUrl = appBase + prevAppUrl;
                    }
                } else if (isDefined((appUrl = stripBaseUrl(appBaseNoFile, url)))) {
                    rewrittenUrl = appBaseNoFile + appUrl;
                } else if (appBaseNoFile === url + "/") {
                    rewrittenUrl = appBaseNoFile;
                }
                if (rewrittenUrl) {
                    this.$$parse(rewrittenUrl);
                }
                return !!rewrittenUrl;
            };
        }
        function LocationHashbangUrl(appBase, appBaseNoFile, hashPrefix) {
            parseAbsoluteUrl(appBase, this);
            this.$$parse = function (url) {
                var withoutBaseUrl = stripBaseUrl(appBase, url) || stripBaseUrl(appBaseNoFile, url);
                var withoutHashUrl;
                if (!isUndefined(withoutBaseUrl) && withoutBaseUrl.charAt(0) === "#") {
                    withoutHashUrl = stripBaseUrl(hashPrefix, withoutBaseUrl);
                    if (isUndefined(withoutHashUrl)) {
                        withoutHashUrl = withoutBaseUrl;
                    }
                } else {
                    if (this.$$html5) {
                        withoutHashUrl = withoutBaseUrl;
                    } else {
                        withoutHashUrl = "";
                        if (isUndefined(withoutBaseUrl)) {
                            appBase = url;
                            this.replace();
                        }
                    }
                }
                parseAppUrl(withoutHashUrl, this);
                this.$$path = removeWindowsDriveName(this.$$path, withoutHashUrl, appBase);
                this.$$compose();
                function removeWindowsDriveName(path, url, base) {
                    var windowsFilePathExp = /^\/[A-Z]:(\/.*)/;
                    var firstPathSegmentMatch;
                    if (startsWith(url, base)) {
                        url = url.replace(base, "");
                    }
                    if (windowsFilePathExp.exec(url)) {
                        return path;
                    }
                    firstPathSegmentMatch = windowsFilePathExp.exec(path);
                    return firstPathSegmentMatch ? firstPathSegmentMatch[1] : path;
                }
            };
            this.$$compose = function () {
                var search = toKeyValue(this.$$search),
                    hash = this.$$hash ? "#" + encodeUriSegment(this.$$hash) : "";
                this.$$url = encodePath(this.$$path) + (search ? "?" + search : "") + hash;
                this.$$absUrl = appBase + (this.$$url ? hashPrefix + this.$$url : "");
                this.$$urlUpdatedByLocation = true;
            };
            this.$$parseLinkUrl = function (url, relHref) {
                if (stripHash(appBase) === stripHash(url)) {
                    this.$$parse(url);
                    return true;
                }
                return false;
            };
        }
        function LocationHashbangInHtml5Url(appBase, appBaseNoFile, hashPrefix) {
            this.$$html5 = true;
            LocationHashbangUrl.apply(this, arguments);
            this.$$parseLinkUrl = function (url, relHref) {
                if (relHref && relHref[0] === "#") {
                    this.hash(relHref.slice(1));
                    return true;
                }
                var rewrittenUrl;
                var appUrl;
                if (appBase === stripHash(url)) {
                    rewrittenUrl = url;
                } else if ((appUrl = stripBaseUrl(appBaseNoFile, url))) {
                    rewrittenUrl = appBase + hashPrefix + appUrl;
                } else if (appBaseNoFile === url + "/") {
                    rewrittenUrl = appBaseNoFile;
                }
                if (rewrittenUrl) {
                    this.$$parse(rewrittenUrl);
                }
                return !!rewrittenUrl;
            };
            this.$$compose = function () {
                var search = toKeyValue(this.$$search),
                    hash = this.$$hash ? "#" + encodeUriSegment(this.$$hash) : "";
                this.$$url = encodePath(this.$$path) + (search ? "?" + search : "") + hash;
                this.$$absUrl = appBase + hashPrefix + this.$$url;
                this.$$urlUpdatedByLocation = true;
            };
        }
        var locationPrototype = {
            $$absUrl: "",
            $$html5: false,
            $$replace: false,
            absUrl: locationGetter("$$absUrl"),
            url: function (url) {
                if (isUndefined(url)) {
                    return this.$$url;
                }
                var match = PATH_MATCH.exec(url);
                if (match[1] || url === "") this.path(decodeURIComponent(match[1]));
                if (match[2] || match[1] || url === "") this.search(match[3] || "");
                this.hash(match[5] || "");
                return this;
            },
            protocol: locationGetter("$$protocol"),
            host: locationGetter("$$host"),
            port: locationGetter("$$port"),
            path: locationGetterSetter("$$path", function (path) {
                path = path !== null ? path.toString() : "";
                return path.charAt(0) === "/" ? path : "/" + path;
            }),
            search: function (search, paramValue) {
                switch (arguments.length) {
                    case 0:
                        return this.$$search;
                    case 1:
                        if (isString(search) || isNumber(search)) {
                            search = search.toString();
                            this.$$search = parseKeyValue(search);
                        } else if (isObject(search)) {
                            search = copy(search, {});
                            forEach(search, function (value, key) {
                                if (value == null) delete search[key];
                            });
                            this.$$search = search;
                        } else {
                            throw $locationMinErr("isrcharg", "The first argument of the `$location#search()` call must be a string or an object.");
                        }
                        break;
                    default:
                        if (isUndefined(paramValue) || paramValue === null) {
                            delete this.$$search[search];
                        } else {
                            this.$$search[search] = paramValue;
                        }
                }
                this.$$compose();
                return this;
            },
            hash: locationGetterSetter("$$hash", function (hash) {
                return hash !== null ? hash.toString() : "";
            }),
            replace: function () {
                this.$$replace = true;
                return this;
            },
        };
        forEach([LocationHashbangInHtml5Url, LocationHashbangUrl, LocationHtml5Url], function (Location) {
            Location.prototype = Object.create(locationPrototype);
            Location.prototype.state = function (state) {
                if (!arguments.length) {
                    return this.$$state;
                }
                if (Location !== LocationHtml5Url || !this.$$html5) {
                    throw $locationMinErr("nostate", "History API state support is available only " + "in HTML5 mode and only in browsers supporting HTML5 History API");
                }
                this.$$state = isUndefined(state) ? null : state;
                this.$$urlUpdatedByLocation = true;
                return this;
            };
        });
        function locationGetter(property) {
            return function () {
                return this[property];
            };
        }
        function locationGetterSetter(property, preprocess) {
            return function (value) {
                if (isUndefined(value)) {
                    return this[property];
                }
                this[property] = preprocess(value);
                this.$$compose();
                return this;
            };
        }
        function $LocationProvider() {
            var hashPrefix = "!",
                html5Mode = { enabled: false, requireBase: true, rewriteLinks: true };
            this.hashPrefix = function (prefix) {
                if (isDefined(prefix)) {
                    hashPrefix = prefix;
                    return this;
                } else {
                    return hashPrefix;
                }
            };
            this.html5Mode = function (mode) {
                if (isBoolean(mode)) {
                    html5Mode.enabled = mode;
                    return this;
                } else if (isObject(mode)) {
                    if (isBoolean(mode.enabled)) {
                        html5Mode.enabled = mode.enabled;
                    }
                    if (isBoolean(mode.requireBase)) {
                        html5Mode.requireBase = mode.requireBase;
                    }
                    if (isBoolean(mode.rewriteLinks) || isString(mode.rewriteLinks)) {
                        html5Mode.rewriteLinks = mode.rewriteLinks;
                    }
                    return this;
                } else {
                    return html5Mode;
                }
            };
            this.$get = [
                "$rootScope",
                "$browser",
                "$sniffer",
                "$rootElement",
                "$window",
                function ($rootScope, $browser, $sniffer, $rootElement, $window) {
                    var $location,
                        LocationMode,
                        baseHref = $browser.baseHref(),
                        initialUrl = $browser.url(),
                        appBase;
                    if (html5Mode.enabled) {
                        if (!baseHref && html5Mode.requireBase) {
                            throw $locationMinErr("nobase", "$location in HTML5 mode requires a <base> tag to be present!");
                        }
                        appBase = serverBase(initialUrl) + (baseHref || "/");
                        LocationMode = $sniffer.history ? LocationHtml5Url : LocationHashbangInHtml5Url;
                    } else {
                        appBase = stripHash(initialUrl);
                        LocationMode = LocationHashbangUrl;
                    }
                    var appBaseNoFile = stripFile(appBase);
                    $location = new LocationMode(appBase, appBaseNoFile, "#" + hashPrefix);
                    $location.$$parseLinkUrl(initialUrl, initialUrl);
                    $location.$$state = $browser.state();
                    var IGNORE_URI_REGEXP = /^\s*(javascript|mailto):/i;
                    function setBrowserUrlWithFallback(url, replace, state) {
                        var oldUrl = $location.url();
                        var oldState = $location.$$state;
                        try {
                            $browser.url(url, replace, state);
                            $location.$$state = $browser.state();
                        } catch (e) {
                            $location.url(oldUrl);
                            $location.$$state = oldState;
                            throw e;
                        }
                    }
                    $rootElement.on("click", function (event) {
                        var rewriteLinks = html5Mode.rewriteLinks;
                        if (!rewriteLinks || event.ctrlKey || event.metaKey || event.shiftKey || event.which === 2 || event.button === 2) return;
                        var elm = jqLite(event.target);
                        while (nodeName_(elm[0]) !== "a") {
                            if (elm[0] === $rootElement[0] || !(elm = elm.parent())[0]) return;
                        }
                        if (isString(rewriteLinks) && isUndefined(elm.attr(rewriteLinks))) return;
                        var absHref = elm.prop("href");
                        var relHref = elm.attr("href") || elm.attr("xlink:href");
                        if (isObject(absHref) && absHref.toString() === "[object SVGAnimatedString]") {
                            absHref = urlResolve(absHref.animVal).href;
                        }
                        if (IGNORE_URI_REGEXP.test(absHref)) return;
                        if (absHref && !elm.attr("target") && !event.isDefaultPrevented()) {
                            if ($location.$$parseLinkUrl(absHref, relHref)) {
                                event.preventDefault();
                                if ($location.absUrl() !== $browser.url()) {
                                    $rootScope.$apply();
                                    $window.angular["ff-684208-preventDefault"] = true;
                                }
                            }
                        }
                    });
                    if (trimEmptyHash($location.absUrl()) !== trimEmptyHash(initialUrl)) {
                        $browser.url($location.absUrl(), true);
                    }
                    var initializing = true;
                    $browser.onUrlChange(function (newUrl, newState) {
                        if (!startsWith(newUrl, appBaseNoFile)) {
                            $window.location.href = newUrl;
                            return;
                        }
                        $rootScope.$evalAsync(function () {
                            var oldUrl = $location.absUrl();
                            var oldState = $location.$$state;
                            var defaultPrevented;
                            newUrl = trimEmptyHash(newUrl);
                            $location.$$parse(newUrl);
                            $location.$$state = newState;
                            defaultPrevented = $rootScope.$broadcast("$locationChangeStart", newUrl, oldUrl, newState, oldState).defaultPrevented;
                            if ($location.absUrl() !== newUrl) return;
                            if (defaultPrevented) {
                                $location.$$parse(oldUrl);
                                $location.$$state = oldState;
                                setBrowserUrlWithFallback(oldUrl, false, oldState);
                            } else {
                                initializing = false;
                                afterLocationChange(oldUrl, oldState);
                            }
                        });
                        if (!$rootScope.$$phase) $rootScope.$digest();
                    });
                    $rootScope.$watch(function $locationWatch() {
                        if (initializing || $location.$$urlUpdatedByLocation) {
                            $location.$$urlUpdatedByLocation = false;
                            var oldUrl = trimEmptyHash($browser.url());
                            var newUrl = trimEmptyHash($location.absUrl());
                            var oldState = $browser.state();
                            var currentReplace = $location.$$replace;
                            var urlOrStateChanged = oldUrl !== newUrl || ($location.$$html5 && $sniffer.history && oldState !== $location.$$state);
                            if (initializing || urlOrStateChanged) {
                                initializing = false;
                                $rootScope.$evalAsync(function () {
                                    var newUrl = $location.absUrl();
                                    var defaultPrevented = $rootScope.$broadcast("$locationChangeStart", newUrl, oldUrl, $location.$$state, oldState).defaultPrevented;
                                    if ($location.absUrl() !== newUrl) return;
                                    if (defaultPrevented) {
                                        $location.$$parse(oldUrl);
                                        $location.$$state = oldState;
                                    } else {
                                        if (urlOrStateChanged) {
                                            setBrowserUrlWithFallback(newUrl, currentReplace, oldState === $location.$$state ? null : $location.$$state);
                                        }
                                        afterLocationChange(oldUrl, oldState);
                                    }
                                });
                            }
                        }
                        $location.$$replace = false;
                    });
                    return $location;
                    function afterLocationChange(oldUrl, oldState) {
                        $rootScope.$broadcast("$locationChangeSuccess", $location.absUrl(), oldUrl, $location.$$state, oldState);
                    }
                },
            ];
        }
        function $LogProvider() {
            var debug = true,
                self = this;
            this.debugEnabled = function (flag) {
                if (isDefined(flag)) {
                    debug = flag;
                    return this;
                } else {
                    return debug;
                }
            };
            this.$get = [
                "$window",
                function ($window) {
                    var formatStackTrace = msie || /\bEdge\//.test($window.navigator && $window.navigator.userAgent);
                    return {
                        log: consoleLog("log"),
                        info: consoleLog("info"),
                        warn: consoleLog("warn"),
                        error: consoleLog("error"),
                        debug: (function () {
                            var fn = consoleLog("debug");
                            return function () {
                                if (debug) {
                                    fn.apply(self, arguments);
                                }
                            };
                        })(),
                    };
                    function formatError(arg) {
                        if (arg instanceof Error) {
                            if (arg.stack && formatStackTrace) {
                                arg = arg.message && arg.stack.indexOf(arg.message) === -1 ? "Error: " + arg.message + "\n" + arg.stack : arg.stack;
                            } else if (arg.sourceURL) {
                                arg = arg.message + "\n" + arg.sourceURL + ":" + arg.line;
                            }
                        }
                        return arg;
                    }
                    function consoleLog(type) {
                        var console = $window.console || {},
                            logFn = console[type] || console.log || noop,
                            hasApply = false;
                        try {
                            hasApply = !!logFn.apply;
                        } catch (e) { }
                        if (hasApply) {
                            return function () {
                                var args = [];
                                forEach(arguments, function (arg) {
                                    args.push(formatError(arg));
                                });
                                return logFn.apply(console, args);
                            };
                        }
                        return function (arg1, arg2) {
                            logFn(arg1, arg2 == null ? "" : arg2);
                        };
                    }
                },
            ];
        }
        var $parseMinErr = minErr("$parse");
        var objectValueOf = {}.constructor.prototype.valueOf;
        function getStringValue(name) {
            return name + "";
        }
        var OPERATORS = createMap();
        forEach("+ - * / % === !== == != < > <= >= && || ! = |".split(" "), function (operator) {
            OPERATORS[operator] = true;
        });
        var ESCAPE = { n: "\n", f: "\f", r: "\r", t: "\t", v: "\v", "'": "'", '"': '"' };
        var Lexer = function Lexer(options) {
            this.options = options;
        };
        Lexer.prototype = {
            constructor: Lexer,
            lex: function (text) {
                this.text = text;
                this.index = 0;
                this.tokens = [];
                while (this.index < this.text.length) {
                    var ch = this.text.charAt(this.index);
                    if (ch === '"' || ch === "'") {
                        this.readString(ch);
                    } else if (this.isNumber(ch) || (ch === "." && this.isNumber(this.peek()))) {
                        this.readNumber();
                    } else if (this.isIdentifierStart(this.peekMultichar())) {
                        this.readIdent();
                    } else if (this.is(ch, "(){}[].,;:?")) {
                        this.tokens.push({ index: this.index, text: ch });
                        this.index++;
                    } else if (this.isWhitespace(ch)) {
                        this.index++;
                    } else {
                        var ch2 = ch + this.peek();
                        var ch3 = ch2 + this.peek(2);
                        var op1 = OPERATORS[ch];
                        var op2 = OPERATORS[ch2];
                        var op3 = OPERATORS[ch3];
                        if (op1 || op2 || op3) {
                            var token = op3 ? ch3 : op2 ? ch2 : ch;
                            this.tokens.push({ index: this.index, text: token, operator: true });
                            this.index += token.length;
                        } else {
                            this.throwError("Unexpected next character ", this.index, this.index + 1);
                        }
                    }
                }
                return this.tokens;
            },
            is: function (ch, chars) {
                return chars.indexOf(ch) !== -1;
            },
            peek: function (i) {
                var num = i || 1;
                return this.index + num < this.text.length ? this.text.charAt(this.index + num) : false;
            },
            isNumber: function (ch) {
                return "0" <= ch && ch <= "9" && typeof ch === "string";
            },
            isWhitespace: function (ch) {
                return ch === " " || ch === "\r" || ch === "\t" || ch === "\n" || ch === "\v" || ch === "Â ";
            },
            isIdentifierStart: function (ch) {
                return this.options.isIdentifierStart ? this.options.isIdentifierStart(ch, this.codePointAt(ch)) : this.isValidIdentifierStart(ch);
            },
            isValidIdentifierStart: function (ch) {
                return ("a" <= ch && ch <= "z") || ("A" <= ch && ch <= "Z") || "_" === ch || ch === "$";
            },
            isIdentifierContinue: function (ch) {
                return this.options.isIdentifierContinue ? this.options.isIdentifierContinue(ch, this.codePointAt(ch)) : this.isValidIdentifierContinue(ch);
            },
            isValidIdentifierContinue: function (ch, cp) {
                return this.isValidIdentifierStart(ch, cp) || this.isNumber(ch);
            },
            codePointAt: function (ch) {
                if (ch.length === 1) return ch.charCodeAt(0);
                return (ch.charCodeAt(0) << 10) + ch.charCodeAt(1) - 56613888;
            },
            peekMultichar: function () {
                var ch = this.text.charAt(this.index);
                var peek = this.peek();
                if (!peek) {
                    return ch;
                }
                var cp1 = ch.charCodeAt(0);
                var cp2 = peek.charCodeAt(0);
                if (cp1 >= 55296 && cp1 <= 56319 && cp2 >= 56320 && cp2 <= 57343) {
                    return ch + peek;
                }
                return ch;
            },
            isExpOperator: function (ch) {
                return ch === "-" || ch === "+" || this.isNumber(ch);
            },
            throwError: function (error, start, end) {
                end = end || this.index;
                var colStr = isDefined(start) ? "s " + start + "-" + this.index + " [" + this.text.substring(start, end) + "]" : " " + end;
                throw $parseMinErr("lexerr", "Lexer Error: {0} at column{1} in expression [{2}].", error, colStr, this.text);
            },
            readNumber: function () {
                var number = "";
                var start = this.index;
                while (this.index < this.text.length) {
                    var ch = lowercase(this.text.charAt(this.index));
                    if (ch === "." || this.isNumber(ch)) {
                        number += ch;
                    } else {
                        var peekCh = this.peek();
                        if (ch === "e" && this.isExpOperator(peekCh)) {
                            number += ch;
                        } else if (this.isExpOperator(ch) && peekCh && this.isNumber(peekCh) && number.charAt(number.length - 1) === "e") {
                            number += ch;
                        } else if (this.isExpOperator(ch) && (!peekCh || !this.isNumber(peekCh)) && number.charAt(number.length - 1) === "e") {
                            this.throwError("Invalid exponent");
                        } else {
                            break;
                        }
                    }
                    this.index++;
                }
                this.tokens.push({ index: start, text: number, constant: true, value: Number(number) });
            },
            readIdent: function () {
                var start = this.index;
                this.index += this.peekMultichar().length;
                while (this.index < this.text.length) {
                    var ch = this.peekMultichar();
                    if (!this.isIdentifierContinue(ch)) {
                        break;
                    }
                    this.index += ch.length;
                }
                this.tokens.push({ index: start, text: this.text.slice(start, this.index), identifier: true });
            },
            readString: function (quote) {
                var start = this.index;
                this.index++;
                var string = "";
                var rawString = quote;
                var escape = false;
                while (this.index < this.text.length) {
                    var ch = this.text.charAt(this.index);
                    rawString += ch;
                    if (escape) {
                        if (ch === "u") {
                            var hex = this.text.substring(this.index + 1, this.index + 5);
                            if (!hex.match(/[\da-f]{4}/i)) {
                                this.throwError("Invalid unicode escape [\\u" + hex + "]");
                            }
                            this.index += 4;
                            string += String.fromCharCode(parseInt(hex, 16));
                        } else {
                            var rep = ESCAPE[ch];
                            string = string + (rep || ch);
                        }
                        escape = false;
                    } else if (ch === "\\") {
                        escape = true;
                    } else if (ch === quote) {
                        this.index++;
                        this.tokens.push({ index: start, text: rawString, constant: true, value: string });
                        return;
                    } else {
                        string += ch;
                    }
                    this.index++;
                }
                this.throwError("Unterminated quote", start);
            },
        };
        var AST = function AST(lexer, options) {
            this.lexer = lexer;
            this.options = options;
        };
        AST.Program = "Program";
        AST.ExpressionStatement = "ExpressionStatement";
        AST.AssignmentExpression = "AssignmentExpression";
        AST.ConditionalExpression = "ConditionalExpression";
        AST.LogicalExpression = "LogicalExpression";
        AST.BinaryExpression = "BinaryExpression";
        AST.UnaryExpression = "UnaryExpression";
        AST.CallExpression = "CallExpression";
        AST.MemberExpression = "MemberExpression";
        AST.Identifier = "Identifier";
        AST.Literal = "Literal";
        AST.ArrayExpression = "ArrayExpression";
        AST.Property = "Property";
        AST.ObjectExpression = "ObjectExpression";
        AST.ThisExpression = "ThisExpression";
        AST.LocalsExpression = "LocalsExpression";
        AST.NGValueParameter = "NGValueParameter";
        AST.prototype = {
            ast: function (text) {
                this.text = text;
                this.tokens = this.lexer.lex(text);
                var value = this.program();
                if (this.tokens.length !== 0) {
                    this.throwError("is an unexpected token", this.tokens[0]);
                }
                return value;
            },
            program: function () {
                var body = [];
                while (true) {
                    if (this.tokens.length > 0 && !this.peek("}", ")", ";", "]")) body.push(this.expressionStatement());
                    if (!this.expect(";")) {
                        return { type: AST.Program, body: body };
                    }
                }
            },
            expressionStatement: function () {
                return { type: AST.ExpressionStatement, expression: this.filterChain() };
            },
            filterChain: function () {
                var left = this.expression();
                while (this.expect("|")) {
                    left = this.filter(left);
                }
                return left;
            },
            expression: function () {
                return this.assignment();
            },
            assignment: function () {
                var result = this.ternary();
                if (this.expect("=")) {
                    if (!isAssignable(result)) {
                        throw $parseMinErr("lval", "Trying to assign a value to a non l-value");
                    }
                    result = { type: AST.AssignmentExpression, left: result, right: this.assignment(), operator: "=" };
                }
                return result;
            },
            ternary: function () {
                var test = this.logicalOR();
                var alternate;
                var consequent;
                if (this.expect("?")) {
                    alternate = this.expression();
                    if (this.consume(":")) {
                        consequent = this.expression();
                        return { type: AST.ConditionalExpression, test: test, alternate: alternate, consequent: consequent };
                    }
                }
                return test;
            },
            logicalOR: function () {
                var left = this.logicalAND();
                while (this.expect("||")) {
                    left = { type: AST.LogicalExpression, operator: "||", left: left, right: this.logicalAND() };
                }
                return left;
            },
            logicalAND: function () {
                var left = this.equality();
                while (this.expect("&&")) {
                    left = { type: AST.LogicalExpression, operator: "&&", left: left, right: this.equality() };
                }
                return left;
            },
            equality: function () {
                var left = this.relational();
                var token;
                while ((token = this.expect("==", "!=", "===", "!=="))) {
                    left = { type: AST.BinaryExpression, operator: token.text, left: left, right: this.relational() };
                }
                return left;
            },
            relational: function () {
                var left = this.additive();
                var token;
                while ((token = this.expect("<", ">", "<=", ">="))) {
                    left = { type: AST.BinaryExpression, operator: token.text, left: left, right: this.additive() };
                }
                return left;
            },
            additive: function () {
                var left = this.multiplicative();
                var token;
                while ((token = this.expect("+", "-"))) {
                    left = { type: AST.BinaryExpression, operator: token.text, left: left, right: this.multiplicative() };
                }
                return left;
            },
            multiplicative: function () {
                var left = this.unary();
                var token;
                while ((token = this.expect("*", "/", "%"))) {
                    left = { type: AST.BinaryExpression, operator: token.text, left: left, right: this.unary() };
                }
                return left;
            },
            unary: function () {
                var token;
                if ((token = this.expect("+", "-", "!"))) {
                    return { type: AST.UnaryExpression, operator: token.text, prefix: true, argument: this.unary() };
                } else {
                    return this.primary();
                }
            },
            primary: function () {
                var primary;
                if (this.expect("(")) {
                    primary = this.filterChain();
                    this.consume(")");
                } else if (this.expect("[")) {
                    primary = this.arrayDeclaration();
                } else if (this.expect("{")) {
                    primary = this.object();
                } else if (this.selfReferential.hasOwnProperty(this.peek().text)) {
                    primary = copy(this.selfReferential[this.consume().text]);
                } else if (this.options.literals.hasOwnProperty(this.peek().text)) {
                    primary = { type: AST.Literal, value: this.options.literals[this.consume().text] };
                } else if (this.peek().identifier) {
                    primary = this.identifier();
                } else if (this.peek().constant) {
                    primary = this.constant();
                } else {
                    this.throwError("not a primary expression", this.peek());
                }
                var next;
                while ((next = this.expect("(", "[", "."))) {
                    if (next.text === "(") {
                        primary = { type: AST.CallExpression, callee: primary, arguments: this.parseArguments() };
                        this.consume(")");
                    } else if (next.text === "[") {
                        primary = { type: AST.MemberExpression, object: primary, property: this.expression(), computed: true };
                        this.consume("]");
                    } else if (next.text === ".") {
                        primary = { type: AST.MemberExpression, object: primary, property: this.identifier(), computed: false };
                    } else {
                        this.throwError("IMPOSSIBLE");
                    }
                }
                return primary;
            },
            filter: function (baseExpression) {
                var args = [baseExpression];
                var result = { type: AST.CallExpression, callee: this.identifier(), arguments: args, filter: true };
                while (this.expect(":")) {
                    args.push(this.expression());
                }
                return result;
            },
            parseArguments: function () {
                var args = [];
                if (this.peekToken().text !== ")") {
                    do {
                        args.push(this.filterChain());
                    } while (this.expect(","));
                }
                return args;
            },
            identifier: function () {
                var token = this.consume();
                if (!token.identifier) {
                    this.throwError("is not a valid identifier", token);
                }
                return { type: AST.Identifier, name: token.text };
            },
            constant: function () {
                return { type: AST.Literal, value: this.consume().value };
            },
            arrayDeclaration: function () {
                var elements = [];
                if (this.peekToken().text !== "]") {
                    do {
                        if (this.peek("]")) {
                            break;
                        }
                        elements.push(this.expression());
                    } while (this.expect(","));
                }
                this.consume("]");
                return { type: AST.ArrayExpression, elements: elements };
            },
            object: function () {
                var properties = [],
                    property;
                if (this.peekToken().text !== "}") {
                    do {
                        if (this.peek("}")) {
                            break;
                        }
                        property = { type: AST.Property, kind: "init" };
                        if (this.peek().constant) {
                            property.key = this.constant();
                            property.computed = false;
                            this.consume(":");
                            property.value = this.expression();
                        } else if (this.peek().identifier) {
                            property.key = this.identifier();
                            property.computed = false;
                            if (this.peek(":")) {
                                this.consume(":");
                                property.value = this.expression();
                            } else {
                                property.value = property.key;
                            }
                        } else if (this.peek("[")) {
                            this.consume("[");
                            property.key = this.expression();
                            this.consume("]");
                            property.computed = true;
                            this.consume(":");
                            property.value = this.expression();
                        } else {
                            this.throwError("invalid key", this.peek());
                        }
                        properties.push(property);
                    } while (this.expect(","));
                }
                this.consume("}");
                return { type: AST.ObjectExpression, properties: properties };
            },
            throwError: function (msg, token) {
                throw $parseMinErr("syntax", "Syntax Error: Token '{0}' {1} at column {2} of the expression [{3}] starting at [{4}].", token.text, msg, token.index + 1, this.text, this.text.substring(token.index));
            },
            consume: function (e1) {
                if (this.tokens.length === 0) {
                    throw $parseMinErr("ueoe", "Unexpected end of expression: {0}", this.text);
                }
                var token = this.expect(e1);
                if (!token) {
                    this.throwError("is unexpected, expecting [" + e1 + "]", this.peek());
                }
                return token;
            },
            peekToken: function () {
                if (this.tokens.length === 0) {
                    throw $parseMinErr("ueoe", "Unexpected end of expression: {0}", this.text);
                }
                return this.tokens[0];
            },
            peek: function (e1, e2, e3, e4) {
                return this.peekAhead(0, e1, e2, e3, e4);
            },
            peekAhead: function (i, e1, e2, e3, e4) {
                if (this.tokens.length > i) {
                    var token = this.tokens[i];
                    var t = token.text;
                    if (t === e1 || t === e2 || t === e3 || t === e4 || (!e1 && !e2 && !e3 && !e4)) {
                        return token;
                    }
                }
                return false;
            },
            expect: function (e1, e2, e3, e4) {
                var token = this.peek(e1, e2, e3, e4);
                if (token) {
                    this.tokens.shift();
                    return token;
                }
                return false;
            },
            selfReferential: { this: { type: AST.ThisExpression }, $locals: { type: AST.LocalsExpression } },
        };
        function ifDefined(v, d) {
            return typeof v !== "undefined" ? v : d;
        }
        function plusFn(l, r) {
            if (typeof l === "undefined") return r;
            if (typeof r === "undefined") return l;
            return l + r;
        }
        function isStateless($filter, filterName) {
            var fn = $filter(filterName);
            return !fn.$stateful;
        }
        function findConstantAndWatchExpressions(ast, $filter) {
            var allConstants;
            var argsToWatch;
            var isStatelessFilter;
            switch (ast.type) {
                case AST.Program:
                    allConstants = true;
                    forEach(ast.body, function (expr) {
                        findConstantAndWatchExpressions(expr.expression, $filter);
                        allConstants = allConstants && expr.expression.constant;
                    });
                    ast.constant = allConstants;
                    break;
                case AST.Literal:
                    ast.constant = true;
                    ast.toWatch = [];
                    break;
                case AST.UnaryExpression:
                    findConstantAndWatchExpressions(ast.argument, $filter);
                    ast.constant = ast.argument.constant;
                    ast.toWatch = ast.argument.toWatch;
                    break;
                case AST.BinaryExpression:
                    findConstantAndWatchExpressions(ast.left, $filter);
                    findConstantAndWatchExpressions(ast.right, $filter);
                    ast.constant = ast.left.constant && ast.right.constant;
                    ast.toWatch = ast.left.toWatch.concat(ast.right.toWatch);
                    break;
                case AST.LogicalExpression:
                    findConstantAndWatchExpressions(ast.left, $filter);
                    findConstantAndWatchExpressions(ast.right, $filter);
                    ast.constant = ast.left.constant && ast.right.constant;
                    ast.toWatch = ast.constant ? [] : [ast];
                    break;
                case AST.ConditionalExpression:
                    findConstantAndWatchExpressions(ast.test, $filter);
                    findConstantAndWatchExpressions(ast.alternate, $filter);
                    findConstantAndWatchExpressions(ast.consequent, $filter);
                    ast.constant = ast.test.constant && ast.alternate.constant && ast.consequent.constant;
                    ast.toWatch = ast.constant ? [] : [ast];
                    break;
                case AST.Identifier:
                    ast.constant = false;
                    ast.toWatch = [ast];
                    break;
                case AST.MemberExpression:
                    findConstantAndWatchExpressions(ast.object, $filter);
                    if (ast.computed) {
                        findConstantAndWatchExpressions(ast.property, $filter);
                    }
                    ast.constant = ast.object.constant && (!ast.computed || ast.property.constant);
                    ast.toWatch = [ast];
                    break;
                case AST.CallExpression:
                    isStatelessFilter = ast.filter ? isStateless($filter, ast.callee.name) : false;
                    allConstants = isStatelessFilter;
                    argsToWatch = [];
                    forEach(ast.arguments, function (expr) {
                        findConstantAndWatchExpressions(expr, $filter);
                        allConstants = allConstants && expr.constant;
                        if (!expr.constant) {
                            argsToWatch.push.apply(argsToWatch, expr.toWatch);
                        }
                    });
                    ast.constant = allConstants;
                    ast.toWatch = isStatelessFilter ? argsToWatch : [ast];
                    break;
                case AST.AssignmentExpression:
                    findConstantAndWatchExpressions(ast.left, $filter);
                    findConstantAndWatchExpressions(ast.right, $filter);
                    ast.constant = ast.left.constant && ast.right.constant;
                    ast.toWatch = [ast];
                    break;
                case AST.ArrayExpression:
                    allConstants = true;
                    argsToWatch = [];
                    forEach(ast.elements, function (expr) {
                        findConstantAndWatchExpressions(expr, $filter);
                        allConstants = allConstants && expr.constant;
                        if (!expr.constant) {
                            argsToWatch.push.apply(argsToWatch, expr.toWatch);
                        }
                    });
                    ast.constant = allConstants;
                    ast.toWatch = argsToWatch;
                    break;
                case AST.ObjectExpression:
                    allConstants = true;
                    argsToWatch = [];
                    forEach(ast.properties, function (property) {
                        findConstantAndWatchExpressions(property.value, $filter);
                        allConstants = allConstants && property.value.constant && !property.computed;
                        if (!property.value.constant) {
                            argsToWatch.push.apply(argsToWatch, property.value.toWatch);
                        }
                        if (property.computed) {
                            findConstantAndWatchExpressions(property.key, $filter);
                            if (!property.key.constant) {
                                argsToWatch.push.apply(argsToWatch, property.key.toWatch);
                            }
                        }
                    });
                    ast.constant = allConstants;
                    ast.toWatch = argsToWatch;
                    break;
                case AST.ThisExpression:
                    ast.constant = false;
                    ast.toWatch = [];
                    break;
                case AST.LocalsExpression:
                    ast.constant = false;
                    ast.toWatch = [];
                    break;
            }
        }
        function getInputs(body) {
            if (body.length !== 1) return;
            var lastExpression = body[0].expression;
            var candidate = lastExpression.toWatch;
            if (candidate.length !== 1) return candidate;
            return candidate[0] !== lastExpression ? candidate : undefined;
        }
        function isAssignable(ast) {
            return ast.type === AST.Identifier || ast.type === AST.MemberExpression;
        }
        function assignableAST(ast) {
            if (ast.body.length === 1 && isAssignable(ast.body[0].expression)) {
                return { type: AST.AssignmentExpression, left: ast.body[0].expression, right: { type: AST.NGValueParameter }, operator: "=" };
            }
        }
        function isLiteral(ast) {
            return ast.body.length === 0 || (ast.body.length === 1 && (ast.body[0].expression.type === AST.Literal || ast.body[0].expression.type === AST.ArrayExpression || ast.body[0].expression.type === AST.ObjectExpression));
        }
        function isConstant(ast) {
            return ast.constant;
        }
        function ASTCompiler($filter) {
            this.$filter = $filter;
        }
        ASTCompiler.prototype = {
            compile: function (ast) {
                var self = this;
                this.state = { nextId: 0, filters: {}, fn: { vars: [], body: [], own: {} }, assign: { vars: [], body: [], own: {} }, inputs: [] };
                findConstantAndWatchExpressions(ast, self.$filter);
                var extra = "";
                var assignable;
                this.stage = "assign";
                if ((assignable = assignableAST(ast))) {
                    this.state.computing = "assign";
                    var result = this.nextId();
                    this.recurse(assignable, result);
                    this.return_(result);
                    extra = "fn.assign=" + this.generateFunction("assign", "s,v,l");
                }
                var toWatch = getInputs(ast.body);
                self.stage = "inputs";
                forEach(toWatch, function (watch, key) {
                    var fnKey = "fn" + key;
                    self.state[fnKey] = { vars: [], body: [], own: {} };
                    self.state.computing = fnKey;
                    var intoId = self.nextId();
                    self.recurse(watch, intoId);
                    self.return_(intoId);
                    self.state.inputs.push(fnKey);
                    watch.watchId = key;
                });
                this.state.computing = "fn";
                this.stage = "main";
                this.recurse(ast);
                var fnString = '"' + this.USE + " " + this.STRICT + '";\n' + this.filterPrefix() + "var fn=" + this.generateFunction("fn", "s,l,a,i") + extra + this.watchFns() + "return fn;";
                var fn = new Function("$filter", "getStringValue", "ifDefined", "plus", fnString)(this.$filter, getStringValue, ifDefined, plusFn);
                this.state = this.stage = undefined;
                return fn;
            },
            USE: "use",
            STRICT: "strict",
            watchFns: function () {
                var result = [];
                var fns = this.state.inputs;
                var self = this;
                forEach(fns, function (name) {
                    result.push("var " + name + "=" + self.generateFunction(name, "s"));
                });
                if (fns.length) {
                    result.push("fn.inputs=[" + fns.join(",") + "];");
                }
                return result.join("");
            },
            generateFunction: function (name, params) {
                return "function(" + params + "){" + this.varsPrefix(name) + this.body(name) + "};";
            },
            filterPrefix: function () {
                var parts = [];
                var self = this;
                forEach(this.state.filters, function (id, filter) {
                    parts.push(id + "=$filter(" + self.escape(filter) + ")");
                });
                if (parts.length) return "var " + parts.join(",") + ";";
                return "";
            },
            varsPrefix: function (section) {
                return this.state[section].vars.length ? "var " + this.state[section].vars.join(",") + ";" : "";
            },
            body: function (section) {
                return this.state[section].body.join("");
            },
            recurse: function (ast, intoId, nameId, recursionFn, create, skipWatchIdCheck) {
                var left,
                    right,
                    self = this,
                    args,
                    expression,
                    computed;
                recursionFn = recursionFn || noop;
                if (!skipWatchIdCheck && isDefined(ast.watchId)) {
                    intoId = intoId || this.nextId();
                    this.if_("i", this.lazyAssign(intoId, this.computedMember("i", ast.watchId)), this.lazyRecurse(ast, intoId, nameId, recursionFn, create, true));
                    return;
                }
                switch (ast.type) {
                    case AST.Program:
                        forEach(ast.body, function (expression, pos) {
                            self.recurse(expression.expression, undefined, undefined, function (expr) {
                                right = expr;
                            });
                            if (pos !== ast.body.length - 1) {
                                self.current().body.push(right, ";");
                            } else {
                                self.return_(right);
                            }
                        });
                        break;
                    case AST.Literal:
                        expression = this.escape(ast.value);
                        this.assign(intoId, expression);
                        recursionFn(intoId || expression);
                        break;
                    case AST.UnaryExpression:
                        this.recurse(ast.argument, undefined, undefined, function (expr) {
                            right = expr;
                        });
                        expression = ast.operator + "(" + this.ifDefined(right, 0) + ")";
                        this.assign(intoId, expression);
                        recursionFn(expression);
                        break;
                    case AST.BinaryExpression:
                        this.recurse(ast.left, undefined, undefined, function (expr) {
                            left = expr;
                        });
                        this.recurse(ast.right, undefined, undefined, function (expr) {
                            right = expr;
                        });
                        if (ast.operator === "+") {
                            expression = this.plus(left, right);
                        } else if (ast.operator === "-") {
                            expression = this.ifDefined(left, 0) + ast.operator + this.ifDefined(right, 0);
                        } else {
                            expression = "(" + left + ")" + ast.operator + "(" + right + ")";
                        }
                        this.assign(intoId, expression);
                        recursionFn(expression);
                        break;
                    case AST.LogicalExpression:
                        intoId = intoId || this.nextId();
                        self.recurse(ast.left, intoId);
                        self.if_(ast.operator === "&&" ? intoId : self.not(intoId), self.lazyRecurse(ast.right, intoId));
                        recursionFn(intoId);
                        break;
                    case AST.ConditionalExpression:
                        intoId = intoId || this.nextId();
                        self.recurse(ast.test, intoId);
                        self.if_(intoId, self.lazyRecurse(ast.alternate, intoId), self.lazyRecurse(ast.consequent, intoId));
                        recursionFn(intoId);
                        break;
                    case AST.Identifier:
                        intoId = intoId || this.nextId();
                        if (nameId) {
                            nameId.context = self.stage === "inputs" ? "s" : this.assign(this.nextId(), this.getHasOwnProperty("l", ast.name) + "?l:s");
                            nameId.computed = false;
                            nameId.name = ast.name;
                        }
                        self.if_(
                            self.stage === "inputs" || self.not(self.getHasOwnProperty("l", ast.name)),
                            function () {
                                self.if_(self.stage === "inputs" || "s", function () {
                                    if (create && create !== 1) {
                                        self.if_(self.isNull(self.nonComputedMember("s", ast.name)), self.lazyAssign(self.nonComputedMember("s", ast.name), "{}"));
                                    }
                                    self.assign(intoId, self.nonComputedMember("s", ast.name));
                                });
                            },
                            intoId && self.lazyAssign(intoId, self.nonComputedMember("l", ast.name))
                        );
                        recursionFn(intoId);
                        break;
                    case AST.MemberExpression:
                        left = (nameId && (nameId.context = this.nextId())) || this.nextId();
                        intoId = intoId || this.nextId();
                        self.recurse(
                            ast.object,
                            left,
                            undefined,
                            function () {
                                self.if_(
                                    self.notNull(left),
                                    function () {
                                        if (ast.computed) {
                                            right = self.nextId();
                                            self.recurse(ast.property, right);
                                            self.getStringValue(right);
                                            if (create && create !== 1) {
                                                self.if_(self.not(self.computedMember(left, right)), self.lazyAssign(self.computedMember(left, right), "{}"));
                                            }
                                            expression = self.computedMember(left, right);
                                            self.assign(intoId, expression);
                                            if (nameId) {
                                                nameId.computed = true;
                                                nameId.name = right;
                                            }
                                        } else {
                                            if (create && create !== 1) {
                                                self.if_(self.isNull(self.nonComputedMember(left, ast.property.name)), self.lazyAssign(self.nonComputedMember(left, ast.property.name), "{}"));
                                            }
                                            expression = self.nonComputedMember(left, ast.property.name);
                                            self.assign(intoId, expression);
                                            if (nameId) {
                                                nameId.computed = false;
                                                nameId.name = ast.property.name;
                                            }
                                        }
                                    },
                                    function () {
                                        self.assign(intoId, "undefined");
                                    }
                                );
                                recursionFn(intoId);
                            },
                            !!create
                        );
                        break;
                    case AST.CallExpression:
                        intoId = intoId || this.nextId();
                        if (ast.filter) {
                            right = self.filter(ast.callee.name);
                            args = [];
                            forEach(ast.arguments, function (expr) {
                                var argument = self.nextId();
                                self.recurse(expr, argument);
                                args.push(argument);
                            });
                            expression = right + "(" + args.join(",") + ")";
                            self.assign(intoId, expression);
                            recursionFn(intoId);
                        } else {
                            right = self.nextId();
                            left = {};
                            args = [];
                            self.recurse(ast.callee, right, left, function () {
                                self.if_(
                                    self.notNull(right),
                                    function () {
                                        forEach(ast.arguments, function (expr) {
                                            self.recurse(expr, ast.constant ? undefined : self.nextId(), undefined, function (argument) {
                                                args.push(argument);
                                            });
                                        });
                                        if (left.name) {
                                            expression = self.member(left.context, left.name, left.computed) + "(" + args.join(",") + ")";
                                        } else {
                                            expression = right + "(" + args.join(",") + ")";
                                        }
                                        self.assign(intoId, expression);
                                    },
                                    function () {
                                        self.assign(intoId, "undefined");
                                    }
                                );
                                recursionFn(intoId);
                            });
                        }
                        break;
                    case AST.AssignmentExpression:
                        right = this.nextId();
                        left = {};
                        this.recurse(
                            ast.left,
                            undefined,
                            left,
                            function () {
                                self.if_(self.notNull(left.context), function () {
                                    self.recurse(ast.right, right);
                                    expression = self.member(left.context, left.name, left.computed) + ast.operator + right;
                                    self.assign(intoId, expression);
                                    recursionFn(intoId || expression);
                                });
                            },
                            1
                        );
                        break;
                    case AST.ArrayExpression:
                        args = [];
                        forEach(ast.elements, function (expr) {
                            self.recurse(expr, ast.constant ? undefined : self.nextId(), undefined, function (argument) {
                                args.push(argument);
                            });
                        });
                        expression = "[" + args.join(",") + "]";
                        this.assign(intoId, expression);
                        recursionFn(intoId || expression);
                        break;
                    case AST.ObjectExpression:
                        args = [];
                        computed = false;
                        forEach(ast.properties, function (property) {
                            if (property.computed) {
                                computed = true;
                            }
                        });
                        if (computed) {
                            intoId = intoId || this.nextId();
                            this.assign(intoId, "{}");
                            forEach(ast.properties, function (property) {
                                if (property.computed) {
                                    left = self.nextId();
                                    self.recurse(property.key, left);
                                } else {
                                    left = property.key.type === AST.Identifier ? property.key.name : "" + property.key.value;
                                }
                                right = self.nextId();
                                self.recurse(property.value, right);
                                self.assign(self.member(intoId, left, property.computed), right);
                            });
                        } else {
                            forEach(ast.properties, function (property) {
                                self.recurse(property.value, ast.constant ? undefined : self.nextId(), undefined, function (expr) {
                                    args.push(self.escape(property.key.type === AST.Identifier ? property.key.name : "" + property.key.value) + ":" + expr);
                                });
                            });
                            expression = "{" + args.join(",") + "}";
                            this.assign(intoId, expression);
                        }
                        recursionFn(intoId || expression);
                        break;
                    case AST.ThisExpression:
                        this.assign(intoId, "s");
                        recursionFn(intoId || "s");
                        break;
                    case AST.LocalsExpression:
                        this.assign(intoId, "l");
                        recursionFn(intoId || "l");
                        break;
                    case AST.NGValueParameter:
                        this.assign(intoId, "v");
                        recursionFn(intoId || "v");
                        break;
                }
            },
            getHasOwnProperty: function (element, property) {
                var key = element + "." + property;
                var own = this.current().own;
                if (!own.hasOwnProperty(key)) {
                    own[key] = this.nextId(false, element + "&&(" + this.escape(property) + " in " + element + ")");
                }
                return own[key];
            },
            assign: function (id, value) {
                if (!id) return;
                this.current().body.push(id, "=", value, ";");
                return id;
            },
            filter: function (filterName) {
                if (!this.state.filters.hasOwnProperty(filterName)) {
                    this.state.filters[filterName] = this.nextId(true);
                }
                return this.state.filters[filterName];
            },
            ifDefined: function (id, defaultValue) {
                return "ifDefined(" + id + "," + this.escape(defaultValue) + ")";
            },
            plus: function (left, right) {
                return "plus(" + left + "," + right + ")";
            },
            return_: function (id) {
                this.current().body.push("return ", id, ";");
            },
            if_: function (test, alternate, consequent) {
                if (test === true) {
                    alternate();
                } else {
                    var body = this.current().body;
                    body.push("if(", test, "){");
                    alternate();
                    body.push("}");
                    if (consequent) {
                        body.push("else{");
                        consequent();
                        body.push("}");
                    }
                }
            },
            not: function (expression) {
                return "!(" + expression + ")";
            },
            isNull: function (expression) {
                return expression + "==null";
            },
            notNull: function (expression) {
                return expression + "!=null";
            },
            nonComputedMember: function (left, right) {
                var SAFE_IDENTIFIER = /^[$_a-zA-Z][$_a-zA-Z0-9]*$/;
                var UNSAFE_CHARACTERS = /[^$_a-zA-Z0-9]/g;
                if (SAFE_IDENTIFIER.test(right)) {
                    return left + "." + right;
                } else {
                    return left + '["' + right.replace(UNSAFE_CHARACTERS, this.stringEscapeFn) + '"]';
                }
            },
            computedMember: function (left, right) {
                return left + "[" + right + "]";
            },
            member: function (left, right, computed) {
                if (computed) return this.computedMember(left, right);
                return this.nonComputedMember(left, right);
            },
            getStringValue: function (item) {
                this.assign(item, "getStringValue(" + item + ")");
            },
            lazyRecurse: function (ast, intoId, nameId, recursionFn, create, skipWatchIdCheck) {
                var self = this;
                return function () {
                    self.recurse(ast, intoId, nameId, recursionFn, create, skipWatchIdCheck);
                };
            },
            lazyAssign: function (id, value) {
                var self = this;
                return function () {
                    self.assign(id, value);
                };
            },
            stringEscapeRegex: /[^ a-zA-Z0-9]/g,
            stringEscapeFn: function (c) {
                return "\\u" + ("0000" + c.charCodeAt(0).toString(16)).slice(-4);
            },
            escape: function (value) {
                if (isString(value)) return "'" + value.replace(this.stringEscapeRegex, this.stringEscapeFn) + "'";
                if (isNumber(value)) return value.toString();
                if (value === true) return "true";
                if (value === false) return "false";
                if (value === null) return "null";
                if (typeof value === "undefined") return "undefined";
                throw $parseMinErr("esc", "IMPOSSIBLE");
            },
            nextId: function (skip, init) {
                var id = "v" + this.state.nextId++;
                if (!skip) {
                    this.current().vars.push(id + (init ? "=" + init : ""));
                }
                return id;
            },
            current: function () {
                return this.state[this.state.computing];
            },
        };
        function ASTInterpreter($filter) {
            this.$filter = $filter;
        }
        ASTInterpreter.prototype = {
            compile: function (ast) {
                var self = this;
                findConstantAndWatchExpressions(ast, self.$filter);
                var assignable;
                var assign;
                if ((assignable = assignableAST(ast))) {
                    assign = this.recurse(assignable);
                }
                var toWatch = getInputs(ast.body);
                var inputs;
                if (toWatch) {
                    inputs = [];
                    forEach(toWatch, function (watch, key) {
                        var input = self.recurse(watch);
                        watch.input = input;
                        inputs.push(input);
                        watch.watchId = key;
                    });
                }
                var expressions = [];
                forEach(ast.body, function (expression) {
                    expressions.push(self.recurse(expression.expression));
                });
                var fn =
                    ast.body.length === 0
                        ? noop
                        : ast.body.length === 1
                            ? expressions[0]
                            : function (scope, locals) {
                                var lastValue;
                                forEach(expressions, function (exp) {
                                    lastValue = exp(scope, locals);
                                });
                                return lastValue;
                            };
                if (assign) {
                    fn.assign = function (scope, value, locals) {
                        return assign(scope, locals, value);
                    };
                }
                if (inputs) {
                    fn.inputs = inputs;
                }
                return fn;
            },
            recurse: function (ast, context, create) {
                var left,
                    right,
                    self = this,
                    args;
                if (ast.input) {
                    return this.inputs(ast.input, ast.watchId);
                }
                switch (ast.type) {
                    case AST.Literal:
                        return this.value(ast.value, context);
                    case AST.UnaryExpression:
                        right = this.recurse(ast.argument);
                        return this["unary" + ast.operator](right, context);
                    case AST.BinaryExpression:
                        left = this.recurse(ast.left);
                        right = this.recurse(ast.right);
                        return this["binary" + ast.operator](left, right, context);
                    case AST.LogicalExpression:
                        left = this.recurse(ast.left);
                        right = this.recurse(ast.right);
                        return this["binary" + ast.operator](left, right, context);
                    case AST.ConditionalExpression:
                        return this["ternary?:"](this.recurse(ast.test), this.recurse(ast.alternate), this.recurse(ast.consequent), context);
                    case AST.Identifier:
                        return self.identifier(ast.name, context, create);
                    case AST.MemberExpression:
                        left = this.recurse(ast.object, false, !!create);
                        if (!ast.computed) {
                            right = ast.property.name;
                        }
                        if (ast.computed) right = this.recurse(ast.property);
                        return ast.computed ? this.computedMember(left, right, context, create) : this.nonComputedMember(left, right, context, create);
                    case AST.CallExpression:
                        args = [];
                        forEach(ast.arguments, function (expr) {
                            args.push(self.recurse(expr));
                        });
                        if (ast.filter) right = this.$filter(ast.callee.name);
                        if (!ast.filter) right = this.recurse(ast.callee, true);
                        return ast.filter
                            ? function (scope, locals, assign, inputs) {
                                var values = [];
                                for (var i = 0; i < args.length; ++i) {
                                    values.push(args[i](scope, locals, assign, inputs));
                                }
                                var value = right.apply(undefined, values, inputs);
                                return context ? { context: undefined, name: undefined, value: value } : value;
                            }
                            : function (scope, locals, assign, inputs) {
                                var rhs = right(scope, locals, assign, inputs);
                                var value;
                                if (rhs.value != null) {
                                    var values = [];
                                    for (var i = 0; i < args.length; ++i) {
                                        values.push(args[i](scope, locals, assign, inputs));
                                    }
                                    value = rhs.value.apply(rhs.context, values);
                                }
                                return context ? { value: value } : value;
                            };
                    case AST.AssignmentExpression:
                        left = this.recurse(ast.left, true, 1);
                        right = this.recurse(ast.right);
                        return function (scope, locals, assign, inputs) {
                            var lhs = left(scope, locals, assign, inputs);
                            var rhs = right(scope, locals, assign, inputs);
                            lhs.context[lhs.name] = rhs;
                            return context ? { value: rhs } : rhs;
                        };
                    case AST.ArrayExpression:
                        args = [];
                        forEach(ast.elements, function (expr) {
                            args.push(self.recurse(expr));
                        });
                        return function (scope, locals, assign, inputs) {
                            var value = [];
                            for (var i = 0; i < args.length; ++i) {
                                value.push(args[i](scope, locals, assign, inputs));
                            }
                            return context ? { value: value } : value;
                        };
                    case AST.ObjectExpression:
                        args = [];
                        forEach(ast.properties, function (property) {
                            if (property.computed) {
                                args.push({ key: self.recurse(property.key), computed: true, value: self.recurse(property.value) });
                            } else {
                                args.push({ key: property.key.type === AST.Identifier ? property.key.name : "" + property.key.value, computed: false, value: self.recurse(property.value) });
                            }
                        });
                        return function (scope, locals, assign, inputs) {
                            var value = {};
                            for (var i = 0; i < args.length; ++i) {
                                if (args[i].computed) {
                                    value[args[i].key(scope, locals, assign, inputs)] = args[i].value(scope, locals, assign, inputs);
                                } else {
                                    value[args[i].key] = args[i].value(scope, locals, assign, inputs);
                                }
                            }
                            return context ? { value: value } : value;
                        };
                    case AST.ThisExpression:
                        return function (scope) {
                            return context ? { value: scope } : scope;
                        };
                    case AST.LocalsExpression:
                        return function (scope, locals) {
                            return context ? { value: locals } : locals;
                        };
                    case AST.NGValueParameter:
                        return function (scope, locals, assign) {
                            return context ? { value: assign } : assign;
                        };
                }
            },
            "unary+": function (argument, context) {
                return function (scope, locals, assign, inputs) {
                    var arg = argument(scope, locals, assign, inputs);
                    if (isDefined(arg)) {
                        arg = +arg;
                    } else {
                        arg = 0;
                    }
                    return context ? { value: arg } : arg;
                };
            },
            "unary-": function (argument, context) {
                return function (scope, locals, assign, inputs) {
                    var arg = argument(scope, locals, assign, inputs);
                    if (isDefined(arg)) {
                        arg = -arg;
                    } else {
                        arg = -0;
                    }
                    return context ? { value: arg } : arg;
                };
            },
            "unary!": function (argument, context) {
                return function (scope, locals, assign, inputs) {
                    var arg = !argument(scope, locals, assign, inputs);
                    return context ? { value: arg } : arg;
                };
            },
            "binary+": function (left, right, context) {
                return function (scope, locals, assign, inputs) {
                    var lhs = left(scope, locals, assign, inputs);
                    var rhs = right(scope, locals, assign, inputs);
                    var arg = plusFn(lhs, rhs);
                    return context ? { value: arg } : arg;
                };
            },
            "binary-": function (left, right, context) {
                return function (scope, locals, assign, inputs) {
                    var lhs = left(scope, locals, assign, inputs);
                    var rhs = right(scope, locals, assign, inputs);
                    var arg = (isDefined(lhs) ? lhs : 0) - (isDefined(rhs) ? rhs : 0);
                    return context ? { value: arg } : arg;
                };
            },
            "binary*": function (left, right, context) {
                return function (scope, locals, assign, inputs) {
                    var arg = left(scope, locals, assign, inputs) * right(scope, locals, assign, inputs);
                    return context ? { value: arg } : arg;
                };
            },
            "binary/": function (left, right, context) {
                return function (scope, locals, assign, inputs) {
                    var arg = left(scope, locals, assign, inputs) / right(scope, locals, assign, inputs);
                    return context ? { value: arg } : arg;
                };
            },
            "binary%": function (left, right, context) {
                return function (scope, locals, assign, inputs) {
                    var arg = left(scope, locals, assign, inputs) % right(scope, locals, assign, inputs);
                    return context ? { value: arg } : arg;
                };
            },
            "binary===": function (left, right, context) {
                return function (scope, locals, assign, inputs) {
                    var arg = left(scope, locals, assign, inputs) === right(scope, locals, assign, inputs);
                    return context ? { value: arg } : arg;
                };
            },
            "binary!==": function (left, right, context) {
                return function (scope, locals, assign, inputs) {
                    var arg = left(scope, locals, assign, inputs) !== right(scope, locals, assign, inputs);
                    return context ? { value: arg } : arg;
                };
            },
            "binary==": function (left, right, context) {
                return function (scope, locals, assign, inputs) {
                    var arg = left(scope, locals, assign, inputs) == right(scope, locals, assign, inputs);
                    return context ? { value: arg } : arg;
                };
            },
            "binary!=": function (left, right, context) {
                return function (scope, locals, assign, inputs) {
                    var arg = left(scope, locals, assign, inputs) != right(scope, locals, assign, inputs);
                    return context ? { value: arg } : arg;
                };
            },
            "binary<": function (left, right, context) {
                return function (scope, locals, assign, inputs) {
                    var arg = left(scope, locals, assign, inputs) < right(scope, locals, assign, inputs);
                    return context ? { value: arg } : arg;
                };
            },
            "binary>": function (left, right, context) {
                return function (scope, locals, assign, inputs) {
                    var arg = left(scope, locals, assign, inputs) > right(scope, locals, assign, inputs);
                    return context ? { value: arg } : arg;
                };
            },
            "binary<=": function (left, right, context) {
                return function (scope, locals, assign, inputs) {
                    var arg = left(scope, locals, assign, inputs) <= right(scope, locals, assign, inputs);
                    return context ? { value: arg } : arg;
                };
            },
            "binary>=": function (left, right, context) {
                return function (scope, locals, assign, inputs) {
                    var arg = left(scope, locals, assign, inputs) >= right(scope, locals, assign, inputs);
                    return context ? { value: arg } : arg;
                };
            },
            "binary&&": function (left, right, context) {
                return function (scope, locals, assign, inputs) {
                    var arg = left(scope, locals, assign, inputs) && right(scope, locals, assign, inputs);
                    return context ? { value: arg } : arg;
                };
            },
            "binary||": function (left, right, context) {
                return function (scope, locals, assign, inputs) {
                    var arg = left(scope, locals, assign, inputs) || right(scope, locals, assign, inputs);
                    return context ? { value: arg } : arg;
                };
            },
            "ternary?:": function (test, alternate, consequent, context) {
                return function (scope, locals, assign, inputs) {
                    var arg = test(scope, locals, assign, inputs) ? alternate(scope, locals, assign, inputs) : consequent(scope, locals, assign, inputs);
                    return context ? { value: arg } : arg;
                };
            },
            value: function (value, context) {
                return function () {
                    return context ? { context: undefined, name: undefined, value: value } : value;
                };
            },
            identifier: function (name, context, create) {
                return function (scope, locals, assign, inputs) {
                    var base = locals && name in locals ? locals : scope;
                    if (create && create !== 1 && base && base[name] == null) {
                        base[name] = {};
                    }
                    var value = base ? base[name] : undefined;
                    if (context) {
                        return { context: base, name: name, value: value };
                    } else {
                        return value;
                    }
                };
            },
            computedMember: function (left, right, context, create) {
                return function (scope, locals, assign, inputs) {
                    var lhs = left(scope, locals, assign, inputs);
                    var rhs;
                    var value;
                    if (lhs != null) {
                        rhs = right(scope, locals, assign, inputs);
                        rhs = getStringValue(rhs);
                        if (create && create !== 1) {
                            if (lhs && !lhs[rhs]) {
                                lhs[rhs] = {};
                            }
                        }
                        value = lhs[rhs];
                    }
                    if (context) {
                        return { context: lhs, name: rhs, value: value };
                    } else {
                        return value;
                    }
                };
            },
            nonComputedMember: function (left, right, context, create) {
                return function (scope, locals, assign, inputs) {
                    var lhs = left(scope, locals, assign, inputs);
                    if (create && create !== 1) {
                        if (lhs && lhs[right] == null) {
                            lhs[right] = {};
                        }
                    }
                    var value = lhs != null ? lhs[right] : undefined;
                    if (context) {
                        return { context: lhs, name: right, value: value };
                    } else {
                        return value;
                    }
                };
            },
            inputs: function (input, watchId) {
                return function (scope, value, locals, inputs) {
                    if (inputs) return inputs[watchId];
                    return input(scope, value, locals);
                };
            },
        };
        function Parser(lexer, $filter, options) {
            this.ast = new AST(lexer, options);
            this.astCompiler = options.csp ? new ASTInterpreter($filter) : new ASTCompiler($filter);
        }
        Parser.prototype = {
            constructor: Parser,
            parse: function (text) {
                var ast = this.ast.ast(text);
                var fn = this.astCompiler.compile(ast);
                fn.literal = isLiteral(ast);
                fn.constant = isConstant(ast);
                return fn;
            },
        };
        function getValueOf(value) {
            return isFunction(value.valueOf) ? value.valueOf() : objectValueOf.call(value);
        }
        function $ParseProvider() {
            var cache = createMap();
            var literals = { true: true, false: false, null: null, undefined: undefined };
            var identStart, identContinue;
            this.addLiteral = function (literalName, literalValue) {
                literals[literalName] = literalValue;
            };
            this.setIdentifierFns = function (identifierStart, identifierContinue) {
                identStart = identifierStart;
                identContinue = identifierContinue;
                return this;
            };
            this.$get = [
                "$filter",
                function ($filter) {
                    var noUnsafeEval = csp().noUnsafeEval;
                    var $parseOptions = { csp: noUnsafeEval, literals: copy(literals), isIdentifierStart: isFunction(identStart) && identStart, isIdentifierContinue: isFunction(identContinue) && identContinue };
                    return $parse;
                    function $parse(exp, interceptorFn) {
                        var parsedExpression, oneTime, cacheKey;
                        switch (typeof exp) {
                            case "string":
                                exp = exp.trim();
                                cacheKey = exp;
                                parsedExpression = cache[cacheKey];
                                if (!parsedExpression) {
                                    if (exp.charAt(0) === ":" && exp.charAt(1) === ":") {
                                        oneTime = true;
                                        exp = exp.substring(2);
                                    }
                                    var lexer = new Lexer($parseOptions);
                                    var parser = new Parser(lexer, $filter, $parseOptions);
                                    parsedExpression = parser.parse(exp);
                                    if (parsedExpression.constant) {
                                        parsedExpression.$$watchDelegate = constantWatchDelegate;
                                    } else if (oneTime) {
                                        parsedExpression.oneTime = true;
                                        parsedExpression.$$watchDelegate = oneTimeWatchDelegate;
                                    } else if (parsedExpression.inputs) {
                                        parsedExpression.$$watchDelegate = inputsWatchDelegate;
                                    }
                                    cache[cacheKey] = parsedExpression;
                                }
                                return addInterceptor(parsedExpression, interceptorFn);
                            case "function":
                                return addInterceptor(exp, interceptorFn);
                            default:
                                return addInterceptor(noop, interceptorFn);
                        }
                    }
                    function expressionInputDirtyCheck(newValue, oldValueOfValue, compareObjectIdentity) {
                        if (newValue == null || oldValueOfValue == null) {
                            return newValue === oldValueOfValue;
                        }
                        if (typeof newValue === "object") {
                            newValue = getValueOf(newValue);
                            if (typeof newValue === "object" && !compareObjectIdentity) {
                                return false;
                            }
                        }
                        return newValue === oldValueOfValue || (newValue !== newValue && oldValueOfValue !== oldValueOfValue);
                    }
                    function inputsWatchDelegate(scope, listener, objectEquality, parsedExpression, prettyPrintExpression) {
                        var inputExpressions = parsedExpression.inputs;
                        var lastResult;
                        if (inputExpressions.length === 1) {
                            var oldInputValueOf = expressionInputDirtyCheck;
                            inputExpressions = inputExpressions[0];
                            return scope.$watch(
                                function expressionInputWatch(scope) {
                                    var newInputValue = inputExpressions(scope);
                                    if (!expressionInputDirtyCheck(newInputValue, oldInputValueOf, parsedExpression.literal)) {
                                        lastResult = parsedExpression(scope, undefined, undefined, [newInputValue]);
                                        oldInputValueOf = newInputValue && getValueOf(newInputValue);
                                    }
                                    return lastResult;
                                },
                                listener,
                                objectEquality,
                                prettyPrintExpression
                            );
                        }
                        var oldInputValueOfValues = [];
                        var oldInputValues = [];
                        for (var i = 0, ii = inputExpressions.length; i < ii; i++) {
                            oldInputValueOfValues[i] = expressionInputDirtyCheck;
                            oldInputValues[i] = null;
                        }
                        return scope.$watch(
                            function expressionInputsWatch(scope) {
                                var changed = false;
                                for (var i = 0, ii = inputExpressions.length; i < ii; i++) {
                                    var newInputValue = inputExpressions[i](scope);
                                    if (changed || (changed = !expressionInputDirtyCheck(newInputValue, oldInputValueOfValues[i], parsedExpression.literal))) {
                                        oldInputValues[i] = newInputValue;
                                        oldInputValueOfValues[i] = newInputValue && getValueOf(newInputValue);
                                    }
                                }
                                if (changed) {
                                    lastResult = parsedExpression(scope, undefined, undefined, oldInputValues);
                                }
                                return lastResult;
                            },
                            listener,
                            objectEquality,
                            prettyPrintExpression
                        );
                    }
                    function oneTimeWatchDelegate(scope, listener, objectEquality, parsedExpression, prettyPrintExpression) {
                        var isDone = parsedExpression.literal ? isAllDefined : isDefined;
                        var unwatch, lastValue;
                        if (parsedExpression.inputs) {
                            unwatch = inputsWatchDelegate(scope, oneTimeListener, objectEquality, parsedExpression, prettyPrintExpression);
                        } else {
                            unwatch = scope.$watch(oneTimeWatch, oneTimeListener, objectEquality);
                        }
                        return unwatch;
                        function oneTimeWatch(scope) {
                            return parsedExpression(scope);
                        }
                        function oneTimeListener(value, old, scope) {
                            lastValue = value;
                            if (isFunction(listener)) {
                                listener(value, old, scope);
                            }
                            if (isDone(value)) {
                                scope.$$postDigest(function () {
                                    if (isDone(lastValue)) {
                                        unwatch();
                                    }
                                });
                            }
                        }
                    }
                    function isAllDefined(value) {
                        var allDefined = true;
                        forEach(value, function (val) {
                            if (!isDefined(val)) allDefined = false;
                        });
                        return allDefined;
                    }
                    function constantWatchDelegate(scope, listener, objectEquality, parsedExpression) {
                        var unwatch = scope.$watch(
                            function constantWatch(scope) {
                                unwatch();
                                return parsedExpression(scope);
                            },
                            listener,
                            objectEquality
                        );
                        return unwatch;
                    }
                    function addInterceptor(parsedExpression, interceptorFn) {
                        if (!interceptorFn) return parsedExpression;
                        var watchDelegate = parsedExpression.$$watchDelegate;
                        var useInputs = false;
                        var isDone = parsedExpression.literal ? isAllDefined : isDefined;
                        function regularInterceptedExpression(scope, locals, assign, inputs) {
                            var value = useInputs && inputs ? inputs[0] : parsedExpression(scope, locals, assign, inputs);
                            return interceptorFn(value, scope, locals);
                        }
                        function oneTimeInterceptedExpression(scope, locals, assign, inputs) {
                            var value = useInputs && inputs ? inputs[0] : parsedExpression(scope, locals, assign, inputs);
                            var result = interceptorFn(value, scope, locals);
                            return isDone(value) ? result : value;
                        }
                        var fn = parsedExpression.oneTime ? oneTimeInterceptedExpression : regularInterceptedExpression;
                        fn.literal = parsedExpression.literal;
                        fn.oneTime = parsedExpression.oneTime;
                        useInputs = !parsedExpression.inputs;
                        if (watchDelegate && watchDelegate !== inputsWatchDelegate) {
                            fn.$$watchDelegate = watchDelegate;
                            fn.inputs = parsedExpression.inputs;
                        } else if (!interceptorFn.$stateful) {
                            fn.$$watchDelegate = inputsWatchDelegate;
                            fn.inputs = parsedExpression.inputs ? parsedExpression.inputs : [parsedExpression];
                        }
                        return fn;
                    }
                },
            ];
        }
        function $QProvider() {
            var errorOnUnhandledRejections = true;
            this.$get = [
                "$rootScope",
                "$exceptionHandler",
                function ($rootScope, $exceptionHandler) {
                    return qFactory(
                        function (callback) {
                            $rootScope.$evalAsync(callback);
                        },
                        $exceptionHandler,
                        errorOnUnhandledRejections
                    );
                },
            ];
            this.errorOnUnhandledRejections = function (value) {
                if (isDefined(value)) {
                    errorOnUnhandledRejections = value;
                    return this;
                } else {
                    return errorOnUnhandledRejections;
                }
            };
        }
        function $$QProvider() {
            var errorOnUnhandledRejections = true;
            this.$get = [
                "$browser",
                "$exceptionHandler",
                function ($browser, $exceptionHandler) {
                    return qFactory(
                        function (callback) {
                            $browser.defer(callback);
                        },
                        $exceptionHandler,
                        errorOnUnhandledRejections
                    );
                },
            ];
            this.errorOnUnhandledRejections = function (value) {
                if (isDefined(value)) {
                    errorOnUnhandledRejections = value;
                    return this;
                } else {
                    return errorOnUnhandledRejections;
                }
            };
        }
        function qFactory(nextTick, exceptionHandler, errorOnUnhandledRejections) {
            var $qMinErr = minErr("$q", TypeError);
            var queueSize = 0;
            var checkQueue = [];
            function defer() {
                return new Deferred();
            }
            function Deferred() {
                var promise = (this.promise = new Promise());
                this.resolve = function (val) {
                    resolvePromise(promise, val);
                };
                this.reject = function (reason) {
                    rejectPromise(promise, reason);
                };
                this.notify = function (progress) {
                    notifyPromise(promise, progress);
                };
            }
            function Promise() {
                this.$$state = { status: 0 };
            }
            extend(Promise.prototype, {
                then: function (onFulfilled, onRejected, progressBack) {
                    if (isUndefined(onFulfilled) && isUndefined(onRejected) && isUndefined(progressBack)) {
                        return this;
                    }
                    var result = new Promise();
                    this.$$state.pending = this.$$state.pending || [];
                    this.$$state.pending.push([result, onFulfilled, onRejected, progressBack]);
                    if (this.$$state.status > 0) scheduleProcessQueue(this.$$state);
                    return result;
                },
                catch: function (callback) {
                    return this.then(null, callback);
                },
                finally: function (callback, progressBack) {
                    return this.then(
                        function (value) {
                            return handleCallback(value, resolve, callback);
                        },
                        function (error) {
                            return handleCallback(error, reject, callback);
                        },
                        progressBack
                    );
                },
            });
            function processQueue(state) {
                var fn, promise, pending;
                pending = state.pending;
                state.processScheduled = false;
                state.pending = undefined;
                try {
                    for (var i = 0, ii = pending.length; i < ii; ++i) {
                        state.pur = true;
                        promise = pending[i][0];
                        fn = pending[i][state.status];
                        try {
                            if (isFunction(fn)) {
                                resolvePromise(promise, fn(state.value));
                            } else if (state.status === 1) {
                                resolvePromise(promise, state.value);
                            } else {
                                rejectPromise(promise, state.value);
                            }
                        } catch (e) {
                            rejectPromise(promise, e);
                        }
                    }
                } finally {
                    --queueSize;
                    if (errorOnUnhandledRejections && queueSize === 0) {
                        nextTick(processChecks);
                    }
                }
            }
            function processChecks() {
                while (!queueSize && checkQueue.length) {
                    var toCheck = checkQueue.shift();
                    if (!toCheck.pur) {
                        toCheck.pur = true;
                        var errorMessage = "Possibly unhandled rejection: " + toDebugString(toCheck.value);
                        if (toCheck.value instanceof Error) {
                            exceptionHandler(toCheck.value, errorMessage);
                        } else {
                            exceptionHandler(errorMessage);
                        }
                    }
                }
            }
            function scheduleProcessQueue(state) {
                if (errorOnUnhandledRejections && !state.pending && state.status === 2 && !state.pur) {
                    if (queueSize === 0 && checkQueue.length === 0) {
                        nextTick(processChecks);
                    }
                    checkQueue.push(state);
                }
                if (state.processScheduled || !state.pending) return;
                state.processScheduled = true;
                ++queueSize;
                nextTick(function () {
                    processQueue(state);
                });
            }
            function resolvePromise(promise, val) {
                if (promise.$$state.status) return;
                if (val === promise) {
                    $$reject(promise, $qMinErr("qcycle", "Expected promise to be resolved with value other than itself '{0}'", val));
                } else {
                    $$resolve(promise, val);
                }
            }
            function $$resolve(promise, val) {
                var then;
                var done = false;
                try {
                    if (isObject(val) || isFunction(val)) then = val.then;
                    if (isFunction(then)) {
                        promise.$$state.status = -1;
                        then.call(val, doResolve, doReject, doNotify);
                    } else {
                        promise.$$state.value = val;
                        promise.$$state.status = 1;
                        scheduleProcessQueue(promise.$$state);
                    }
                } catch (e) {
                    doReject(e);
                }
                function doResolve(val) {
                    if (done) return;
                    done = true;
                    $$resolve(promise, val);
                }
                function doReject(val) {
                    if (done) return;
                    done = true;
                    $$reject(promise, val);
                }
                function doNotify(progress) {
                    notifyPromise(promise, progress);
                }
            }
            function rejectPromise(promise, reason) {
                if (promise.$$state.status) return;
                $$reject(promise, reason);
            }
            function $$reject(promise, reason) {
                promise.$$state.value = reason;
                promise.$$state.status = 2;
                scheduleProcessQueue(promise.$$state);
            }
            function notifyPromise(promise, progress) {
                var callbacks = promise.$$state.pending;
                if (promise.$$state.status <= 0 && callbacks && callbacks.length) {
                    nextTick(function () {
                        var callback, result;
                        for (var i = 0, ii = callbacks.length; i < ii; i++) {
                            result = callbacks[i][0];
                            callback = callbacks[i][3];
                            try {
                                notifyPromise(result, isFunction(callback) ? callback(progress) : progress);
                            } catch (e) {
                                exceptionHandler(e);
                            }
                        }
                    });
                }
            }
            function reject(reason) {
                var result = new Promise();
                rejectPromise(result, reason);
                return result;
            }
            function handleCallback(value, resolver, callback) {
                var callbackOutput = null;
                try {
                    if (isFunction(callback)) callbackOutput = callback();
                } catch (e) {
                    return reject(e);
                }
                if (isPromiseLike(callbackOutput)) {
                    return callbackOutput.then(function () {
                        return resolver(value);
                    }, reject);
                } else {
                    return resolver(value);
                }
            }
            function when(value, callback, errback, progressBack) {
                var result = new Promise();
                resolvePromise(result, value);
                return result.then(callback, errback, progressBack);
            }
            var resolve = when;
            function all(promises) {
                var result = new Promise(),
                    counter = 0,
                    results = isArray(promises) ? [] : {};
                forEach(promises, function (promise, key) {
                    counter++;
                    when(promise).then(
                        function (value) {
                            results[key] = value;
                            if (!--counter) resolvePromise(result, results);
                        },
                        function (reason) {
                            rejectPromise(result, reason);
                        }
                    );
                });
                if (counter === 0) {
                    resolvePromise(result, results);
                }
                return result;
            }
            function race(promises) {
                var deferred = defer();
                forEach(promises, function (promise) {
                    when(promise).then(deferred.resolve, deferred.reject);
                });
                return deferred.promise;
            }
            function $Q(resolver) {
                if (!isFunction(resolver)) {
                    throw $qMinErr("norslvr", "Expected resolverFn, got '{0}'", resolver);
                }
                var promise = new Promise();
                function resolveFn(value) {
                    resolvePromise(promise, value);
                }
                function rejectFn(reason) {
                    rejectPromise(promise, reason);
                }
                resolver(resolveFn, rejectFn);
                return promise;
            }
            $Q.prototype = Promise.prototype;
            $Q.defer = defer;
            $Q.reject = reject;
            $Q.when = when;
            $Q.resolve = resolve;
            $Q.all = all;
            $Q.race = race;
            return $Q;
        }
        function $$RAFProvider() {
            this.$get = [
                "$window",
                "$timeout",
                function ($window, $timeout) {
                    var requestAnimationFrame = $window.requestAnimationFrame || $window.webkitRequestAnimationFrame;
                    var cancelAnimationFrame = $window.cancelAnimationFrame || $window.webkitCancelAnimationFrame || $window.webkitCancelRequestAnimationFrame;
                    var rafSupported = !!requestAnimationFrame;
                    var raf = rafSupported
                        ? function (fn) {
                            var id = requestAnimationFrame(fn);
                            return function () {
                                cancelAnimationFrame(id);
                            };
                        }
                        : function (fn) {
                            var timer = $timeout(fn, 16.66, false);
                            return function () {
                                $timeout.cancel(timer);
                            };
                        };
                    raf.supported = rafSupported;
                    return raf;
                },
            ];
        }
        function $RootScopeProvider() {
            var TTL = 10;
            var $rootScopeMinErr = minErr("$rootScope");
            var lastDirtyWatch = null;
            var applyAsyncId = null;
            this.digestTtl = function (value) {
                if (arguments.length) {
                    TTL = value;
                }
                return TTL;
            };
            function createChildScopeClass(parent) {
                function ChildScope() {
                    this.$$watchers = this.$$nextSibling = this.$$childHead = this.$$childTail = null;
                    this.$$listeners = {};
                    this.$$listenerCount = {};
                    this.$$watchersCount = 0;
                    this.$id = nextUid();
                    this.$$ChildScope = null;
                }
                ChildScope.prototype = parent;
                return ChildScope;
            }
            this.$get = [
                "$exceptionHandler",
                "$parse",
                "$browser",
                function ($exceptionHandler, $parse, $browser) {
                    function destroyChildScope($event) {
                        $event.currentScope.$$destroyed = true;
                    }
                    function cleanUpScope($scope) {
                        if (msie === 9) {
                            if ($scope.$$childHead) {
                                cleanUpScope($scope.$$childHead);
                            }
                            if ($scope.$$nextSibling) {
                                cleanUpScope($scope.$$nextSibling);
                            }
                        }
                        $scope.$parent = $scope.$$nextSibling = $scope.$$prevSibling = $scope.$$childHead = $scope.$$childTail = $scope.$root = $scope.$$watchers = null;
                    }
                    function Scope() {
                        this.$id = nextUid();
                        this.$$phase = this.$parent = this.$$watchers = this.$$nextSibling = this.$$prevSibling = this.$$childHead = this.$$childTail = null;
                        this.$root = this;
                        this.$$destroyed = false;
                        this.$$listeners = {};
                        this.$$listenerCount = {};
                        this.$$watchersCount = 0;
                        this.$$isolateBindings = null;
                    }
                    Scope.prototype = {
                        constructor: Scope,
                        $new: function (isolate, parent) {
                            var child;
                            parent = parent || this;
                            if (isolate) {
                                child = new Scope();
                                child.$root = this.$root;
                            } else {
                                if (!this.$$ChildScope) {
                                    this.$$ChildScope = createChildScopeClass(this);
                                }
                                child = new this.$$ChildScope();
                            }
                            child.$parent = parent;
                            child.$$prevSibling = parent.$$childTail;
                            if (parent.$$childHead) {
                                parent.$$childTail.$$nextSibling = child;
                                parent.$$childTail = child;
                            } else {
                                parent.$$childHead = parent.$$childTail = child;
                            }
                            if (isolate || parent !== this) child.$on("$destroy", destroyChildScope);
                            return child;
                        },
                        $watch: function (watchExp, listener, objectEquality, prettyPrintExpression) {
                            var get = $parse(watchExp);
                            if (get.$$watchDelegate) {
                                return get.$$watchDelegate(this, listener, objectEquality, get, watchExp);
                            }
                            var scope = this,
                                array = scope.$$watchers,
                                watcher = { fn: listener, last: initWatchVal, get: get, exp: prettyPrintExpression || watchExp, eq: !!objectEquality };
                            lastDirtyWatch = null;
                            if (!isFunction(listener)) {
                                watcher.fn = noop;
                            }
                            if (!array) {
                                array = scope.$$watchers = [];
                                array.$$digestWatchIndex = -1;
                            }
                            array.unshift(watcher);
                            array.$$digestWatchIndex++;
                            incrementWatchersCount(this, 1);
                            return function deregisterWatch() {
                                var index = arrayRemove(array, watcher);
                                if (index >= 0) {
                                    incrementWatchersCount(scope, -1);
                                    if (index < array.$$digestWatchIndex) {
                                        array.$$digestWatchIndex--;
                                    }
                                }
                                lastDirtyWatch = null;
                            };
                        },
                        $watchGroup: function (watchExpressions, listener) {
                            var oldValues = new Array(watchExpressions.length);
                            var newValues = new Array(watchExpressions.length);
                            var deregisterFns = [];
                            var self = this;
                            var changeReactionScheduled = false;
                            var firstRun = true;
                            if (!watchExpressions.length) {
                                var shouldCall = true;
                                self.$evalAsync(function () {
                                    if (shouldCall) listener(newValues, newValues, self);
                                });
                                return function deregisterWatchGroup() {
                                    shouldCall = false;
                                };
                            }
                            if (watchExpressions.length === 1) {
                                return this.$watch(watchExpressions[0], function watchGroupAction(value, oldValue, scope) {
                                    newValues[0] = value;
                                    oldValues[0] = oldValue;
                                    listener(newValues, value === oldValue ? newValues : oldValues, scope);
                                });
                            }
                            forEach(watchExpressions, function (expr, i) {
                                var unwatchFn = self.$watch(expr, function watchGroupSubAction(value, oldValue) {
                                    newValues[i] = value;
                                    oldValues[i] = oldValue;
                                    if (!changeReactionScheduled) {
                                        changeReactionScheduled = true;
                                        self.$evalAsync(watchGroupAction);
                                    }
                                });
                                deregisterFns.push(unwatchFn);
                            });
                            function watchGroupAction() {
                                changeReactionScheduled = false;
                                if (firstRun) {
                                    firstRun = false;
                                    listener(newValues, newValues, self);
                                } else {
                                    listener(newValues, oldValues, self);
                                }
                            }
                            return function deregisterWatchGroup() {
                                while (deregisterFns.length) {
                                    deregisterFns.shift()();
                                }
                            };
                        },
                        $watchCollection: function (obj, listener) {
                            $watchCollectionInterceptor.$stateful = true;
                            var self = this;
                            var newValue;
                            var oldValue;
                            var veryOldValue;
                            var trackVeryOldValue = listener.length > 1;
                            var changeDetected = 0;
                            var changeDetector = $parse(obj, $watchCollectionInterceptor);
                            var internalArray = [];
                            var internalObject = {};
                            var initRun = true;
                            var oldLength = 0;
                            function $watchCollectionInterceptor(_value) {
                                newValue = _value;
                                var newLength, key, bothNaN, newItem, oldItem;
                                if (isUndefined(newValue)) return;
                                if (!isObject(newValue)) {
                                    if (oldValue !== newValue) {
                                        oldValue = newValue;
                                        changeDetected++;
                                    }
                                } else if (isArrayLike(newValue)) {
                                    if (oldValue !== internalArray) {
                                        oldValue = internalArray;
                                        oldLength = oldValue.length = 0;
                                        changeDetected++;
                                    }
                                    newLength = newValue.length;
                                    if (oldLength !== newLength) {
                                        changeDetected++;
                                        oldValue.length = oldLength = newLength;
                                    }
                                    for (var i = 0; i < newLength; i++) {
                                        oldItem = oldValue[i];
                                        newItem = newValue[i];
                                        bothNaN = oldItem !== oldItem && newItem !== newItem;
                                        if (!bothNaN && oldItem !== newItem) {
                                            changeDetected++;
                                            oldValue[i] = newItem;
                                        }
                                    }
                                } else {
                                    if (oldValue !== internalObject) {
                                        oldValue = internalObject = {};
                                        oldLength = 0;
                                        changeDetected++;
                                    }
                                    newLength = 0;
                                    for (key in newValue) {
                                        if (hasOwnProperty.call(newValue, key)) {
                                            newLength++;
                                            newItem = newValue[key];
                                            oldItem = oldValue[key];
                                            if (key in oldValue) {
                                                bothNaN = oldItem !== oldItem && newItem !== newItem;
                                                if (!bothNaN && oldItem !== newItem) {
                                                    changeDetected++;
                                                    oldValue[key] = newItem;
                                                }
                                            } else {
                                                oldLength++;
                                                oldValue[key] = newItem;
                                                changeDetected++;
                                            }
                                        }
                                    }
                                    if (oldLength > newLength) {
                                        changeDetected++;
                                        for (key in oldValue) {
                                            if (!hasOwnProperty.call(newValue, key)) {
                                                oldLength--;
                                                delete oldValue[key];
                                            }
                                        }
                                    }
                                }
                                return changeDetected;
                            }
                            function $watchCollectionAction() {
                                if (initRun) {
                                    initRun = false;
                                    listener(newValue, newValue, self);
                                } else {
                                    listener(newValue, veryOldValue, self);
                                }
                                if (trackVeryOldValue) {
                                    if (!isObject(newValue)) {
                                        veryOldValue = newValue;
                                    } else if (isArrayLike(newValue)) {
                                        veryOldValue = new Array(newValue.length);
                                        for (var i = 0; i < newValue.length; i++) {
                                            veryOldValue[i] = newValue[i];
                                        }
                                    } else {
                                        veryOldValue = {};
                                        for (var key in newValue) {
                                            if (hasOwnProperty.call(newValue, key)) {
                                                veryOldValue[key] = newValue[key];
                                            }
                                        }
                                    }
                                }
                            }
                            return this.$watch(changeDetector, $watchCollectionAction);
                        },
                        $digest: function () {
                            var watch,
                                value,
                                last,
                                fn,
                                get,
                                watchers,
                                dirty,
                                ttl = TTL,
                                next,
                                current,
                                target = this,
                                watchLog = [],
                                logIdx,
                                asyncTask;
                            beginPhase("$digest");
                            $browser.$$checkUrlChange();
                            if (this === $rootScope && applyAsyncId !== null) {
                                $browser.defer.cancel(applyAsyncId);
                                flushApplyAsync();
                            }
                            lastDirtyWatch = null;
                            do {
                                dirty = false;
                                current = target;
                                for (var asyncQueuePosition = 0; asyncQueuePosition < asyncQueue.length; asyncQueuePosition++) {
                                    try {
                                        asyncTask = asyncQueue[asyncQueuePosition];
                                        fn = asyncTask.fn;
                                        fn(asyncTask.scope, asyncTask.locals);
                                    } catch (e) {
                                        $exceptionHandler(e);
                                    }
                                    lastDirtyWatch = null;
                                }
                                asyncQueue.length = 0;
                                traverseScopesLoop: do {
                                    if ((watchers = current.$$watchers)) {
                                        watchers.$$digestWatchIndex = watchers.length;
                                        while (watchers.$$digestWatchIndex--) {
                                            try {
                                                watch = watchers[watchers.$$digestWatchIndex];
                                                if (watch) {
                                                    get = watch.get;
                                                    if ((value = get(current)) !== (last = watch.last) && !(watch.eq ? equals(value, last) : isNumberNaN(value) && isNumberNaN(last))) {
                                                        dirty = true;
                                                        lastDirtyWatch = watch;
                                                        watch.last = watch.eq ? copy(value, null) : value;
                                                        fn = watch.fn;
                                                        fn(value, last === initWatchVal ? value : last, current);
                                                        if (ttl < 5) {
                                                            logIdx = 4 - ttl;
                                                            if (!watchLog[logIdx]) watchLog[logIdx] = [];
                                                            watchLog[logIdx].push({ msg: isFunction(watch.exp) ? "fn: " + (watch.exp.name || watch.exp.toString()) : watch.exp, newVal: value, oldVal: last });
                                                        }
                                                    } else if (watch === lastDirtyWatch) {
                                                        dirty = false;
                                                        break traverseScopesLoop;
                                                    }
                                                }
                                            } catch (e) {
                                                $exceptionHandler(e);
                                            }
                                        }
                                    }
                                    if (!(next = (current.$$watchersCount && current.$$childHead) || (current !== target && current.$$nextSibling))) {
                                        while (current !== target && !(next = current.$$nextSibling)) {
                                            current = current.$parent;
                                        }
                                    }
                                } while ((current = next));
                                if ((dirty || asyncQueue.length) && !ttl--) {
                                    clearPhase();
                                    throw $rootScopeMinErr("infdig", "{0} $digest() iterations reached. Aborting!\n" + "Watchers fired in the last 5 iterations: {1}", TTL, watchLog);
                                }
                            } while (dirty || asyncQueue.length);
                            clearPhase();
                            while (postDigestQueuePosition < postDigestQueue.length) {
                                try {
                                    postDigestQueue[postDigestQueuePosition++]();
                                } catch (e) {
                                    $exceptionHandler(e);
                                }
                            }
                            postDigestQueue.length = postDigestQueuePosition = 0;
                            $browser.$$checkUrlChange();
                        },
                        $destroy: function () {
                            if (this.$$destroyed) return;
                            var parent = this.$parent;
                            this.$broadcast("$destroy");
                            this.$$destroyed = true;
                            if (this === $rootScope) {
                                $browser.$$applicationDestroyed();
                            }
                            incrementWatchersCount(this, -this.$$watchersCount);
                            for (var eventName in this.$$listenerCount) {
                                decrementListenerCount(this, this.$$listenerCount[eventName], eventName);
                            }
                            if (parent && parent.$$childHead === this) parent.$$childHead = this.$$nextSibling;
                            if (parent && parent.$$childTail === this) parent.$$childTail = this.$$prevSibling;
                            if (this.$$prevSibling) this.$$prevSibling.$$nextSibling = this.$$nextSibling;
                            if (this.$$nextSibling) this.$$nextSibling.$$prevSibling = this.$$prevSibling;
                            this.$destroy = this.$digest = this.$apply = this.$evalAsync = this.$applyAsync = noop;
                            this.$on = this.$watch = this.$watchGroup = function () {
                                return noop;
                            };
                            this.$$listeners = {};
                            this.$$nextSibling = null;
                            cleanUpScope(this);
                        },
                        $eval: function (expr, locals) {
                            return $parse(expr)(this, locals);
                        },
                        $evalAsync: function (expr, locals) {
                            if (!$rootScope.$$phase && !asyncQueue.length) {
                                $browser.defer(function () {
                                    if (asyncQueue.length) {
                                        $rootScope.$digest();
                                    }
                                });
                            }
                            asyncQueue.push({ scope: this, fn: $parse(expr), locals: locals });
                        },
                        $$postDigest: function (fn) {
                            postDigestQueue.push(fn);
                        },
                        $apply: function (expr) {
                            try {
                                beginPhase("$apply");
                                try {
                                    return this.$eval(expr);
                                } finally {
                                    clearPhase();
                                }
                            } catch (e) {
                                $exceptionHandler(e);
                            } finally {
                                try {
                                    $rootScope.$digest();
                                } catch (e) {
                                    $exceptionHandler(e);
                                    throw e;
                                }
                            }
                        },
                        $applyAsync: function (expr) {
                            var scope = this;
                            if (expr) {
                                applyAsyncQueue.push($applyAsyncExpression);
                            }
                            expr = $parse(expr);
                            scheduleApplyAsync();
                            function $applyAsyncExpression() {
                                scope.$eval(expr);
                            }
                        },
                        $on: function (name, listener) {
                            var namedListeners = this.$$listeners[name];
                            if (!namedListeners) {
                                this.$$listeners[name] = namedListeners = [];
                            }
                            namedListeners.push(listener);
                            var current = this;
                            do {
                                if (!current.$$listenerCount[name]) {
                                    current.$$listenerCount[name] = 0;
                                }
                                current.$$listenerCount[name]++;
                            } while ((current = current.$parent));
                            var self = this;
                            return function () {
                                var indexOfListener = namedListeners.indexOf(listener);
                                if (indexOfListener !== -1) {
                                    namedListeners[indexOfListener] = null;
                                    decrementListenerCount(self, 1, name);
                                }
                            };
                        },
                        $emit: function (name, args) {
                            var empty = [],
                                namedListeners,
                                scope = this,
                                stopPropagation = false,
                                event = {
                                    name: name,
                                    targetScope: scope,
                                    stopPropagation: function () {
                                        stopPropagation = true;
                                    },
                                    preventDefault: function () {
                                        event.defaultPrevented = true;
                                    },
                                    defaultPrevented: false,
                                },
                                listenerArgs = concat([event], arguments, 1),
                                i,
                                length;
                            do {
                                namedListeners = scope.$$listeners[name] || empty;
                                event.currentScope = scope;
                                for (i = 0, length = namedListeners.length; i < length; i++) {
                                    if (!namedListeners[i]) {
                                        namedListeners.splice(i, 1);
                                        i--;
                                        length--;
                                        continue;
                                    }
                                    try {
                                        namedListeners[i].apply(null, listenerArgs);
                                    } catch (e) {
                                        $exceptionHandler(e);
                                    }
                                }
                                if (stopPropagation) {
                                    event.currentScope = null;
                                    return event;
                                }
                                scope = scope.$parent;
                            } while (scope);
                            event.currentScope = null;
                            return event;
                        },
                        $broadcast: function (name, args) {
                            var target = this,
                                current = target,
                                next = target,
                                event = {
                                    name: name,
                                    targetScope: target,
                                    preventDefault: function () {
                                        event.defaultPrevented = true;
                                    },
                                    defaultPrevented: false,
                                };
                            if (!target.$$listenerCount[name]) return event;
                            var listenerArgs = concat([event], arguments, 1),
                                listeners,
                                i,
                                length;
                            while ((current = next)) {
                                event.currentScope = current;
                                listeners = current.$$listeners[name] || [];
                                for (i = 0, length = listeners.length; i < length; i++) {
                                    if (!listeners[i]) {
                                        listeners.splice(i, 1);
                                        i--;
                                        length--;
                                        continue;
                                    }
                                    try {
                                        listeners[i].apply(null, listenerArgs);
                                    } catch (e) {
                                        $exceptionHandler(e);
                                    }
                                }
                                if (!(next = (current.$$listenerCount[name] && current.$$childHead) || (current !== target && current.$$nextSibling))) {
                                    while (current !== target && !(next = current.$$nextSibling)) {
                                        current = current.$parent;
                                    }
                                }
                            }
                            event.currentScope = null;
                            return event;
                        },
                    };
                    var $rootScope = new Scope();
                    var asyncQueue = ($rootScope.$$asyncQueue = []);
                    var postDigestQueue = ($rootScope.$$postDigestQueue = []);
                    var applyAsyncQueue = ($rootScope.$$applyAsyncQueue = []);
                    var postDigestQueuePosition = 0;
                    return $rootScope;
                    function beginPhase(phase) {
                        if ($rootScope.$$phase) {
                            throw $rootScopeMinErr("inprog", "{0} already in progress", $rootScope.$$phase);
                        }
                        $rootScope.$$phase = phase;
                    }
                    function clearPhase() {
                        $rootScope.$$phase = null;
                    }
                    function incrementWatchersCount(current, count) {
                        do {
                            current.$$watchersCount += count;
                        } while ((current = current.$parent));
                    }
                    function decrementListenerCount(current, count, name) {
                        do {
                            current.$$listenerCount[name] -= count;
                            if (current.$$listenerCount[name] === 0) {
                                delete current.$$listenerCount[name];
                            }
                        } while ((current = current.$parent));
                    }
                    function initWatchVal() { }
                    function flushApplyAsync() {
                        while (applyAsyncQueue.length) {
                            try {
                                applyAsyncQueue.shift()();
                            } catch (e) {
                                $exceptionHandler(e);
                            }
                        }
                        applyAsyncId = null;
                    }
                    function scheduleApplyAsync() {
                        if (applyAsyncId === null) {
                            applyAsyncId = $browser.defer(function () {
                                $rootScope.$apply(flushApplyAsync);
                            });
                        }
                    }
                },
            ];
        }
        function $$SanitizeUriProvider() {
            var aHrefSanitizationWhitelist = /^\s*(https?|ftp|mailto|tel|file):/,
                imgSrcSanitizationWhitelist = /^\s*((https?|ftp|file|blob):|data:image\/)/;
            this.aHrefSanitizationWhitelist = function (regexp) {
                if (isDefined(regexp)) {
                    aHrefSanitizationWhitelist = regexp;
                    return this;
                }
                return aHrefSanitizationWhitelist;
            };
            this.imgSrcSanitizationWhitelist = function (regexp) {
                if (isDefined(regexp)) {
                    imgSrcSanitizationWhitelist = regexp;
                    return this;
                }
                return imgSrcSanitizationWhitelist;
            };
            this.$get = function () {
                return function sanitizeUri(uri, isImage) {
                    var regex = isImage ? imgSrcSanitizationWhitelist : aHrefSanitizationWhitelist;
                    var normalizedVal;
                    normalizedVal = urlResolve(uri).href;
                    if (normalizedVal !== "" && !normalizedVal.match(regex)) {
                        return "unsafe:" + normalizedVal;
                    }
                    return uri;
                };
            };
        }
        var $sceMinErr = minErr("$sce");
        var SCE_CONTEXTS = { HTML: "html", CSS: "css", URL: "url", RESOURCE_URL: "resourceUrl", JS: "js" };
        var UNDERSCORE_LOWERCASE_REGEXP = /_([a-z])/g;
        function snakeToCamel(name) {
            return name.replace(UNDERSCORE_LOWERCASE_REGEXP, fnCamelCaseReplace);
        }
        function adjustMatcher(matcher) {
            if (matcher === "self") {
                return matcher;
            } else if (isString(matcher)) {
                if (matcher.indexOf("***") > -1) {
                    throw $sceMinErr("iwcard", "Illegal sequence *** in string matcher.  String: {0}", matcher);
                }
                matcher = escapeForRegexp(matcher)
                    .replace(/\\\*\\\*/g, ".*")
                    .replace(/\\\*/g, "[^:/.?&;]*");
                return new RegExp("^" + matcher + "$");
            } else if (isRegExp(matcher)) {
                return new RegExp("^" + matcher.source + "$");
            } else {
                throw $sceMinErr("imatcher", 'Matchers may only be "self", string patterns or RegExp objects');
            }
        }
        function adjustMatchers(matchers) {
            var adjustedMatchers = [];
            if (isDefined(matchers)) {
                forEach(matchers, function (matcher) {
                    adjustedMatchers.push(adjustMatcher(matcher));
                });
            }
            return adjustedMatchers;
        }
        function $SceDelegateProvider() {
            this.SCE_CONTEXTS = SCE_CONTEXTS;
            var resourceUrlWhitelist = ["self"],
                resourceUrlBlacklist = [];
            this.resourceUrlWhitelist = function (value) {
                if (arguments.length) {
                    resourceUrlWhitelist = adjustMatchers(value);
                }
                return resourceUrlWhitelist;
            };
            this.resourceUrlBlacklist = function (value) {
                if (arguments.length) {
                    resourceUrlBlacklist = adjustMatchers(value);
                }
                return resourceUrlBlacklist;
            };
            this.$get = [
                "$injector",
                function ($injector) {
                    var htmlSanitizer = function htmlSanitizer(html) {
                        throw $sceMinErr("unsafe", "Attempting to use an unsafe value in a safe context.");
                    };
                    if ($injector.has("$sanitize")) {
                        htmlSanitizer = $injector.get("$sanitize");
                    }
                    function matchUrl(matcher, parsedUrl) {
                        if (matcher === "self") {
                            return urlIsSameOrigin(parsedUrl);
                        } else {
                            return !!matcher.exec(parsedUrl.href);
                        }
                    }
                    function isResourceUrlAllowedByPolicy(url) {
                        var parsedUrl = urlResolve(url.toString());
                        var i,
                            n,
                            allowed = false;
                        for (i = 0, n = resourceUrlWhitelist.length; i < n; i++) {
                            if (matchUrl(resourceUrlWhitelist[i], parsedUrl)) {
                                allowed = true;
                                break;
                            }
                        }
                        if (allowed) {
                            for (i = 0, n = resourceUrlBlacklist.length; i < n; i++) {
                                if (matchUrl(resourceUrlBlacklist[i], parsedUrl)) {
                                    allowed = false;
                                    break;
                                }
                            }
                        }
                        return allowed;
                    }
                    function generateHolderType(Base) {
                        var holderType = function TrustedValueHolderType(trustedValue) {
                            this.$$unwrapTrustedValue = function () {
                                return trustedValue;
                            };
                        };
                        if (Base) {
                            holderType.prototype = new Base();
                        }
                        holderType.prototype.valueOf = function sceValueOf() {
                            return this.$$unwrapTrustedValue();
                        };
                        holderType.prototype.toString = function sceToString() {
                            return this.$$unwrapTrustedValue().toString();
                        };
                        return holderType;
                    }
                    var trustedValueHolderBase = generateHolderType(),
                        byType = {};
                    byType[SCE_CONTEXTS.HTML] = generateHolderType(trustedValueHolderBase);
                    byType[SCE_CONTEXTS.CSS] = generateHolderType(trustedValueHolderBase);
                    byType[SCE_CONTEXTS.URL] = generateHolderType(trustedValueHolderBase);
                    byType[SCE_CONTEXTS.JS] = generateHolderType(trustedValueHolderBase);
                    byType[SCE_CONTEXTS.RESOURCE_URL] = generateHolderType(byType[SCE_CONTEXTS.URL]);
                    function trustAs(type, trustedValue) {
                        var Constructor = byType.hasOwnProperty(type) ? byType[type] : null;
                        if (!Constructor) {
                            throw $sceMinErr("icontext", "Attempted to trust a value in invalid context. Context: {0}; Value: {1}", type, trustedValue);
                        }
                        if (trustedValue === null || isUndefined(trustedValue) || trustedValue === "") {
                            return trustedValue;
                        }
                        if (typeof trustedValue !== "string") {
                            throw $sceMinErr("itype", "Attempted to trust a non-string value in a content requiring a string: Context: {0}", type);
                        }
                        return new Constructor(trustedValue);
                    }
                    function valueOf(maybeTrusted) {
                        if (maybeTrusted instanceof trustedValueHolderBase) {
                            return maybeTrusted.$$unwrapTrustedValue();
                        } else {
                            return maybeTrusted;
                        }
                    }
                    function getTrusted(type, maybeTrusted) {
                        if (maybeTrusted === null || isUndefined(maybeTrusted) || maybeTrusted === "") {
                            return maybeTrusted;
                        }
                        var constructor = byType.hasOwnProperty(type) ? byType[type] : null;
                        if (constructor && maybeTrusted instanceof constructor) {
                            return maybeTrusted.$$unwrapTrustedValue();
                        }
                        if (type === SCE_CONTEXTS.RESOURCE_URL) {
                            if (isResourceUrlAllowedByPolicy(maybeTrusted)) {
                                return maybeTrusted;
                            } else {
                                throw $sceMinErr("insecurl", "Blocked loading resource from url not allowed by $sceDelegate policy.  URL: {0}", maybeTrusted.toString());
                            }
                        } else if (type === SCE_CONTEXTS.HTML) {
                            return htmlSanitizer(maybeTrusted);
                        }
                        throw $sceMinErr("unsafe", "Attempting to use an unsafe value in a safe context.");
                    }
                    return { trustAs: trustAs, getTrusted: getTrusted, valueOf: valueOf };
                },
            ];
        }
        function $SceProvider() {
            var enabled = true;
            this.enabled = function (value) {
                if (arguments.length) {
                    enabled = !!value;
                }
                return enabled;
            };
            this.$get = [
                "$parse",
                "$sceDelegate",
                function ($parse, $sceDelegate) {
                    if (enabled && msie < 8) {
                        throw $sceMinErr(
                            "iequirks",
                            "Strict Contextual Escaping does not support Internet Explorer version < 11 in quirks " +
                            "mode.  You can fix this by adding the text <!doctype html> to the top of your HTML " +
                            "document.  See http://docs.angularjs.org/api/ng.$sce for more information."
                        );
                    }
                    var sce = shallowCopy(SCE_CONTEXTS);
                    sce.isEnabled = function () {
                        return enabled;
                    };
                    sce.trustAs = $sceDelegate.trustAs;
                    sce.getTrusted = $sceDelegate.getTrusted;
                    sce.valueOf = $sceDelegate.valueOf;
                    if (!enabled) {
                        sce.trustAs = sce.getTrusted = function (type, value) {
                            return value;
                        };
                        sce.valueOf = identity;
                    }
                    sce.parseAs = function sceParseAs(type, expr) {
                        var parsed = $parse(expr);
                        if (parsed.literal && parsed.constant) {
                            return parsed;
                        } else {
                            return $parse(expr, function (value) {
                                return sce.getTrusted(type, value);
                            });
                        }
                    };
                    var parse = sce.parseAs,
                        getTrusted = sce.getTrusted,
                        trustAs = sce.trustAs;
                    forEach(SCE_CONTEXTS, function (enumValue, name) {
                        var lName = lowercase(name);
                        sce[snakeToCamel("parse_as_" + lName)] = function (expr) {
                            return parse(enumValue, expr);
                        };
                        sce[snakeToCamel("get_trusted_" + lName)] = function (value) {
                            return getTrusted(enumValue, value);
                        };
                        sce[snakeToCamel("trust_as_" + lName)] = function (value) {
                            return trustAs(enumValue, value);
                        };
                    });
                    return sce;
                },
            ];
        }
        function $SnifferProvider() {
            this.$get = [
                "$window",
                "$document",
                function ($window, $document) {
                    var eventSupport = {},
                        isNw = $window.nw && $window.nw.process,
                        isChromePackagedApp = !isNw && $window.chrome && (($window.chrome.app && $window.chrome.app.runtime) || (!$window.chrome.app && $window.chrome.runtime && $window.chrome.runtime.id)),
                        hasHistoryPushState = !isChromePackagedApp && $window.history && $window.history.pushState,
                        android = toInt((/android (\d+)/.exec(lowercase(($window.navigator || {}).userAgent)) || [])[1]),
                        boxee = /Boxee/i.test(($window.navigator || {}).userAgent),
                        document = $document[0] || {},
                        bodyStyle = document.body && document.body.style,
                        transitions = false,
                        animations = false;
                    if (bodyStyle) {
                        transitions = !!("transition" in bodyStyle || "webkitTransition" in bodyStyle);
                        animations = !!("animation" in bodyStyle || "webkitAnimation" in bodyStyle);
                    }
                    return {
                        history: !!(hasHistoryPushState && !(android < 4) && !boxee),
                        hasEvent: function (event) {
                            if (event === "input" && msie) return false;
                            if (isUndefined(eventSupport[event])) {
                                var divElm = document.createElement("div");
                                eventSupport[event] = "on" + event in divElm;
                            }
                            return eventSupport[event];
                        },
                        csp: csp(),
                        transitions: transitions,
                        animations: animations,
                        android: android,
                    };
                },
            ];
        }
        var $templateRequestMinErr = minErr("$compile");
        function $TemplateRequestProvider() {
            var httpOptions;
            this.httpOptions = function (val) {
                if (val) {
                    httpOptions = val;
                    return this;
                }
                return httpOptions;
            };
            this.$get = [
                "$exceptionHandler",
                "$templateCache",
                "$http",
                "$q",
                "$sce",
                function ($exceptionHandler, $templateCache, $http, $q, $sce) {
                    function handleRequestFn(tpl, ignoreRequestError) {
                        handleRequestFn.totalPendingRequests++;
                        if (!isString(tpl) || isUndefined($templateCache.get(tpl))) {
                            tpl = $sce.getTrustedResourceUrl(tpl);
                        }
                        var transformResponse = $http.defaults && $http.defaults.transformResponse;
                        if (isArray(transformResponse)) {
                            transformResponse = transformResponse.filter(function (transformer) {
                                return transformer !== defaultHttpResponseTransform;
                            });
                        } else if (transformResponse === defaultHttpResponseTransform) {
                            transformResponse = null;
                        }
                        return $http
                            .get(tpl, extend({ cache: $templateCache, transformResponse: transformResponse }, httpOptions))
                            .finally(function () {
                                handleRequestFn.totalPendingRequests--;
                            })
                            .then(function (response) {
                                $templateCache.put(tpl, response.data);
                                return response.data;
                            }, handleError);
                        function handleError(resp) {
                            if (!ignoreRequestError) {
                                resp = $templateRequestMinErr("tpload", "Failed to load template: {0} (HTTP status: {1} {2})", tpl, resp.status, resp.statusText);
                                $exceptionHandler(resp);
                            }
                            return $q.reject(resp);
                        }
                    }
                    handleRequestFn.totalPendingRequests = 0;
                    return handleRequestFn;
                },
            ];
        }
        function $$TestabilityProvider() {
            this.$get = [
                "$rootScope",
                "$browser",
                "$location",
                function ($rootScope, $browser, $location) {
                    var testability = {};
                    testability.findBindings = function (element, expression, opt_exactMatch) {
                        var bindings = element.getElementsByClassName("ng-binding");
                        var matches = [];
                        forEach(bindings, function (binding) {
                            var dataBinding = angular.element(binding).data("$binding");
                            if (dataBinding) {
                                forEach(dataBinding, function (bindingName) {
                                    if (opt_exactMatch) {
                                        var matcher = new RegExp("(^|\\s)" + escapeForRegexp(expression) + "(\\s|\\||$)");
                                        if (matcher.test(bindingName)) {
                                            matches.push(binding);
                                        }
                                    } else {
                                        if (bindingName.indexOf(expression) !== -1) {
                                            matches.push(binding);
                                        }
                                    }
                                });
                            }
                        });
                        return matches;
                    };
                    testability.findModels = function (element, expression, opt_exactMatch) {
                        var prefixes = ["ng-", "data-ng-", "ng\\:"];
                        for (var p = 0; p < prefixes.length; ++p) {
                            var attributeEquals = opt_exactMatch ? "=" : "*=";
                            var selector = "[" + prefixes[p] + "model" + attributeEquals + '"' + expression + '"]';
                            var elements = element.querySelectorAll(selector);
                            if (elements.length) {
                                return elements;
                            }
                        }
                    };
                    testability.getLocation = function () {
                        return $location.url();
                    };
                    testability.setLocation = function (url) {
                        if (url !== $location.url()) {
                            $location.url(url);
                            $rootScope.$digest();
                        }
                    };
                    testability.whenStable = function (callback) {
                        $browser.notifyWhenNoOutstandingRequests(callback);
                    };
                    return testability;
                },
            ];
        }
        function $TimeoutProvider() {
            this.$get = [
                "$rootScope",
                "$browser",
                "$q",
                "$$q",
                "$exceptionHandler",
                function ($rootScope, $browser, $q, $$q, $exceptionHandler) {
                    var deferreds = {};
                    function timeout(fn, delay, invokeApply) {
                        if (!isFunction(fn)) {
                            invokeApply = delay;
                            delay = fn;
                            fn = noop;
                        }
                        var args = sliceArgs(arguments, 3),
                            skipApply = isDefined(invokeApply) && !invokeApply,
                            deferred = (skipApply ? $$q : $q).defer(),
                            promise = deferred.promise,
                            timeoutId;
                        timeoutId = $browser.defer(function () {
                            try {
                                deferred.resolve(fn.apply(null, args));
                            } catch (e) {
                                deferred.reject(e);
                                $exceptionHandler(e);
                            } finally {
                                delete deferreds[promise.$$timeoutId];
                            }
                            if (!skipApply) $rootScope.$apply();
                        }, delay);
                        promise.$$timeoutId = timeoutId;
                        deferreds[timeoutId] = deferred;
                        return promise;
                    }
                    timeout.cancel = function (promise) {
                        if (promise && promise.$$timeoutId in deferreds) {
                            deferreds[promise.$$timeoutId].promise.catch(noop);
                            deferreds[promise.$$timeoutId].reject("canceled");
                            delete deferreds[promise.$$timeoutId];
                            return $browser.defer.cancel(promise.$$timeoutId);
                        }
                        return false;
                    };
                    return timeout;
                },
            ];
        }
        var urlParsingNode = window.document.createElement("a");
        var originUrl = urlResolve(window.location.href);
        function urlResolve(url) {
            var href = url;
            if (msie) {
                urlParsingNode.setAttribute("href", href);
                href = urlParsingNode.href;
            }
            urlParsingNode.setAttribute("href", href);
            return {
                href: urlParsingNode.href,
                protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
                host: urlParsingNode.host,
                search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
                hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
                hostname: urlParsingNode.hostname,
                port: urlParsingNode.port,
                pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname,
            };
        }
        function urlIsSameOrigin(requestUrl) {
            var parsed = isString(requestUrl) ? urlResolve(requestUrl) : requestUrl;
            return parsed.protocol === originUrl.protocol && parsed.host === originUrl.host;
        }
        function $WindowProvider() {
            this.$get = valueFn(window);
        }
        function $$CookieReader($document) {
            var rawDocument = $document[0] || {};
            var lastCookies = {};
            var lastCookieString = "";
            function safeGetCookie(rawDocument) {
                try {
                    return rawDocument.cookie || "";
                } catch (e) {
                    return "";
                }
            }
            function safeDecodeURIComponent(str) {
                try {
                    return decodeURIComponent(str);
                } catch (e) {
                    return str;
                }
            }
            return function () {
                var cookieArray, cookie, i, index, name;
                var currentCookieString = safeGetCookie(rawDocument);
                if (currentCookieString !== lastCookieString) {
                    lastCookieString = currentCookieString;
                    cookieArray = lastCookieString.split("; ");
                    lastCookies = {};
                    for (i = 0; i < cookieArray.length; i++) {
                        cookie = cookieArray[i];
                        index = cookie.indexOf("=");
                        if (index > 0) {
                            name = safeDecodeURIComponent(cookie.substring(0, index));
                            if (isUndefined(lastCookies[name])) {
                                lastCookies[name] = safeDecodeURIComponent(cookie.substring(index + 1));
                            }
                        }
                    }
                }
                return lastCookies;
            };
        }
        $$CookieReader.$inject = ["$document"];
        function $$CookieReaderProvider() {
            this.$get = $$CookieReader;
        }
        $FilterProvider.$inject = ["$provide"];
        function $FilterProvider($provide) {
            var suffix = "Filter";
            function register(name, factory) {
                if (isObject(name)) {
                    var filters = {};
                    forEach(name, function (filter, key) {
                        filters[key] = register(key, filter);
                    });
                    return filters;
                } else {
                    return $provide.factory(name + suffix, factory);
                }
            }
            this.register = register;
            this.$get = [
                "$injector",
                function ($injector) {
                    return function (name) {
                        return $injector.get(name + suffix);
                    };
                },
            ];
            register("currency", currencyFilter);
            register("date", dateFilter);
            register("filter", filterFilter);
            register("json", jsonFilter);
            register("limitTo", limitToFilter);
            register("lowercase", lowercaseFilter);
            register("number", numberFilter);
            register("orderBy", orderByFilter);
            register("uppercase", uppercaseFilter);
        }
        function filterFilter() {
            return function (array, expression, comparator, anyPropertyKey) {
                if (!isArrayLike(array)) {
                    if (array == null) {
                        return array;
                    } else {
                        throw minErr("filter")("notarray", "Expected array but received: {0}", array);
                    }
                }
                anyPropertyKey = anyPropertyKey || "$";
                var expressionType = getTypeForFilter(expression);
                var predicateFn;
                var matchAgainstAnyProp;
                switch (expressionType) {
                    case "function":
                        predicateFn = expression;
                        break;
                    case "boolean":
                    case "null":
                    case "number":
                    case "string":
                        matchAgainstAnyProp = true;
                    case "object":
                        predicateFn = createPredicateFn(expression, comparator, anyPropertyKey, matchAgainstAnyProp);
                        break;
                    default:
                        return array;
                }
                return Array.prototype.filter.call(array, predicateFn);
            };
        }
        function createPredicateFn(expression, comparator, anyPropertyKey, matchAgainstAnyProp) {
            var shouldMatchPrimitives = isObject(expression) && anyPropertyKey in expression;
            var predicateFn;
            if (comparator === true) {
                comparator = equals;
            } else if (!isFunction(comparator)) {
                comparator = function (actual, expected) {
                    if (isUndefined(actual)) {
                        return false;
                    }
                    if (actual === null || expected === null) {
                        return actual === expected;
                    }
                    if (isObject(expected) || (isObject(actual) && !hasCustomToString(actual))) {
                        return false;
                    }
                    actual = lowercase("" + actual);
                    expected = lowercase("" + expected);
                    return actual.indexOf(expected) !== -1;
                };
            }
            predicateFn = function (item) {
                if (shouldMatchPrimitives && !isObject(item)) {
                    return deepCompare(item, expression[anyPropertyKey], comparator, anyPropertyKey, false);
                }
                return deepCompare(item, expression, comparator, anyPropertyKey, matchAgainstAnyProp);
            };
            return predicateFn;
        }
        function deepCompare(actual, expected, comparator, anyPropertyKey, matchAgainstAnyProp, dontMatchWholeObject) {
            var actualType = getTypeForFilter(actual);
            var expectedType = getTypeForFilter(expected);
            if (expectedType === "string" && expected.charAt(0) === "!") {
                return !deepCompare(actual, expected.substring(1), comparator, anyPropertyKey, matchAgainstAnyProp);
            } else if (isArray(actual)) {
                return actual.some(function (item) {
                    return deepCompare(item, expected, comparator, anyPropertyKey, matchAgainstAnyProp);
                });
            }
            switch (actualType) {
                case "object":
                    var key;
                    if (matchAgainstAnyProp) {
                        for (key in actual) {
                            if (key.charAt && key.charAt(0) !== "$" && deepCompare(actual[key], expected, comparator, anyPropertyKey, true)) {
                                return true;
                            }
                        }
                        return dontMatchWholeObject ? false : deepCompare(actual, expected, comparator, anyPropertyKey, false);
                    } else if (expectedType === "object") {
                        for (key in expected) {
                            var expectedVal = expected[key];
                            if (isFunction(expectedVal) || isUndefined(expectedVal)) {
                                continue;
                            }
                            var matchAnyProperty = key === anyPropertyKey;
                            var actualVal = matchAnyProperty ? actual : actual[key];
                            if (!deepCompare(actualVal, expectedVal, comparator, anyPropertyKey, matchAnyProperty, matchAnyProperty)) {
                                return false;
                            }
                        }
                        return true;
                    } else {
                        return comparator(actual, expected);
                    }
                case "function":
                    return false;
                default:
                    return comparator(actual, expected);
            }
        }
        function getTypeForFilter(val) {
            return val === null ? "null" : typeof val;
        }
        var MAX_DIGITS = 22;
        var DECIMAL_SEP = ".";
        var ZERO_CHAR = "0";
        currencyFilter.$inject = ["$locale"];
        function currencyFilter($locale) {
            var formats = $locale.NUMBER_FORMATS;
            return function (amount, currencySymbol, fractionSize) {
                if (isUndefined(currencySymbol)) {
                    currencySymbol = formats.CURRENCY_SYM;
                }
                if (isUndefined(fractionSize)) {
                    fractionSize = formats.PATTERNS[1].maxFrac;
                }
                return amount == null ? amount : formatNumber(amount, formats.PATTERNS[1], formats.GROUP_SEP, formats.DECIMAL_SEP, fractionSize).replace(/\u00A4/g, currencySymbol);
            };
        }
        numberFilter.$inject = ["$locale"];
        function numberFilter($locale) {
            var formats = $locale.NUMBER_FORMATS;
            return function (number, fractionSize) {
                return number == null ? number : formatNumber(number, formats.PATTERNS[0], formats.GROUP_SEP, formats.DECIMAL_SEP, fractionSize);
            };
        }
        function parse(numStr) {
            var exponent = 0,
                digits,
                numberOfIntegerDigits;
            var i, j, zeros;
            if ((numberOfIntegerDigits = numStr.indexOf(DECIMAL_SEP)) > -1) {
                numStr = numStr.replace(DECIMAL_SEP, "");
            }
            if ((i = numStr.search(/e/i)) > 0) {
                if (numberOfIntegerDigits < 0) numberOfIntegerDigits = i;
                numberOfIntegerDigits += +numStr.slice(i + 1);
                numStr = numStr.substring(0, i);
            } else if (numberOfIntegerDigits < 0) {
                numberOfIntegerDigits = numStr.length;
            }
            for (i = 0; numStr.charAt(i) === ZERO_CHAR; i++) { }
            if (i === (zeros = numStr.length)) {
                digits = [0];
                numberOfIntegerDigits = 1;
            } else {
                zeros--;
                while (numStr.charAt(zeros) === ZERO_CHAR) zeros--;
                numberOfIntegerDigits -= i;
                digits = [];
                for (j = 0; i <= zeros; i++, j++) {
                    digits[j] = +numStr.charAt(i);
                }
            }
            if (numberOfIntegerDigits > MAX_DIGITS) {
                digits = digits.splice(0, MAX_DIGITS - 1);
                exponent = numberOfIntegerDigits - 1;
                numberOfIntegerDigits = 1;
            }
            return { d: digits, e: exponent, i: numberOfIntegerDigits };
        }
        function roundNumber(parsedNumber, fractionSize, minFrac, maxFrac) {
            var digits = parsedNumber.d;
            var fractionLen = digits.length - parsedNumber.i;
            fractionSize = isUndefined(fractionSize) ? Math.min(Math.max(minFrac, fractionLen), maxFrac) : +fractionSize;
            var roundAt = fractionSize + parsedNumber.i;
            var digit = digits[roundAt];
            if (roundAt > 0) {
                digits.splice(Math.max(parsedNumber.i, roundAt));
                for (var j = roundAt; j < digits.length; j++) {
                    digits[j] = 0;
                }
            } else {
                fractionLen = Math.max(0, fractionLen);
                parsedNumber.i = 1;
                digits.length = Math.max(1, (roundAt = fractionSize + 1));
                digits[0] = 0;
                for (var i = 1; i < roundAt; i++) digits[i] = 0;
            }
            if (digit >= 5) {
                if (roundAt - 1 < 0) {
                    for (var k = 0; k > roundAt; k--) {
                        digits.unshift(0);
                        parsedNumber.i++;
                    }
                    digits.unshift(1);
                    parsedNumber.i++;
                } else {
                    digits[roundAt - 1]++;
                }
            }
            for (; fractionLen < Math.max(0, fractionSize); fractionLen++) digits.push(0);
            var carry = digits.reduceRight(function (carry, d, i, digits) {
                d = d + carry;
                digits[i] = d % 10;
                return Math.floor(d / 10);
            }, 0);
            if (carry) {
                digits.unshift(carry);
                parsedNumber.i++;
            }
        }
        function formatNumber(number, pattern, groupSep, decimalSep, fractionSize) {
            if (!(isString(number) || isNumber(number)) || isNaN(number)) return "";
            var isInfinity = !isFinite(number);
            var isZero = false;
            var numStr = Math.abs(number) + "",
                formattedText = "",
                parsedNumber;
            if (isInfinity) {
                formattedText = "âˆž";
            } else {
                parsedNumber = parse(numStr);
                roundNumber(parsedNumber, fractionSize, pattern.minFrac, pattern.maxFrac);
                var digits = parsedNumber.d;
                var integerLen = parsedNumber.i;
                var exponent = parsedNumber.e;
                var decimals = [];
                isZero = digits.reduce(function (isZero, d) {
                    return isZero && !d;
                }, true);
                while (integerLen < 0) {
                    digits.unshift(0);
                    integerLen++;
                }
                if (integerLen > 0) {
                    decimals = digits.splice(integerLen, digits.length);
                } else {
                    decimals = digits;
                    digits = [0];
                }
                var groups = [];
                if (digits.length >= pattern.lgSize) {
                    groups.unshift(digits.splice(-pattern.lgSize, digits.length).join(""));
                }
                while (digits.length > pattern.gSize) {
                    groups.unshift(digits.splice(-pattern.gSize, digits.length).join(""));
                }
                if (digits.length) {
                    groups.unshift(digits.join(""));
                }
                formattedText = groups.join(groupSep);
                if (decimals.length) {
                    formattedText += decimalSep + decimals.join("");
                }
                if (exponent) {
                    formattedText += "e+" + exponent;
                }
            }
            if (number < 0 && !isZero) {
                return pattern.negPre + formattedText + pattern.negSuf;
            } else {
                return pattern.posPre + formattedText + pattern.posSuf;
            }
        }
        function padNumber(num, digits, trim, negWrap) {
            var neg = "";
            if (num < 0 || (negWrap && num <= 0)) {
                if (negWrap) {
                    num = -num + 1;
                } else {
                    num = -num;
                    neg = "-";
                }
            }
            num = "" + num;
            while (num.length < digits) num = ZERO_CHAR + num;
            if (trim) {
                num = num.substr(num.length - digits);
            }
            return neg + num;
        }
        function dateGetter(name, size, offset, trim, negWrap) {
            offset = offset || 0;
            return function (date) {
                var value = date["get" + name]();
                if (offset > 0 || value > -offset) {
                    value += offset;
                }
                if (value === 0 && offset === -12) value = 12;
                return padNumber(value, size, trim, negWrap);
            };
        }
        function dateStrGetter(name, shortForm, standAlone) {
            return function (date, formats) {
                var value = date["get" + name]();
                var propPrefix = (standAlone ? "STANDALONE" : "") + (shortForm ? "SHORT" : "");
                var get = uppercase(propPrefix + name);
                return formats[get][value];
            };
        }
        function timeZoneGetter(date, formats, offset) {
            var zone = -1 * offset;
            var paddedZone = zone >= 0 ? "+" : "";
            paddedZone += padNumber(Math[zone > 0 ? "floor" : "ceil"](zone / 60), 2) + padNumber(Math.abs(zone % 60), 2);
            return paddedZone;
        }
        function getFirstThursdayOfYear(year) {
            var dayOfWeekOnFirst = new Date(year, 0, 1).getDay();
            return new Date(year, 0, (dayOfWeekOnFirst <= 4 ? 5 : 12) - dayOfWeekOnFirst);
        }
        function getThursdayThisWeek(datetime) {
            return new Date(datetime.getFullYear(), datetime.getMonth(), datetime.getDate() + (4 - datetime.getDay()));
        }
        function weekGetter(size) {
            return function (date) {
                var firstThurs = getFirstThursdayOfYear(date.getFullYear()),
                    thisThurs = getThursdayThisWeek(date);
                var diff = +thisThurs - +firstThurs,
                    result = 1 + Math.round(diff / 6048e5);
                return padNumber(result, size);
            };
        }
        function ampmGetter(date, formats) {
            return date.getHours() < 12 ? formats.AMPMS[0] : formats.AMPMS[1];
        }
        function eraGetter(date, formats) {
            return date.getFullYear() <= 0 ? formats.ERAS[0] : formats.ERAS[1];
        }
        function longEraGetter(date, formats) {
            return date.getFullYear() <= 0 ? formats.ERANAMES[0] : formats.ERANAMES[1];
        }
        var DATE_FORMATS = {
            yyyy: dateGetter("FullYear", 4, 0, false, true),
            yy: dateGetter("FullYear", 2, 0, true, true),
            y: dateGetter("FullYear", 1, 0, false, true),
            MMMM: dateStrGetter("Month"),
            MMM: dateStrGetter("Month", true),
            MM: dateGetter("Month", 2, 1),
            M: dateGetter("Month", 1, 1),
            LLLL: dateStrGetter("Month", false, true),
            dd: dateGetter("Date", 2),
            d: dateGetter("Date", 1),
            HH: dateGetter("Hours", 2),
            H: dateGetter("Hours", 1),
            hh: dateGetter("Hours", 2, -12),
            h: dateGetter("Hours", 1, -12),
            mm: dateGetter("Minutes", 2),
            m: dateGetter("Minutes", 1),
            ss: dateGetter("Seconds", 2),
            s: dateGetter("Seconds", 1),
            sss: dateGetter("Milliseconds", 3),
            EEEE: dateStrGetter("Day"),
            EEE: dateStrGetter("Day", true),
            a: ampmGetter,
            Z: timeZoneGetter,
            ww: weekGetter(2),
            w: weekGetter(1),
            G: eraGetter,
            GG: eraGetter,
            GGG: eraGetter,
            GGGG: longEraGetter,
        };
        var DATE_FORMATS_SPLIT = /((?:[^yMLdHhmsaZEwG']+)|(?:'(?:[^']|'')*')|(?:E+|y+|M+|L+|d+|H+|h+|m+|s+|a|Z|G+|w+))([\s\S]*)/,
            NUMBER_STRING = /^-?\d+$/;
        dateFilter.$inject = ["$locale"];
        function dateFilter($locale) {
            var R_ISO8601_STR = /^(\d{4})-?(\d\d)-?(\d\d)(?:T(\d\d)(?::?(\d\d)(?::?(\d\d)(?:\.(\d+))?)?)?(Z|([+-])(\d\d):?(\d\d))?)?$/;
            function jsonStringToDate(string) {
                var match;
                if ((match = string.match(R_ISO8601_STR))) {
                    var date = new Date(0),
                        tzHour = 0,
                        tzMin = 0,
                        dateSetter = match[8] ? date.setUTCFullYear : date.setFullYear,
                        timeSetter = match[8] ? date.setUTCHours : date.setHours;
                    if (match[9]) {
                        tzHour = toInt(match[9] + match[10]);
                        tzMin = toInt(match[9] + match[11]);
                    }
                    dateSetter.call(date, toInt(match[1]), toInt(match[2]) - 1, toInt(match[3]));
                    var h = toInt(match[4] || 0) - tzHour;
                    var m = toInt(match[5] || 0) - tzMin;
                    var s = toInt(match[6] || 0);
                    var ms = Math.round(parseFloat("0." + (match[7] || 0)) * 1e3);
                    timeSetter.call(date, h, m, s, ms);
                    return date;
                }
                return string;
            }
            return function (date, format, timezone) {
                var text = "",
                    parts = [],
                    fn,
                    match;
                format = format || "mediumDate";
                format = $locale.DATETIME_FORMATS[format] || format;
                if (isString(date)) {
                    date = NUMBER_STRING.test(date) ? toInt(date) : jsonStringToDate(date);
                }
                if (isNumber(date)) {
                    date = new Date(date);
                }
                if (!isDate(date) || !isFinite(date.getTime())) {
                    return date;
                }
                while (format) {
                    match = DATE_FORMATS_SPLIT.exec(format);
                    if (match) {
                        parts = concat(parts, match, 1);
                        format = parts.pop();
                    } else {
                        parts.push(format);
                        format = null;
                    }
                }
                var dateTimezoneOffset = date.getTimezoneOffset();
                if (timezone) {
                    dateTimezoneOffset = timezoneToOffset(timezone, dateTimezoneOffset);
                    date = convertTimezoneToLocal(date, timezone, true);
                }
                forEach(parts, function (value) {
                    fn = DATE_FORMATS[value];
                    text += fn ? fn(date, $locale.DATETIME_FORMATS, dateTimezoneOffset) : value === "''" ? "'" : value.replace(/(^'|'$)/g, "").replace(/''/g, "'");
                });
                return text;
            };
        }
        function jsonFilter() {
            return function (object, spacing) {
                if (isUndefined(spacing)) {
                    spacing = 2;
                }
                return toJson(object, spacing);
            };
        }
        var lowercaseFilter = valueFn(lowercase);
        var uppercaseFilter = valueFn(uppercase);
        function limitToFilter() {
            return function (input, limit, begin) {
                if (Math.abs(Number(limit)) === Infinity) {
                    limit = Number(limit);
                } else {
                    limit = toInt(limit);
                }
                if (isNumberNaN(limit)) return input;
                if (isNumber(input)) input = input.toString();
                if (!isArrayLike(input)) return input;
                begin = !begin || isNaN(begin) ? 0 : toInt(begin);
                begin = begin < 0 ? Math.max(0, input.length + begin) : begin;
                if (limit >= 0) {
                    return sliceFn(input, begin, begin + limit);
                } else {
                    if (begin === 0) {
                        return sliceFn(input, limit, input.length);
                    } else {
                        return sliceFn(input, Math.max(0, begin + limit), begin);
                    }
                }
            };
        }
        function sliceFn(input, begin, end) {
            if (isString(input)) return input.slice(begin, end);
            return slice.call(input, begin, end);
        }
        orderByFilter.$inject = ["$parse"];
        function orderByFilter($parse) {
            return function (array, sortPredicate, reverseOrder, compareFn) {
                if (array == null) return array;
                if (!isArrayLike(array)) {
                    throw minErr("orderBy")("notarray", "Expected array but received: {0}", array);
                }
                if (!isArray(sortPredicate)) {
                    sortPredicate = [sortPredicate];
                }
                if (sortPredicate.length === 0) {
                    sortPredicate = ["+"];
                }
                var predicates = processPredicates(sortPredicate);
                var descending = reverseOrder ? -1 : 1;
                var compare = isFunction(compareFn) ? compareFn : defaultCompare;
                var compareValues = Array.prototype.map.call(array, getComparisonObject);
                compareValues.sort(doComparison);
                array = compareValues.map(function (item) {
                    return item.value;
                });
                return array;
                function getComparisonObject(value, index) {
                    return {
                        value: value,
                        tieBreaker: { value: index, type: "number", index: index },
                        predicateValues: predicates.map(function (predicate) {
                            return getPredicateValue(predicate.get(value), index);
                        }),
                    };
                }
                function doComparison(v1, v2) {
                    for (var i = 0, ii = predicates.length; i < ii; i++) {
                        var result = compare(v1.predicateValues[i], v2.predicateValues[i]);
                        if (result) {
                            return result * predicates[i].descending * descending;
                        }
                    }
                    return compare(v1.tieBreaker, v2.tieBreaker) * descending;
                }
            };
            function processPredicates(sortPredicates) {
                return sortPredicates.map(function (predicate) {
                    var descending = 1,
                        get = identity;
                    if (isFunction(predicate)) {
                        get = predicate;
                    } else if (isString(predicate)) {
                        if (predicate.charAt(0) === "+" || predicate.charAt(0) === "-") {
                            descending = predicate.charAt(0) === "-" ? -1 : 1;
                            predicate = predicate.substring(1);
                        }
                        if (predicate !== "") {
                            get = $parse(predicate);
                            if (get.constant) {
                                var key = get();
                                get = function (value) {
                                    return value[key];
                                };
                            }
                        }
                    }
                    return { get: get, descending: descending };
                });
            }
            function isPrimitive(value) {
                switch (typeof value) {
                    case "number":
                    case "boolean":
                    case "string":
                        return true;
                    default:
                        return false;
                }
            }
            function objectValue(value) {
                if (isFunction(value.valueOf)) {
                    value = value.valueOf();
                    if (isPrimitive(value)) return value;
                }
                if (hasCustomToString(value)) {
                    value = value.toString();
                    if (isPrimitive(value)) return value;
                }
                return value;
            }
            function getPredicateValue(value, index) {
                var type = typeof value;
                if (value === null) {
                    type = "string";
                    value = "null";
                } else if (type === "object") {
                    value = objectValue(value);
                }
                return { value: value, type: type, index: index };
            }
            function defaultCompare(v1, v2) {
                var result = 0;
                var type1 = v1.type;
                var type2 = v2.type;
                if (type1 === type2) {
                    var value1 = v1.value;
                    var value2 = v2.value;
                    if (type1 === "string") {
                        value1 = value1.toLowerCase();
                        value2 = value2.toLowerCase();
                    } else if (type1 === "object") {
                        if (isObject(value1)) value1 = v1.index;
                        if (isObject(value2)) value2 = v2.index;
                    }
                    if (value1 !== value2) {
                        result = value1 < value2 ? -1 : 1;
                    }
                } else {
                    result = type1 < type2 ? -1 : 1;
                }
                return result;
            }
        }
        function ngDirective(directive) {
            if (isFunction(directive)) {
                directive = { link: directive };
            }
            directive.restrict = directive.restrict || "AC";
            return valueFn(directive);
        }
        var htmlAnchorDirective = valueFn({
            restrict: "E",
            compile: function (element, attr) {
                if (!attr.href && !attr.xlinkHref) {
                    return function (scope, element) {
                        if (element[0].nodeName.toLowerCase() !== "a") return;
                        var href = toString.call(element.prop("href")) === "[object SVGAnimatedString]" ? "xlink:href" : "href";
                        element.on("click", function (event) {
                            if (!element.attr(href)) {
                                event.preventDefault();
                            }
                        });
                    };
                }
            },
        });
        var ngAttributeAliasDirectives = {};
        forEach(BOOLEAN_ATTR, function (propName, attrName) {
            if (propName === "multiple") return;
            function defaultLinkFn(scope, element, attr) {
                scope.$watch(attr[normalized], function ngBooleanAttrWatchAction(value) {
                    attr.$set(attrName, !!value);
                });
            }
            var normalized = directiveNormalize("ng-" + attrName);
            var linkFn = defaultLinkFn;
            if (propName === "checked") {
                linkFn = function (scope, element, attr) {
                    if (attr.ngModel !== attr[normalized]) {
                        defaultLinkFn(scope, element, attr);
                    }
                };
            }
            ngAttributeAliasDirectives[normalized] = function () {
                return { restrict: "A", priority: 100, link: linkFn };
            };
        });
        forEach(ALIASED_ATTR, function (htmlAttr, ngAttr) {
            ngAttributeAliasDirectives[ngAttr] = function () {
                return {
                    priority: 100,
                    link: function (scope, element, attr) {
                        if (ngAttr === "ngPattern" && attr.ngPattern.charAt(0) === "/") {
                            var match = attr.ngPattern.match(REGEX_STRING_REGEXP);
                            if (match) {
                                attr.$set("ngPattern", new RegExp(match[1], match[2]));
                                return;
                            }
                        }
                        scope.$watch(attr[ngAttr], function ngAttrAliasWatchAction(value) {
                            attr.$set(ngAttr, value);
                        });
                    },
                };
            };
        });
        forEach(["src", "srcset", "href"], function (attrName) {
            var normalized = directiveNormalize("ng-" + attrName);
            ngAttributeAliasDirectives[normalized] = function () {
                return {
                    priority: 99,
                    link: function (scope, element, attr) {
                        var propName = attrName,
                            name = attrName;
                        if (attrName === "href" && toString.call(element.prop("href")) === "[object SVGAnimatedString]") {
                            name = "xlinkHref";
                            attr.$attr[name] = "xlink:href";
                            propName = null;
                        }
                        attr.$observe(normalized, function (value) {
                            if (!value) {
                                if (attrName === "href") {
                                    attr.$set(name, null);
                                }
                                return;
                            }
                            attr.$set(name, value);
                            if (msie && propName) element.prop(propName, attr[name]);
                        });
                    },
                };
            };
        });
        var nullFormCtrl = { $addControl: noop, $$renameControl: nullFormRenameControl, $removeControl: noop, $setValidity: noop, $setDirty: noop, $setPristine: noop, $setSubmitted: noop },
            PENDING_CLASS = "ng-pending",
            SUBMITTED_CLASS = "ng-submitted";
        function nullFormRenameControl(control, name) {
            control.$name = name;
        }
        FormController.$inject = ["$element", "$attrs", "$scope", "$animate", "$interpolate"];
        function FormController($element, $attrs, $scope, $animate, $interpolate) {
            this.$$controls = [];
            this.$error = {};
            this.$$success = {};
            this.$pending = undefined;
            this.$name = $interpolate($attrs.name || $attrs.ngForm || "")($scope);
            this.$dirty = false;
            this.$pristine = true;
            this.$valid = true;
            this.$invalid = false;
            this.$submitted = false;
            this.$$parentForm = nullFormCtrl;
            this.$$element = $element;
            this.$$animate = $animate;
            setupValidity(this);
        }
        FormController.prototype = {
            $rollbackViewValue: function () {
                forEach(this.$$controls, function (control) {
                    control.$rollbackViewValue();
                });
            },
            $commitViewValue: function () {
                forEach(this.$$controls, function (control) {
                    control.$commitViewValue();
                });
            },
            $addControl: function (control) {
                assertNotHasOwnProperty(control.$name, "input");
                this.$$controls.push(control);
                if (control.$name) {
                    this[control.$name] = control;
                }
                control.$$parentForm = this;
            },
            $$renameControl: function (control, newName) {
                var oldName = control.$name;
                if (this[oldName] === control) {
                    delete this[oldName];
                }
                this[newName] = control;
                control.$name = newName;
            },
            $removeControl: function (control) {
                if (control.$name && this[control.$name] === control) {
                    delete this[control.$name];
                }
                forEach(
                    this.$pending,
                    function (value, name) {
                        this.$setValidity(name, null, control);
                    },
                    this
                );
                forEach(
                    this.$error,
                    function (value, name) {
                        this.$setValidity(name, null, control);
                    },
                    this
                );
                forEach(
                    this.$$success,
                    function (value, name) {
                        this.$setValidity(name, null, control);
                    },
                    this
                );
                arrayRemove(this.$$controls, control);
                control.$$parentForm = nullFormCtrl;
            },
            $setDirty: function () {
                this.$$animate.removeClass(this.$$element, PRISTINE_CLASS);
                this.$$animate.addClass(this.$$element, DIRTY_CLASS);
                this.$dirty = true;
                this.$pristine = false;
                this.$$parentForm.$setDirty();
            },
            $setPristine: function () {
                this.$$animate.setClass(this.$$element, PRISTINE_CLASS, DIRTY_CLASS + " " + SUBMITTED_CLASS);
                this.$dirty = false;
                this.$pristine = true;
                this.$submitted = false;
                forEach(this.$$controls, function (control) {
                    control.$setPristine();
                });
            },
            $setUntouched: function () {
                forEach(this.$$controls, function (control) {
                    control.$setUntouched();
                });
            },
            $setSubmitted: function () {
                this.$$animate.addClass(this.$$element, SUBMITTED_CLASS);
                this.$submitted = true;
                this.$$parentForm.$setSubmitted();
            },
        };
        addSetValidityMethod({
            clazz: FormController,
            set: function (object, property, controller) {
                var list = object[property];
                if (!list) {
                    object[property] = [controller];
                } else {
                    var index = list.indexOf(controller);
                    if (index === -1) {
                        list.push(controller);
                    }
                }
            },
            unset: function (object, property, controller) {
                var list = object[property];
                if (!list) {
                    return;
                }
                arrayRemove(list, controller);
                if (list.length === 0) {
                    delete object[property];
                }
            },
        });
        var formDirectiveFactory = function (isNgForm) {
            return [
                "$timeout",
                "$parse",
                function ($timeout, $parse) {
                    var formDirective = {
                        name: "form",
                        restrict: isNgForm ? "EAC" : "E",
                        require: ["form", "^^?form"],
                        controller: FormController,
                        compile: function ngFormCompile(formElement, attr) {
                            formElement.addClass(PRISTINE_CLASS).addClass(VALID_CLASS);
                            var nameAttr = attr.name ? "name" : isNgForm && attr.ngForm ? "ngForm" : false;
                            return {
                                pre: function ngFormPreLink(scope, formElement, attr, ctrls) {
                                    var controller = ctrls[0];
                                    if (!("action" in attr)) {
                                        var handleFormSubmission = function (event) {
                                            scope.$apply(function () {
                                                controller.$commitViewValue();
                                                controller.$setSubmitted();
                                            });
                                            event.preventDefault();
                                        };
                                        formElement[0].addEventListener("submit", handleFormSubmission);
                                        formElement.on("$destroy", function () {
                                            $timeout(
                                                function () {
                                                    formElement[0].removeEventListener("submit", handleFormSubmission);
                                                },
                                                0,
                                                false
                                            );
                                        });
                                    }
                                    var parentFormCtrl = ctrls[1] || controller.$$parentForm;
                                    parentFormCtrl.$addControl(controller);
                                    var setter = nameAttr ? getSetter(controller.$name) : noop;
                                    if (nameAttr) {
                                        setter(scope, controller);
                                        attr.$observe(nameAttr, function (newValue) {
                                            if (controller.$name === newValue) return;
                                            setter(scope, undefined);
                                            controller.$$parentForm.$$renameControl(controller, newValue);
                                            setter = getSetter(controller.$name);
                                            setter(scope, controller);
                                        });
                                    }
                                    formElement.on("$destroy", function () {
                                        controller.$$parentForm.$removeControl(controller);
                                        setter(scope, undefined);
                                        extend(controller, nullFormCtrl);
                                    });
                                },
                            };
                        },
                    };
                    return formDirective;
                    function getSetter(expression) {
                        if (expression === "") {
                            return $parse('this[""]').assign;
                        }
                        return $parse(expression).assign || noop;
                    }
                },
            ];
        };
        var formDirective = formDirectiveFactory();
        var ngFormDirective = formDirectiveFactory(true);
        function setupValidity(instance) {
            instance.$$classCache = {};
            instance.$$classCache[INVALID_CLASS] = !(instance.$$classCache[VALID_CLASS] = instance.$$element.hasClass(VALID_CLASS));
        }
        function addSetValidityMethod(context) {
            var clazz = context.clazz,
                set = context.set,
                unset = context.unset;
            clazz.prototype.$setValidity = function (validationErrorKey, state, controller) {
                if (isUndefined(state)) {
                    createAndSet(this, "$pending", validationErrorKey, controller);
                } else {
                    unsetAndCleanup(this, "$pending", validationErrorKey, controller);
                }
                if (!isBoolean(state)) {
                    unset(this.$error, validationErrorKey, controller);
                    unset(this.$$success, validationErrorKey, controller);
                } else {
                    if (state) {
                        unset(this.$error, validationErrorKey, controller);
                        set(this.$$success, validationErrorKey, controller);
                    } else {
                        set(this.$error, validationErrorKey, controller);
                        unset(this.$$success, validationErrorKey, controller);
                    }
                }
                if (this.$pending) {
                    cachedToggleClass(this, PENDING_CLASS, true);
                    this.$valid = this.$invalid = undefined;
                    toggleValidationCss(this, "", null);
                } else {
                    cachedToggleClass(this, PENDING_CLASS, false);
                    this.$valid = isObjectEmpty(this.$error);
                    this.$invalid = !this.$valid;
                    toggleValidationCss(this, "", this.$valid);
                }
                var combinedState;
                if (this.$pending && this.$pending[validationErrorKey]) {
                    combinedState = undefined;
                } else if (this.$error[validationErrorKey]) {
                    combinedState = false;
                } else if (this.$$success[validationErrorKey]) {
                    combinedState = true;
                } else {
                    combinedState = null;
                }
                toggleValidationCss(this, validationErrorKey, combinedState);
                this.$$parentForm.$setValidity(validationErrorKey, combinedState, this);
            };
            function createAndSet(ctrl, name, value, controller) {
                if (!ctrl[name]) {
                    ctrl[name] = {};
                }
                set(ctrl[name], value, controller);
            }
            function unsetAndCleanup(ctrl, name, value, controller) {
                if (ctrl[name]) {
                    unset(ctrl[name], value, controller);
                }
                if (isObjectEmpty(ctrl[name])) {
                    ctrl[name] = undefined;
                }
            }
            function cachedToggleClass(ctrl, className, switchValue) {
                if (switchValue && !ctrl.$$classCache[className]) {
                    ctrl.$$animate.addClass(ctrl.$$element, className);
                    ctrl.$$classCache[className] = true;
                } else if (!switchValue && ctrl.$$classCache[className]) {
                    ctrl.$$animate.removeClass(ctrl.$$element, className);
                    ctrl.$$classCache[className] = false;
                }
            }
            function toggleValidationCss(ctrl, validationErrorKey, isValid) {
                validationErrorKey = validationErrorKey ? "-" + snake_case(validationErrorKey, "-") : "";
                cachedToggleClass(ctrl, VALID_CLASS + validationErrorKey, isValid === true);
                cachedToggleClass(ctrl, INVALID_CLASS + validationErrorKey, isValid === false);
            }
        }
        function isObjectEmpty(obj) {
            if (obj) {
                for (var prop in obj) {
                    if (obj.hasOwnProperty(prop)) {
                        return false;
                    }
                }
            }
            return true;
        }
        var ISO_DATE_REGEXP = /^\d{4,}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+(?:[+-][0-2]\d:[0-5]\d|Z)$/;
        var URL_REGEXP = /^[a-z][a-z\d.+-]*:\/*(?:[^:@]+(?::[^@]+)?@)?(?:[^\s:\/?#]+|\[[a-f\d:]+])(?::\d+)?(?:\/[^?#]*)?(?:\?[^#]*)?(?:#.*)?$/i;
        var EMAIL_REGEXP = /^(?=.{1,254}$)(?=.{1,64}@)[-!#$%&'*+\/0-9=?A-Z^_`a-z{|}~]+(\.[-!#$%&'*+\/0-9=?A-Z^_`a-z{|}~]+)*@[A-Za-z0-9]([A-Za-z0-9-]{0,61}[A-Za-z0-9])?(\.[A-Za-z0-9]([A-Za-z0-9-]{0,61}[A-Za-z0-9])?)*$/;
        var NUMBER_REGEXP = /^\s*(-|\+)?(\d+|(\d*(\.\d*)))([eE][+-]?\d+)?\s*$/;
        var DATE_REGEXP = /^(\d{4,})-(\d{2})-(\d{2})$/;
        var DATETIMELOCAL_REGEXP = /^(\d{4,})-(\d\d)-(\d\d)T(\d\d):(\d\d)(?::(\d\d)(\.\d{1,3})?)?$/;
        var WEEK_REGEXP = /^(\d{4,})-W(\d\d)$/;
        var MONTH_REGEXP = /^(\d{4,})-(\d\d)$/;
        var TIME_REGEXP = /^(\d\d):(\d\d)(?::(\d\d)(\.\d{1,3})?)?$/;
        var PARTIAL_VALIDATION_EVENTS = "keydown wheel mousedown";
        var PARTIAL_VALIDATION_TYPES = createMap();
        forEach("date,datetime-local,month,time,week".split(","), function (type) {
            PARTIAL_VALIDATION_TYPES[type] = true;
        });
        var inputType = {
            text: textInputType,
            date: createDateInputType("date", DATE_REGEXP, createDateParser(DATE_REGEXP, ["yyyy", "MM", "dd"]), "yyyy-MM-dd"),
            "datetime-local": createDateInputType("datetimelocal", DATETIMELOCAL_REGEXP, createDateParser(DATETIMELOCAL_REGEXP, ["yyyy", "MM", "dd", "HH", "mm", "ss", "sss"]), "yyyy-MM-ddTHH:mm:ss.sss"),
            time: createDateInputType("time", TIME_REGEXP, createDateParser(TIME_REGEXP, ["HH", "mm", "ss", "sss"]), "HH:mm:ss.sss"),
            week: createDateInputType("week", WEEK_REGEXP, weekParser, "yyyy-Www"),
            month: createDateInputType("month", MONTH_REGEXP, createDateParser(MONTH_REGEXP, ["yyyy", "MM"]), "yyyy-MM"),
            number: numberInputType,
            url: urlInputType,
            email: emailInputType,
            radio: radioInputType,
            range: rangeInputType,
            checkbox: checkboxInputType,
            hidden: noop,
            button: noop,
            submit: noop,
            reset: noop,
            file: noop,
        };
        function stringBasedInputType(ctrl) {
            ctrl.$formatters.push(function (value) {
                return ctrl.$isEmpty(value) ? value : value.toString();
            });
        }
        function textInputType(scope, element, attr, ctrl, $sniffer, $browser) {
            baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
            stringBasedInputType(ctrl);
        }
        function baseInputType(scope, element, attr, ctrl, $sniffer, $browser) {
            var type = lowercase(element[0].type);
            if (!$sniffer.android) {
                var composing = false;
                element.on("compositionstart", function () {
                    composing = true;
                });
                element.on("compositionend", function () {
                    composing = false;
                    listener();
                });
            }
            var timeout;
            var listener = function (ev) {
                if (timeout) {
                    $browser.defer.cancel(timeout);
                    timeout = null;
                }
                if (composing) return;
                var value = element.val(),
                    event = ev && ev.type;
                if (type !== "password" && (!attr.ngTrim || attr.ngTrim !== "false")) {
                    value = trim(value);
                }
                if (ctrl.$viewValue !== value || (value === "" && ctrl.$$hasNativeValidators)) {
                    ctrl.$setViewValue(value, event);
                }
            };
            if ($sniffer.hasEvent("input")) {
                element.on("input", listener);
            } else {
                var deferListener = function (ev, input, origValue) {
                    if (!timeout) {
                        timeout = $browser.defer(function () {
                            timeout = null;
                            if (!input || input.value !== origValue) {
                                listener(ev);
                            }
                        });
                    }
                };
                element.on("keydown", function (event) {
                    var key = event.keyCode;
                    if (key === 91 || (15 < key && key < 19) || (37 <= key && key <= 40)) return;
                    deferListener(event, this, this.value);
                });
                if ($sniffer.hasEvent("paste")) {
                    element.on("paste cut", deferListener);
                }
            }
            element.on("change", listener);
            if (PARTIAL_VALIDATION_TYPES[type] && ctrl.$$hasNativeValidators && type === attr.type) {
                element.on(PARTIAL_VALIDATION_EVENTS, function (ev) {
                    if (!timeout) {
                        var validity = this[VALIDITY_STATE_PROPERTY];
                        var origBadInput = validity.badInput;
                        var origTypeMismatch = validity.typeMismatch;
                        timeout = $browser.defer(function () {
                            timeout = null;
                            if (validity.badInput !== origBadInput || validity.typeMismatch !== origTypeMismatch) {
                                listener(ev);
                            }
                        });
                    }
                });
            }
            ctrl.$render = function () {
                var value = ctrl.$isEmpty(ctrl.$viewValue) ? "" : ctrl.$viewValue;
                if (element.val() !== value) {
                    element.val(value);
                }
            };
        }
        function weekParser(isoWeek, existingDate) {
            if (isDate(isoWeek)) {
                return isoWeek;
            }
            if (isString(isoWeek)) {
                WEEK_REGEXP.lastIndex = 0;
                var parts = WEEK_REGEXP.exec(isoWeek);
                if (parts) {
                    var year = +parts[1],
                        week = +parts[2],
                        hours = 0,
                        minutes = 0,
                        seconds = 0,
                        milliseconds = 0,
                        firstThurs = getFirstThursdayOfYear(year),
                        addDays = (week - 1) * 7;
                    if (existingDate) {
                        hours = existingDate.getHours();
                        minutes = existingDate.getMinutes();
                        seconds = existingDate.getSeconds();
                        milliseconds = existingDate.getMilliseconds();
                    }
                    return new Date(year, 0, firstThurs.getDate() + addDays, hours, minutes, seconds, milliseconds);
                }
            }
            return NaN;
        }
        function createDateParser(regexp, mapping) {
            return function (iso, date) {
                var parts, map;
                if (isDate(iso)) {
                    return iso;
                }
                if (isString(iso)) {
                    if (iso.charAt(0) === '"' && iso.charAt(iso.length - 1) === '"') {
                        iso = iso.substring(1, iso.length - 1);
                    }
                    if (ISO_DATE_REGEXP.test(iso)) {
                        return new Date(iso);
                    }
                    regexp.lastIndex = 0;
                    parts = regexp.exec(iso);
                    if (parts) {
                        parts.shift();
                        if (date) {
                            map = { yyyy: date.getFullYear(), MM: date.getMonth() + 1, dd: date.getDate(), HH: date.getHours(), mm: date.getMinutes(), ss: date.getSeconds(), sss: date.getMilliseconds() / 1e3 };
                        } else {
                            map = { yyyy: 1970, MM: 1, dd: 1, HH: 0, mm: 0, ss: 0, sss: 0 };
                        }
                        forEach(parts, function (part, index) {
                            if (index < mapping.length) {
                                map[mapping[index]] = +part;
                            }
                        });
                        return new Date(map.yyyy, map.MM - 1, map.dd, map.HH, map.mm, map.ss || 0, map.sss * 1e3 || 0);
                    }
                }
                return NaN;
            };
        }
        function createDateInputType(type, regexp, parseDate, format) {
            return function dynamicDateInputType(scope, element, attr, ctrl, $sniffer, $browser, $filter) {
                badInputChecker(scope, element, attr, ctrl);
                baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
                var timezone = ctrl && ctrl.$options.getOption("timezone");
                var previousDate;
                ctrl.$$parserName = type;
                ctrl.$parsers.push(function (value) {
                    if (ctrl.$isEmpty(value)) return null;
                    if (regexp.test(value)) {
                        var parsedDate = parseDate(value, previousDate);
                        if (timezone) {
                            parsedDate = convertTimezoneToLocal(parsedDate, timezone);
                        }
                        return parsedDate;
                    }
                    return undefined;
                });
                ctrl.$formatters.push(function (value) {
                    if (value && !isDate(value)) {
                        throw ngModelMinErr("datefmt", "Expected `{0}` to be a date", value);
                    }
                    if (isValidDate(value)) {
                        previousDate = value;
                        if (previousDate && timezone) {
                            previousDate = convertTimezoneToLocal(previousDate, timezone, true);
                        }
                        return $filter("date")(value, format, timezone);
                    } else {
                        previousDate = null;
                        return "";
                    }
                });
                if (isDefined(attr.min) || attr.ngMin) {
                    var minVal;
                    ctrl.$validators.min = function (value) {
                        return !isValidDate(value) || isUndefined(minVal) || parseDate(value) >= minVal;
                    };
                    attr.$observe("min", function (val) {
                        minVal = parseObservedDateValue(val);
                        ctrl.$validate();
                    });
                }
                if (isDefined(attr.max) || attr.ngMax) {
                    var maxVal;
                    ctrl.$validators.max = function (value) {
                        return !isValidDate(value) || isUndefined(maxVal) || parseDate(value) <= maxVal;
                    };
                    attr.$observe("max", function (val) {
                        maxVal = parseObservedDateValue(val);
                        ctrl.$validate();
                    });
                }
                function isValidDate(value) {
                    return value && !(value.getTime && value.getTime() !== value.getTime());
                }
                function parseObservedDateValue(val) {
                    return isDefined(val) && !isDate(val) ? parseDate(val) || undefined : val;
                }
            };
        }
        function badInputChecker(scope, element, attr, ctrl) {
            var node = element[0];
            var nativeValidation = (ctrl.$$hasNativeValidators = isObject(node.validity));
            if (nativeValidation) {
                ctrl.$parsers.push(function (value) {
                    var validity = element.prop(VALIDITY_STATE_PROPERTY) || {};
                    return validity.badInput || validity.typeMismatch ? undefined : value;
                });
            }
        }
        function numberFormatterParser(ctrl) {
            ctrl.$$parserName = "number";
            ctrl.$parsers.push(function (value) {
                if (ctrl.$isEmpty(value)) return null;
                if (NUMBER_REGEXP.test(value)) return parseFloat(value);
                return undefined;
            });
            ctrl.$formatters.push(function (value) {
                if (!ctrl.$isEmpty(value)) {
                    if (!isNumber(value)) {
                        throw ngModelMinErr("numfmt", "Expected `{0}` to be a number", value);
                    }
                    value = value.toString();
                }
                return value;
            });
        }
        function parseNumberAttrVal(val) {
            if (isDefined(val) && !isNumber(val)) {
                val = parseFloat(val);
            }
            return !isNumberNaN(val) ? val : undefined;
        }
        function isNumberInteger(num) {
            return (num | 0) === num;
        }
        function countDecimals(num) {
            var numString = num.toString();
            var decimalSymbolIndex = numString.indexOf(".");
            if (decimalSymbolIndex === -1) {
                if (-1 < num && num < 1) {
                    var match = /e-(\d+)$/.exec(numString);
                    if (match) {
                        return Number(match[1]);
                    }
                }
                return 0;
            }
            return numString.length - decimalSymbolIndex - 1;
        }
        function isValidForStep(viewValue, stepBase, step) {
            var value = Number(viewValue);
            var isNonIntegerValue = !isNumberInteger(value);
            var isNonIntegerStepBase = !isNumberInteger(stepBase);
            var isNonIntegerStep = !isNumberInteger(step);
            if (isNonIntegerValue || isNonIntegerStepBase || isNonIntegerStep) {
                var valueDecimals = isNonIntegerValue ? countDecimals(value) : 0;
                var stepBaseDecimals = isNonIntegerStepBase ? countDecimals(stepBase) : 0;
                var stepDecimals = isNonIntegerStep ? countDecimals(step) : 0;
                var decimalCount = Math.max(valueDecimals, stepBaseDecimals, stepDecimals);
                var multiplier = Math.pow(10, decimalCount);
                value = value * multiplier;
                stepBase = stepBase * multiplier;
                step = step * multiplier;
                if (isNonIntegerValue) value = Math.round(value);
                if (isNonIntegerStepBase) stepBase = Math.round(stepBase);
                if (isNonIntegerStep) step = Math.round(step);
            }
            return (value - stepBase) % step === 0;
        }
        function numberInputType(scope, element, attr, ctrl, $sniffer, $browser) {
            badInputChecker(scope, element, attr, ctrl);
            numberFormatterParser(ctrl);
            baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
            var minVal;
            var maxVal;
            if (isDefined(attr.min) || attr.ngMin) {
                ctrl.$validators.min = function (value) {
                    return ctrl.$isEmpty(value) || isUndefined(minVal) || value >= minVal;
                };
                attr.$observe("min", function (val) {
                    minVal = parseNumberAttrVal(val);
                    ctrl.$validate();
                });
            }
            if (isDefined(attr.max) || attr.ngMax) {
                ctrl.$validators.max = function (value) {
                    return ctrl.$isEmpty(value) || isUndefined(maxVal) || value <= maxVal;
                };
                attr.$observe("max", function (val) {
                    maxVal = parseNumberAttrVal(val);
                    ctrl.$validate();
                });
            }
            if (isDefined(attr.step) || attr.ngStep) {
                var stepVal;
                ctrl.$validators.step = function (modelValue, viewValue) {
                    return ctrl.$isEmpty(viewValue) || isUndefined(stepVal) || isValidForStep(viewValue, minVal || 0, stepVal);
                };
                attr.$observe("step", function (val) {
                    stepVal = parseNumberAttrVal(val);
                    ctrl.$validate();
                });
            }
        }
        function rangeInputType(scope, element, attr, ctrl, $sniffer, $browser) {
            badInputChecker(scope, element, attr, ctrl);
            numberFormatterParser(ctrl);
            baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
            var supportsRange = ctrl.$$hasNativeValidators && element[0].type === "range",
                minVal = supportsRange ? 0 : undefined,
                maxVal = supportsRange ? 100 : undefined,
                stepVal = supportsRange ? 1 : undefined,
                validity = element[0].validity,
                hasMinAttr = isDefined(attr.min),
                hasMaxAttr = isDefined(attr.max),
                hasStepAttr = isDefined(attr.step);
            var originalRender = ctrl.$render;
            ctrl.$render =
                supportsRange && isDefined(validity.rangeUnderflow) && isDefined(validity.rangeOverflow)
                    ? function rangeRender() {
                        originalRender();
                        ctrl.$setViewValue(element.val());
                    }
                    : originalRender;
            if (hasMinAttr) {
                ctrl.$validators.min = supportsRange
                    ? function noopMinValidator() {
                        return true;
                    }
                    : function minValidator(modelValue, viewValue) {
                        return ctrl.$isEmpty(viewValue) || isUndefined(minVal) || viewValue >= minVal;
                    };
                setInitialValueAndObserver("min", minChange);
            }
            if (hasMaxAttr) {
                ctrl.$validators.max = supportsRange
                    ? function noopMaxValidator() {
                        return true;
                    }
                    : function maxValidator(modelValue, viewValue) {
                        return ctrl.$isEmpty(viewValue) || isUndefined(maxVal) || viewValue <= maxVal;
                    };
                setInitialValueAndObserver("max", maxChange);
            }
            if (hasStepAttr) {
                ctrl.$validators.step = supportsRange
                    ? function nativeStepValidator() {
                        return !validity.stepMismatch;
                    }
                    : function stepValidator(modelValue, viewValue) {
                        return ctrl.$isEmpty(viewValue) || isUndefined(stepVal) || isValidForStep(viewValue, minVal || 0, stepVal);
                    };
                setInitialValueAndObserver("step", stepChange);
            }
            function setInitialValueAndObserver(htmlAttrName, changeFn) {
                element.attr(htmlAttrName, attr[htmlAttrName]);
                attr.$observe(htmlAttrName, changeFn);
            }
            function minChange(val) {
                minVal = parseNumberAttrVal(val);
                if (isNumberNaN(ctrl.$modelValue)) {
                    return;
                }
                if (supportsRange) {
                    var elVal = element.val();
                    if (minVal > elVal) {
                        elVal = minVal;
                        element.val(elVal);
                    }
                    ctrl.$setViewValue(elVal);
                } else {
                    ctrl.$validate();
                }
            }
            function maxChange(val) {
                maxVal = parseNumberAttrVal(val);
                if (isNumberNaN(ctrl.$modelValue)) {
                    return;
                }
                if (supportsRange) {
                    var elVal = element.val();
                    if (maxVal < elVal) {
                        element.val(maxVal);
                        elVal = maxVal < minVal ? minVal : maxVal;
                    }
                    ctrl.$setViewValue(elVal);
                } else {
                    ctrl.$validate();
                }
            }
            function stepChange(val) {
                stepVal = parseNumberAttrVal(val);
                if (isNumberNaN(ctrl.$modelValue)) {
                    return;
                }
                if (supportsRange && ctrl.$viewValue !== element.val()) {
                    ctrl.$setViewValue(element.val());
                } else {
                    ctrl.$validate();
                }
            }
        }
        function urlInputType(scope, element, attr, ctrl, $sniffer, $browser) {
            baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
            stringBasedInputType(ctrl);
            ctrl.$$parserName = "url";
            ctrl.$validators.url = function (modelValue, viewValue) {
                var value = modelValue || viewValue;
                return ctrl.$isEmpty(value) || URL_REGEXP.test(value);
            };
        }
        function emailInputType(scope, element, attr, ctrl, $sniffer, $browser) {
            baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
            stringBasedInputType(ctrl);
            ctrl.$$parserName = "email";
            ctrl.$validators.email = function (modelValue, viewValue) {
                var value = modelValue || viewValue;
                return ctrl.$isEmpty(value) || EMAIL_REGEXP.test(value);
            };
        }
        function radioInputType(scope, element, attr, ctrl) {
            var doTrim = !attr.ngTrim || trim(attr.ngTrim) !== "false";
            if (isUndefined(attr.name)) {
                element.attr("name", nextUid());
            }
            var listener = function (ev) {
                var value;
                if (element[0].checked) {
                    value = attr.value;
                    if (doTrim) {
                        value = trim(value);
                    }
                    ctrl.$setViewValue(value, ev && ev.type);
                }
            };
            element.on("click", listener);
            ctrl.$render = function () {
                var value = attr.value;
                if (doTrim) {
                    value = trim(value);
                }
                element[0].checked = value === ctrl.$viewValue;
            };
            attr.$observe("value", ctrl.$render);
        }
        function parseConstantExpr($parse, context, name, expression, fallback) {
            var parseFn;
            if (isDefined(expression)) {
                parseFn = $parse(expression);
                if (!parseFn.constant) {
                    throw ngModelMinErr("constexpr", "Expected constant expression for `{0}`, but saw " + "`{1}`.", name, expression);
                }
                return parseFn(context);
            }
            return fallback;
        }
        function checkboxInputType(scope, element, attr, ctrl, $sniffer, $browser, $filter, $parse) {
            var trueValue = parseConstantExpr($parse, scope, "ngTrueValue", attr.ngTrueValue, true);
            var falseValue = parseConstantExpr($parse, scope, "ngFalseValue", attr.ngFalseValue, false);
            var listener = function (ev) {
                ctrl.$setViewValue(element[0].checked, ev && ev.type);
            };
            element.on("click", listener);
            ctrl.$render = function () {
                element[0].checked = ctrl.$viewValue;
            };
            ctrl.$isEmpty = function (value) {
                return value === false;
            };
            ctrl.$formatters.push(function (value) {
                return equals(value, trueValue);
            });
            ctrl.$parsers.push(function (value) {
                return value ? trueValue : falseValue;
            });
        }
        var inputDirective = [
            "$browser",
            "$sniffer",
            "$filter",
            "$parse",
            function ($browser, $sniffer, $filter, $parse) {
                return {
                    restrict: "E",
                    require: ["?ngModel"],
                    link: {
                        pre: function (scope, element, attr, ctrls) {
                            if (ctrls[0]) {
                                (inputType[lowercase(attr.type)] || inputType.text)(scope, element, attr, ctrls[0], $sniffer, $browser, $filter, $parse);
                            }
                        },
                    },
                };
            },
        ];
        var CONSTANT_VALUE_REGEXP = /^(true|false|\d+)$/;
        var ngValueDirective = function () {
            function updateElementValue(element, attr, value) {
                var propValue = isDefined(value) ? value : msie === 9 ? "" : null;
                element.prop("value", propValue);
                attr.$set("value", value);
            }
            return {
                restrict: "A",
                priority: 100,
                compile: function (tpl, tplAttr) {
                    if (CONSTANT_VALUE_REGEXP.test(tplAttr.ngValue)) {
                        return function ngValueConstantLink(scope, elm, attr) {
                            var value = scope.$eval(attr.ngValue);
                            updateElementValue(elm, attr, value);
                        };
                    } else {
                        return function ngValueLink(scope, elm, attr) {
                            scope.$watch(attr.ngValue, function valueWatchAction(value) {
                                updateElementValue(elm, attr, value);
                            });
                        };
                    }
                },
            };
        };
        var ngBindDirective = [
            "$compile",
            function ($compile) {
                return {
                    restrict: "AC",
                    compile: function ngBindCompile(templateElement) {
                        $compile.$$addBindingClass(templateElement);
                        return function ngBindLink(scope, element, attr) {
                            $compile.$$addBindingInfo(element, attr.ngBind);
                            element = element[0];
                            scope.$watch(attr.ngBind, function ngBindWatchAction(value) {
                                element.textContent = stringify(value);
                            });
                        };
                    },
                };
            },
        ];
        var ngBindTemplateDirective = [
            "$interpolate",
            "$compile",
            function ($interpolate, $compile) {
                return {
                    compile: function ngBindTemplateCompile(templateElement) {
                        $compile.$$addBindingClass(templateElement);
                        return function ngBindTemplateLink(scope, element, attr) {
                            var interpolateFn = $interpolate(element.attr(attr.$attr.ngBindTemplate));
                            $compile.$$addBindingInfo(element, interpolateFn.expressions);
                            element = element[0];
                            attr.$observe("ngBindTemplate", function (value) {
                                element.textContent = isUndefined(value) ? "" : value;
                            });
                        };
                    },
                };
            },
        ];
        var ngBindHtmlDirective = [
            "$sce",
            "$parse",
            "$compile",
            function ($sce, $parse, $compile) {
                return {
                    restrict: "A",
                    compile: function ngBindHtmlCompile(tElement, tAttrs) {
                        var ngBindHtmlGetter = $parse(tAttrs.ngBindHtml);
                        var ngBindHtmlWatch = $parse(tAttrs.ngBindHtml, function sceValueOf(val) {
                            return $sce.valueOf(val);
                        });
                        $compile.$$addBindingClass(tElement);
                        return function ngBindHtmlLink(scope, element, attr) {
                            $compile.$$addBindingInfo(element, attr.ngBindHtml);
                            scope.$watch(ngBindHtmlWatch, function ngBindHtmlWatchAction() {
                                var value = ngBindHtmlGetter(scope);
                                element.html($sce.getTrustedHtml(value) || "");
                            });
                        };
                    },
                };
            },
        ];
        var ngChangeDirective = valueFn({
            restrict: "A",
            require: "ngModel",
            link: function (scope, element, attr, ctrl) {
                ctrl.$viewChangeListeners.push(function () {
                    scope.$eval(attr.ngChange);
                });
            },
        });
        function classDirective(name, selector) {
            name = "ngClass" + name;
            var indexWatchExpression;
            return [
                "$parse",
                function ($parse) {
                    return {
                        restrict: "AC",
                        link: function (scope, element, attr) {
                            var classCounts = element.data("$classCounts");
                            var oldModulo = true;
                            var oldClassString;
                            if (!classCounts) {
                                classCounts = createMap();
                                element.data("$classCounts", classCounts);
                            }
                            if (name !== "ngClass") {
                                if (!indexWatchExpression) {
                                    indexWatchExpression = $parse("$index", function moduloTwo($index) {
                                        return $index & 1;
                                    });
                                }
                                scope.$watch(indexWatchExpression, ngClassIndexWatchAction);
                            }
                            scope.$watch($parse(attr[name], toClassString), ngClassWatchAction);
                            function addClasses(classString) {
                                classString = digestClassCounts(split(classString), 1);
                                attr.$addClass(classString);
                            }
                            function removeClasses(classString) {
                                classString = digestClassCounts(split(classString), -1);
                                attr.$removeClass(classString);
                            }
                            function updateClasses(oldClassString, newClassString) {
                                var oldClassArray = split(oldClassString);
                                var newClassArray = split(newClassString);
                                var toRemoveArray = arrayDifference(oldClassArray, newClassArray);
                                var toAddArray = arrayDifference(newClassArray, oldClassArray);
                                var toRemoveString = digestClassCounts(toRemoveArray, -1);
                                var toAddString = digestClassCounts(toAddArray, 1);
                                attr.$addClass(toAddString);
                                attr.$removeClass(toRemoveString);
                            }
                            function digestClassCounts(classArray, count) {
                                var classesToUpdate = [];
                                forEach(classArray, function (className) {
                                    if (count > 0 || classCounts[className]) {
                                        classCounts[className] = (classCounts[className] || 0) + count;
                                        if (classCounts[className] === +(count > 0)) {
                                            classesToUpdate.push(className);
                                        }
                                    }
                                });
                                return classesToUpdate.join(" ");
                            }
                            function ngClassIndexWatchAction(newModulo) {
                                if (newModulo === selector) {
                                    addClasses(oldClassString);
                                } else {
                                    removeClasses(oldClassString);
                                }
                                oldModulo = newModulo;
                            }
                            function ngClassWatchAction(newClassString) {
                                if (!isString(newClassString)) {
                                    newClassString = toClassString(newClassString);
                                }
                                if (oldModulo === selector) {
                                    updateClasses(oldClassString, newClassString);
                                }
                                oldClassString = newClassString;
                            }
                        },
                    };
                },
            ];
            function arrayDifference(tokens1, tokens2) {
                if (!tokens1 || !tokens1.length) return [];
                if (!tokens2 || !tokens2.length) return tokens1;
                var values = [];
                outer: for (var i = 0; i < tokens1.length; i++) {
                    var token = tokens1[i];
                    for (var j = 0; j < tokens2.length; j++) {
                        if (token === tokens2[j]) continue outer;
                    }
                    values.push(token);
                }
                return values;
            }
            function split(classString) {
                return classString && classString.split(" ");
            }
            function toClassString(classValue) {
                var classString = classValue;
                if (isArray(classValue)) {
                    classString = classValue.map(toClassString).join(" ");
                } else if (isObject(classValue)) {
                    classString = Object.keys(classValue)
                        .filter(function (key) {
                            return classValue[key];
                        })
                        .join(" ");
                }
                return classString;
            }
        }
        var ngClassDirective = classDirective("", true);
        var ngClassOddDirective = classDirective("Odd", 0);
        var ngClassEvenDirective = classDirective("Even", 1);
        var ngCloakDirective = ngDirective({
            compile: function (element, attr) {
                attr.$set("ngCloak", undefined);
                element.removeClass("ng-cloak");
            },
        });
        var ngControllerDirective = [
            function () {
                return { restrict: "A", scope: true, controller: "@", priority: 500 };
            },
        ];
        var ngEventDirectives = {};
        var forceAsyncEvents = { blur: true, focus: true };
        forEach("click dblclick mousedown mouseup mouseover mouseout mousemove mouseenter mouseleave keydown keyup keypress submit focus blur copy cut paste".split(" "), function (eventName) {
            var directiveName = directiveNormalize("ng-" + eventName);
            ngEventDirectives[directiveName] = [
                "$parse",
                "$rootScope",
                function ($parse, $rootScope) {
                    return {
                        restrict: "A",
                        compile: function ($element, attr) {
                            var fn = $parse(attr[directiveName]);
                            return function ngEventHandler(scope, element) {
                                element.on(eventName, function (event) {
                                    var callback = function () {
                                        fn(scope, { $event: event });
                                    };
                                    if (forceAsyncEvents[eventName] && $rootScope.$$phase) {
                                        scope.$evalAsync(callback);
                                    } else {
                                        scope.$apply(callback);
                                    }
                                });
                            };
                        },
                    };
                },
            ];
        });
        var ngIfDirective = [
            "$animate",
            "$compile",
            function ($animate, $compile) {
                return {
                    multiElement: true,
                    transclude: "element",
                    priority: 600,
                    terminal: true,
                    restrict: "A",
                    $$tlb: true,
                    link: function ($scope, $element, $attr, ctrl, $transclude) {
                        var block, childScope, previousElements;
                        $scope.$watch($attr.ngIf, function ngIfWatchAction(value) {
                            if (value) {
                                if (!childScope) {
                                    $transclude(function (clone, newScope) {
                                        childScope = newScope;
                                        clone[clone.length++] = $compile.$$createComment("end ngIf", $attr.ngIf);
                                        block = { clone: clone };
                                        $animate.enter(clone, $element.parent(), $element);
                                    });
                                }
                            } else {
                                if (previousElements) {
                                    previousElements.remove();
                                    previousElements = null;
                                }
                                if (childScope) {
                                    childScope.$destroy();
                                    childScope = null;
                                }
                                if (block) {
                                    previousElements = getBlockNodes(block.clone);
                                    $animate.leave(previousElements).done(function (response) {
                                        if (response !== false) previousElements = null;
                                    });
                                    block = null;
                                }
                            }
                        });
                    },
                };
            },
        ];
        var ngIncludeDirective = [
            "$templateRequest",
            "$anchorScroll",
            "$animate",
            function ($templateRequest, $anchorScroll, $animate) {
                return {
                    restrict: "ECA",
                    priority: 400,
                    terminal: true,
                    transclude: "element",
                    controller: angular.noop,
                    compile: function (element, attr) {
                        var srcExp = attr.ngInclude || attr.src,
                            onloadExp = attr.onload || "",
                            autoScrollExp = attr.autoscroll;
                        return function (scope, $element, $attr, ctrl, $transclude) {
                            var changeCounter = 0,
                                currentScope,
                                previousElement,
                                currentElement;
                            var cleanupLastIncludeContent = function () {
                                if (previousElement) {
                                    previousElement.remove();
                                    previousElement = null;
                                }
                                if (currentScope) {
                                    currentScope.$destroy();
                                    currentScope = null;
                                }
                                if (currentElement) {
                                    $animate.leave(currentElement).done(function (response) {
                                        if (response !== false) previousElement = null;
                                    });
                                    previousElement = currentElement;
                                    currentElement = null;
                                }
                            };
                            scope.$watch(srcExp, function ngIncludeWatchAction(src) {
                                var afterAnimation = function (response) {
                                    if (response !== false && isDefined(autoScrollExp) && (!autoScrollExp || scope.$eval(autoScrollExp))) {
                                        $anchorScroll();
                                    }
                                };
                                var thisChangeId = ++changeCounter;
                                if (src) {
                                    $templateRequest(src, true).then(
                                        function (response) {
                                            if (scope.$$destroyed) return;
                                            if (thisChangeId !== changeCounter) return;
                                            var newScope = scope.$new();
                                            ctrl.template = response;
                                            var clone = $transclude(newScope, function (clone) {
                                                cleanupLastIncludeContent();
                                                $animate.enter(clone, null, $element).done(afterAnimation);
                                            });
                                            currentScope = newScope;
                                            currentElement = clone;
                                            currentScope.$emit("$includeContentLoaded", src);
                                            scope.$eval(onloadExp);
                                        },
                                        function () {
                                            if (scope.$$destroyed) return;
                                            if (thisChangeId === changeCounter) {
                                                cleanupLastIncludeContent();
                                                scope.$emit("$includeContentError", src);
                                            }
                                        }
                                    );
                                    scope.$emit("$includeContentRequested", src);
                                } else {
                                    cleanupLastIncludeContent();
                                    ctrl.template = null;
                                }
                            });
                        };
                    },
                };
            },
        ];
        var ngIncludeFillContentDirective = [
            "$compile",
            function ($compile) {
                return {
                    restrict: "ECA",
                    priority: -400,
                    require: "ngInclude",
                    link: function (scope, $element, $attr, ctrl) {
                        if (toString.call($element[0]).match(/SVG/)) {
                            $element.empty();
                            $compile(jqLiteBuildFragment(ctrl.template, window.document).childNodes)(
                                scope,
                                function namespaceAdaptedClone(clone) {
                                    $element.append(clone);
                                },
                                { futureParentElement: $element }
                            );
                            return;
                        }
                        $element.html(ctrl.template);
                        $compile($element.contents())(scope);
                    },
                };
            },
        ];
        var ngInitDirective = ngDirective({
            priority: 450,
            compile: function () {
                return {
                    pre: function (scope, element, attrs) {
                        scope.$eval(attrs.ngInit);
                    },
                };
            },
        });
        var ngListDirective = function () {
            return {
                restrict: "A",
                priority: 100,
                require: "ngModel",
                link: function (scope, element, attr, ctrl) {
                    var ngList = attr.ngList || ", ";
                    var trimValues = attr.ngTrim !== "false";
                    var separator = trimValues ? trim(ngList) : ngList;
                    var parse = function (viewValue) {
                        if (isUndefined(viewValue)) return;
                        var list = [];
                        if (viewValue) {
                            forEach(viewValue.split(separator), function (value) {
                                if (value) list.push(trimValues ? trim(value) : value);
                            });
                        }
                        return list;
                    };
                    ctrl.$parsers.push(parse);
                    ctrl.$formatters.push(function (value) {
                        if (isArray(value)) {
                            return value.join(ngList);
                        }
                        return undefined;
                    });
                    ctrl.$isEmpty = function (value) {
                        return !value || !value.length;
                    };
                },
            };
        };
        var VALID_CLASS = "ng-valid",
            INVALID_CLASS = "ng-invalid",
            PRISTINE_CLASS = "ng-pristine",
            DIRTY_CLASS = "ng-dirty",
            UNTOUCHED_CLASS = "ng-untouched",
            TOUCHED_CLASS = "ng-touched",
            EMPTY_CLASS = "ng-empty",
            NOT_EMPTY_CLASS = "ng-not-empty";
        var ngModelMinErr = minErr("ngModel");
        NgModelController.$inject = ["$scope", "$exceptionHandler", "$attrs", "$element", "$parse", "$animate", "$timeout", "$q", "$interpolate"];
        function NgModelController($scope, $exceptionHandler, $attr, $element, $parse, $animate, $timeout, $q, $interpolate) {
            this.$viewValue = Number.NaN;
            this.$modelValue = Number.NaN;
            this.$$rawModelValue = undefined;
            this.$validators = {};
            this.$asyncValidators = {};
            this.$parsers = [];
            this.$formatters = [];
            this.$viewChangeListeners = [];
            this.$untouched = true;
            this.$touched = false;
            this.$pristine = true;
            this.$dirty = false;
            this.$valid = true;
            this.$invalid = false;
            this.$error = {};
            this.$$success = {};
            this.$pending = undefined;
            this.$name = $interpolate($attr.name || "", false)($scope);
            this.$$parentForm = nullFormCtrl;
            this.$options = defaultModelOptions;
            this.$$parsedNgModel = $parse($attr.ngModel);
            this.$$parsedNgModelAssign = this.$$parsedNgModel.assign;
            this.$$ngModelGet = this.$$parsedNgModel;
            this.$$ngModelSet = this.$$parsedNgModelAssign;
            this.$$pendingDebounce = null;
            this.$$parserValid = undefined;
            this.$$currentValidationRunId = 0;
            Object.defineProperty(this, "$$scope", { value: $scope });
            this.$$attr = $attr;
            this.$$element = $element;
            this.$$animate = $animate;
            this.$$timeout = $timeout;
            this.$$parse = $parse;
            this.$$q = $q;
            this.$$exceptionHandler = $exceptionHandler;
            setupValidity(this);
            setupModelWatcher(this);
        }
        NgModelController.prototype = {
            $$initGetterSetters: function () {
                if (this.$options.getOption("getterSetter")) {
                    var invokeModelGetter = this.$$parse(this.$$attr.ngModel + "()"),
                        invokeModelSetter = this.$$parse(this.$$attr.ngModel + "($$$p)");
                    this.$$ngModelGet = function ($scope) {
                        var modelValue = this.$$parsedNgModel($scope);
                        if (isFunction(modelValue)) {
                            modelValue = invokeModelGetter($scope);
                        }
                        return modelValue;
                    };
                    this.$$ngModelSet = function ($scope, newValue) {
                        if (isFunction(this.$$parsedNgModel($scope))) {
                            invokeModelSetter($scope, { $$$p: newValue });
                        } else {
                            this.$$parsedNgModelAssign($scope, newValue);
                        }
                    };
                } else if (!this.$$parsedNgModel.assign) {
                    throw ngModelMinErr("nonassign", "Expression '{0}' is non-assignable. Element: {1}", this.$$attr.ngModel, startingTag(this.$$element));
                }
            },
            $render: noop,
            $isEmpty: function (value) {
                return isUndefined(value) || value === "" || value === null || value !== value;
            },
            $$updateEmptyClasses: function (value) {
                if (this.$isEmpty(value)) {
                    this.$$animate.removeClass(this.$$element, NOT_EMPTY_CLASS);
                    this.$$animate.addClass(this.$$element, EMPTY_CLASS);
                } else {
                    this.$$animate.removeClass(this.$$element, EMPTY_CLASS);
                    this.$$animate.addClass(this.$$element, NOT_EMPTY_CLASS);
                }
            },
            $setPristine: function () {
                this.$dirty = false;
                this.$pristine = true;
                this.$$animate.removeClass(this.$$element, DIRTY_CLASS);
                this.$$animate.addClass(this.$$element, PRISTINE_CLASS);
            },
            $setDirty: function () {
                this.$dirty = true;
                this.$pristine = false;
                this.$$animate.removeClass(this.$$element, PRISTINE_CLASS);
                this.$$animate.addClass(this.$$element, DIRTY_CLASS);
                this.$$parentForm.$setDirty();
            },
            $setUntouched: function () {
                this.$touched = false;
                this.$untouched = true;
                this.$$animate.setClass(this.$$element, UNTOUCHED_CLASS, TOUCHED_CLASS);
            },
            $setTouched: function () {
                this.$touched = true;
                this.$untouched = false;
                this.$$animate.setClass(this.$$element, TOUCHED_CLASS, UNTOUCHED_CLASS);
            },
            $rollbackViewValue: function () {
                this.$$timeout.cancel(this.$$pendingDebounce);
                this.$viewValue = this.$$lastCommittedViewValue;
                this.$render();
            },
            $validate: function () {
                if (isNumberNaN(this.$modelValue)) {
                    return;
                }
                var viewValue = this.$$lastCommittedViewValue;
                var modelValue = this.$$rawModelValue;
                var prevValid = this.$valid;
                var prevModelValue = this.$modelValue;
                var allowInvalid = this.$options.getOption("allowInvalid");
                var that = this;
                this.$$runValidators(modelValue, viewValue, function (allValid) {
                    if (!allowInvalid && prevValid !== allValid) {
                        that.$modelValue = allValid ? modelValue : undefined;
                        if (that.$modelValue !== prevModelValue) {
                            that.$$writeModelToScope();
                        }
                    }
                });
            },
            $$runValidators: function (modelValue, viewValue, doneCallback) {
                this.$$currentValidationRunId++;
                var localValidationRunId = this.$$currentValidationRunId;
                var that = this;
                if (!processParseErrors()) {
                    validationDone(false);
                    return;
                }
                if (!processSyncValidators()) {
                    validationDone(false);
                    return;
                }
                processAsyncValidators();
                function processParseErrors() {
                    var errorKey = that.$$parserName || "parse";
                    if (isUndefined(that.$$parserValid)) {
                        setValidity(errorKey, null);
                    } else {
                        if (!that.$$parserValid) {
                            forEach(that.$validators, function (v, name) {
                                setValidity(name, null);
                            });
                            forEach(that.$asyncValidators, function (v, name) {
                                setValidity(name, null);
                            });
                        }
                        setValidity(errorKey, that.$$parserValid);
                        return that.$$parserValid;
                    }
                    return true;
                }
                function processSyncValidators() {
                    var syncValidatorsValid = true;
                    forEach(that.$validators, function (validator, name) {
                        var result = Boolean(validator(modelValue, viewValue));
                        syncValidatorsValid = syncValidatorsValid && result;
                        setValidity(name, result);
                    });
                    if (!syncValidatorsValid) {
                        forEach(that.$asyncValidators, function (v, name) {
                            setValidity(name, null);
                        });
                        return false;
                    }
                    return true;
                }
                function processAsyncValidators() {
                    var validatorPromises = [];
                    var allValid = true;
                    forEach(that.$asyncValidators, function (validator, name) {
                        var promise = validator(modelValue, viewValue);
                        if (!isPromiseLike(promise)) {
                            throw ngModelMinErr("nopromise", "Expected asynchronous validator to return a promise but got '{0}' instead.", promise);
                        }
                        setValidity(name, undefined);
                        validatorPromises.push(
                            promise.then(
                                function () {
                                    setValidity(name, true);
                                },
                                function () {
                                    allValid = false;
                                    setValidity(name, false);
                                }
                            )
                        );
                    });
                    if (!validatorPromises.length) {
                        validationDone(true);
                    } else {
                        that.$$q.all(validatorPromises).then(function () {
                            validationDone(allValid);
                        }, noop);
                    }
                }
                function setValidity(name, isValid) {
                    if (localValidationRunId === that.$$currentValidationRunId) {
                        that.$setValidity(name, isValid);
                    }
                }
                function validationDone(allValid) {
                    if (localValidationRunId === that.$$currentValidationRunId) {
                        doneCallback(allValid);
                    }
                }
            },
            $commitViewValue: function () {
                var viewValue = this.$viewValue;
                this.$$timeout.cancel(this.$$pendingDebounce);
                if (this.$$lastCommittedViewValue === viewValue && (viewValue !== "" || !this.$$hasNativeValidators)) {
                    return;
                }
                this.$$updateEmptyClasses(viewValue);
                this.$$lastCommittedViewValue = viewValue;
                if (this.$pristine) {
                    this.$setDirty();
                }
                this.$$parseAndValidate();
            },
            $$parseAndValidate: function () {
                var viewValue = this.$$lastCommittedViewValue;
                var modelValue = viewValue;
                var that = this;
                this.$$parserValid = isUndefined(modelValue) ? undefined : true;
                if (this.$$parserValid) {
                    for (var i = 0; i < this.$parsers.length; i++) {
                        modelValue = this.$parsers[i](modelValue);
                        if (isUndefined(modelValue)) {
                            this.$$parserValid = false;
                            break;
                        }
                    }
                }
                if (isNumberNaN(this.$modelValue)) {
                    this.$modelValue = this.$$ngModelGet(this.$$scope);
                }
                var prevModelValue = this.$modelValue;
                var allowInvalid = this.$options.getOption("allowInvalid");
                this.$$rawModelValue = modelValue;
                if (allowInvalid) {
                    this.$modelValue = modelValue;
                    writeToModelIfNeeded();
                }
                this.$$runValidators(modelValue, this.$$lastCommittedViewValue, function (allValid) {
                    if (!allowInvalid) {
                        that.$modelValue = allValid ? modelValue : undefined;
                        writeToModelIfNeeded();
                    }
                });
                function writeToModelIfNeeded() {
                    if (that.$modelValue !== prevModelValue) {
                        that.$$writeModelToScope();
                    }
                }
            },
            $$writeModelToScope: function () {
                this.$$ngModelSet(this.$$scope, this.$modelValue);
                forEach(
                    this.$viewChangeListeners,
                    function (listener) {
                        try {
                            listener();
                        } catch (e) {
                            this.$$exceptionHandler(e);
                        }
                    },
                    this
                );
            },
            $setViewValue: function (value, trigger) {
                this.$viewValue = value;
                if (this.$options.getOption("updateOnDefault")) {
                    this.$$debounceViewValueCommit(trigger);
                }
            },
            $$debounceViewValueCommit: function (trigger) {
                var debounceDelay = this.$options.getOption("debounce");
                if (isNumber(debounceDelay[trigger])) {
                    debounceDelay = debounceDelay[trigger];
                } else if (isNumber(debounceDelay["default"])) {
                    debounceDelay = debounceDelay["default"];
                }
                this.$$timeout.cancel(this.$$pendingDebounce);
                var that = this;
                if (debounceDelay > 0) {
                    this.$$pendingDebounce = this.$$timeout(function () {
                        that.$commitViewValue();
                    }, debounceDelay);
                } else if (this.$$scope.$root.$$phase) {
                    this.$commitViewValue();
                } else {
                    this.$$scope.$apply(function () {
                        that.$commitViewValue();
                    });
                }
            },
            $overrideModelOptions: function (options) {
                this.$options = this.$options.createChild(options);
            },
        };
        function setupModelWatcher(ctrl) {
            ctrl.$$scope.$watch(function ngModelWatch(scope) {
                var modelValue = ctrl.$$ngModelGet(scope);
                if (modelValue !== ctrl.$modelValue && (ctrl.$modelValue === ctrl.$modelValue || modelValue === modelValue)) {
                    ctrl.$modelValue = ctrl.$$rawModelValue = modelValue;
                    ctrl.$$parserValid = undefined;
                    var formatters = ctrl.$formatters,
                        idx = formatters.length;
                    var viewValue = modelValue;
                    while (idx--) {
                        viewValue = formatters[idx](viewValue);
                    }
                    if (ctrl.$viewValue !== viewValue) {
                        ctrl.$$updateEmptyClasses(viewValue);
                        ctrl.$viewValue = ctrl.$$lastCommittedViewValue = viewValue;
                        ctrl.$render();
                        ctrl.$$runValidators(ctrl.$modelValue, ctrl.$viewValue, noop);
                    }
                }
                return modelValue;
            });
        }
        addSetValidityMethod({
            clazz: NgModelController,
            set: function (object, property) {
                object[property] = true;
            },
            unset: function (object, property) {
                delete object[property];
            },
        });
        var ngModelDirective = [
            "$rootScope",
            function ($rootScope) {
                return {
                    restrict: "A",
                    require: ["ngModel", "^?form", "^?ngModelOptions"],
                    controller: NgModelController,
                    priority: 1,
                    compile: function ngModelCompile(element) {
                        element.addClass(PRISTINE_CLASS).addClass(UNTOUCHED_CLASS).addClass(VALID_CLASS);
                        return {
                            pre: function ngModelPreLink(scope, element, attr, ctrls) {
                                var modelCtrl = ctrls[0],
                                    formCtrl = ctrls[1] || modelCtrl.$$parentForm,
                                    optionsCtrl = ctrls[2];
                                if (optionsCtrl) {
                                    modelCtrl.$options = optionsCtrl.$options;
                                }
                                modelCtrl.$$initGetterSetters();
                                formCtrl.$addControl(modelCtrl);
                                attr.$observe("name", function (newValue) {
                                    if (modelCtrl.$name !== newValue) {
                                        modelCtrl.$$parentForm.$$renameControl(modelCtrl, newValue);
                                    }
                                });
                                scope.$on("$destroy", function () {
                                    modelCtrl.$$parentForm.$removeControl(modelCtrl);
                                });
                            },
                            post: function ngModelPostLink(scope, element, attr, ctrls) {
                                var modelCtrl = ctrls[0];
                                if (modelCtrl.$options.getOption("updateOn")) {
                                    element.on(modelCtrl.$options.getOption("updateOn"), function (ev) {
                                        modelCtrl.$$debounceViewValueCommit(ev && ev.type);
                                    });
                                }
                                function setTouched() {
                                    modelCtrl.$setTouched();
                                }
                                element.on("blur", function () {
                                    if (modelCtrl.$touched) return;
                                    if ($rootScope.$$phase) {
                                        scope.$evalAsync(setTouched);
                                    } else {
                                        scope.$apply(setTouched);
                                    }
                                });
                            },
                        };
                    },
                };
            },
        ];
        var defaultModelOptions;
        var DEFAULT_REGEXP = /(\s+|^)default(\s+|$)/;
        function ModelOptions(options) {
            this.$$options = options;
        }
        ModelOptions.prototype = {
            getOption: function (name) {
                return this.$$options[name];
            },
            createChild: function (options) {
                var inheritAll = false;
                options = extend({}, options);
                forEach(
                    options,
                    function (option, key) {
                        if (option === "$inherit") {
                            if (key === "*") {
                                inheritAll = true;
                            } else {
                                options[key] = this.$$options[key];
                                if (key === "updateOn") {
                                    options.updateOnDefault = this.$$options.updateOnDefault;
                                }
                            }
                        } else {
                            if (key === "updateOn") {
                                options.updateOnDefault = false;
                                options[key] = trim(
                                    option.replace(DEFAULT_REGEXP, function () {
                                        options.updateOnDefault = true;
                                        return " ";
                                    })
                                );
                            }
                        }
                    },
                    this
                );
                if (inheritAll) {
                    delete options["*"];
                    defaults(options, this.$$options);
                }
                defaults(options, defaultModelOptions.$$options);
                return new ModelOptions(options);
            },
        };
        defaultModelOptions = new ModelOptions({ updateOn: "", updateOnDefault: true, debounce: 0, getterSetter: false, allowInvalid: false, timezone: null });
        var ngModelOptionsDirective = function () {
            NgModelOptionsController.$inject = ["$attrs", "$scope"];
            function NgModelOptionsController($attrs, $scope) {
                this.$$attrs = $attrs;
                this.$$scope = $scope;
            }
            NgModelOptionsController.prototype = {
                $onInit: function () {
                    var parentOptions = this.parentCtrl ? this.parentCtrl.$options : defaultModelOptions;
                    var modelOptionsDefinition = this.$$scope.$eval(this.$$attrs.ngModelOptions);
                    this.$options = parentOptions.createChild(modelOptionsDefinition);
                },
            };
            return { restrict: "A", priority: 10, require: { parentCtrl: "?^^ngModelOptions" }, bindToController: true, controller: NgModelOptionsController };
        };
        function defaults(dst, src) {
            forEach(src, function (value, key) {
                if (!isDefined(dst[key])) {
                    dst[key] = value;
                }
            });
        }
        var ngNonBindableDirective = ngDirective({ terminal: true, priority: 1e3 });
        var ngOptionsMinErr = minErr("ngOptions");
        var NG_OPTIONS_REGEXP = /^\s*([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+group\s+by\s+([\s\S]+?))?(?:\s+disable\s+when\s+([\s\S]+?))?\s+for\s+(?:([$\w][$\w]*)|(?:\(\s*([$\w][$\w]*)\s*,\s*([$\w][$\w]*)\s*\)))\s+in\s+([\s\S]+?)(?:\s+track\s+by\s+([\s\S]+?))?$/;
        var ngOptionsDirective = [
            "$compile",
            "$document",
            "$parse",
            function ($compile, $document, $parse) {
                function parseOptionsExpression(optionsExp, selectElement, scope) {
                    var match = optionsExp.match(NG_OPTIONS_REGEXP);
                    if (!match) {
                        throw ngOptionsMinErr("iexp", "Expected expression in form of " + "'_select_ (as _label_)? for (_key_,)?_value_ in _collection_'" + " but got '{0}'. Element: {1}", optionsExp, startingTag(selectElement));
                    }
                    var valueName = match[5] || match[7];
                    var keyName = match[6];
                    var selectAs = / as /.test(match[0]) && match[1];
                    var trackBy = match[9];
                    var valueFn = $parse(match[2] ? match[1] : valueName);
                    var selectAsFn = selectAs && $parse(selectAs);
                    var viewValueFn = selectAsFn || valueFn;
                    var trackByFn = trackBy && $parse(trackBy);
                    var getTrackByValueFn = trackBy
                        ? function (value, locals) {
                            return trackByFn(scope, locals);
                        }
                        : function getHashOfValue(value) {
                            return hashKey(value);
                        };
                    var getTrackByValue = function (value, key) {
                        return getTrackByValueFn(value, getLocals(value, key));
                    };
                    var displayFn = $parse(match[2] || match[1]);
                    var groupByFn = $parse(match[3] || "");
                    var disableWhenFn = $parse(match[4] || "");
                    var valuesFn = $parse(match[8]);
                    var locals = {};
                    var getLocals = keyName
                        ? function (value, key) {
                            locals[keyName] = key;
                            locals[valueName] = value;
                            return locals;
                        }
                        : function (value) {
                            locals[valueName] = value;
                            return locals;
                        };
                    function Option(selectValue, viewValue, label, group, disabled) {
                        this.selectValue = selectValue;
                        this.viewValue = viewValue;
                        this.label = label;
                        this.group = group;
                        this.disabled = disabled;
                    }
                    function getOptionValuesKeys(optionValues) {
                        var optionValuesKeys;
                        if (!keyName && isArrayLike(optionValues)) {
                            optionValuesKeys = optionValues;
                        } else {
                            optionValuesKeys = [];
                            for (var itemKey in optionValues) {
                                if (optionValues.hasOwnProperty(itemKey) && itemKey.charAt(0) !== "$") {
                                    optionValuesKeys.push(itemKey);
                                }
                            }
                        }
                        return optionValuesKeys;
                    }
                    return {
                        trackBy: trackBy,
                        getTrackByValue: getTrackByValue,
                        getWatchables: $parse(valuesFn, function (optionValues) {
                            var watchedArray = [];
                            optionValues = optionValues || [];
                            var optionValuesKeys = getOptionValuesKeys(optionValues);
                            var optionValuesLength = optionValuesKeys.length;
                            for (var index = 0; index < optionValuesLength; index++) {
                                var key = optionValues === optionValuesKeys ? index : optionValuesKeys[index];
                                var value = optionValues[key];
                                var locals = getLocals(value, key);
                                var selectValue = getTrackByValueFn(value, locals);
                                watchedArray.push(selectValue);
                                if (match[2] || match[1]) {
                                    var label = displayFn(scope, locals);
                                    watchedArray.push(label);
                                }
                                if (match[4]) {
                                    var disableWhen = disableWhenFn(scope, locals);
                                    watchedArray.push(disableWhen);
                                }
                            }
                            return watchedArray;
                        }),
                        getOptions: function () {
                            var optionItems = [];
                            var selectValueMap = {};
                            var optionValues = valuesFn(scope) || [];
                            var optionValuesKeys = getOptionValuesKeys(optionValues);
                            var optionValuesLength = optionValuesKeys.length;
                            for (var index = 0; index < optionValuesLength; index++) {
                                var key = optionValues === optionValuesKeys ? index : optionValuesKeys[index];
                                var value = optionValues[key];
                                var locals = getLocals(value, key);
                                var viewValue = viewValueFn(scope, locals);
                                var selectValue = getTrackByValueFn(viewValue, locals);
                                var label = displayFn(scope, locals);
                                var group = groupByFn(scope, locals);
                                var disabled = disableWhenFn(scope, locals);
                                var optionItem = new Option(selectValue, viewValue, label, group, disabled);
                                optionItems.push(optionItem);
                                selectValueMap[selectValue] = optionItem;
                            }
                            return {
                                items: optionItems,
                                selectValueMap: selectValueMap,
                                getOptionFromViewValue: function (value) {
                                    return selectValueMap[getTrackByValue(value)];
                                },
                                getViewValueFromOption: function (option) {
                                    return trackBy ? copy(option.viewValue) : option.viewValue;
                                },
                            };
                        },
                    };
                }
                var optionTemplate = window.document.createElement("option"),
                    optGroupTemplate = window.document.createElement("optgroup");
                function ngOptionsPostLink(scope, selectElement, attr, ctrls) {
                    var selectCtrl = ctrls[0];
                    var ngModelCtrl = ctrls[1];
                    var multiple = attr.multiple;
                    for (var i = 0, children = selectElement.children(), ii = children.length; i < ii; i++) {
                        if (children[i].value === "") {
                            selectCtrl.hasEmptyOption = true;
                            selectCtrl.emptyOption = children.eq(i);
                            break;
                        }
                    }
                    var providedEmptyOption = !!selectCtrl.emptyOption;
                    var unknownOption = jqLite(optionTemplate.cloneNode(false));
                    unknownOption.val("?");
                    var options;
                    var ngOptions = parseOptionsExpression(attr.ngOptions, selectElement, scope);
                    var listFragment = $document[0].createDocumentFragment();
                    selectCtrl.generateUnknownOptionValue = function (val) {
                        return "?";
                    };
                    if (!multiple) {
                        selectCtrl.writeValue = function writeNgOptionsValue(value) {
                            var selectedOption = options.selectValueMap[selectElement.val()];
                            var option = options.getOptionFromViewValue(value);
                            if (selectedOption) selectedOption.element.removeAttribute("selected");
                            if (option) {
                                if (selectElement[0].value !== option.selectValue) {
                                    selectCtrl.removeUnknownOption();
                                    selectCtrl.unselectEmptyOption();
                                    selectElement[0].value = option.selectValue;
                                    option.element.selected = true;
                                }
                                option.element.setAttribute("selected", "selected");
                            } else {
                                if (providedEmptyOption) {
                                    selectCtrl.selectEmptyOption();
                                } else if (selectCtrl.unknownOption.parent().length) {
                                    selectCtrl.updateUnknownOption(value);
                                } else {
                                    selectCtrl.renderUnknownOption(value);
                                }
                            }
                        };
                        selectCtrl.readValue = function readNgOptionsValue() {
                            var selectedOption = options.selectValueMap[selectElement.val()];
                            if (selectedOption && !selectedOption.disabled) {
                                selectCtrl.unselectEmptyOption();
                                selectCtrl.removeUnknownOption();
                                return options.getViewValueFromOption(selectedOption);
                            }
                            return null;
                        };
                        if (ngOptions.trackBy) {
                            scope.$watch(
                                function () {
                                    return ngOptions.getTrackByValue(ngModelCtrl.$viewValue);
                                },
                                function () {
                                    ngModelCtrl.$render();
                                }
                            );
                        }
                    } else {
                        selectCtrl.writeValue = function writeNgOptionsMultiple(values) {
                            var selectedOptions = (values && values.map(getAndUpdateSelectedOption)) || [];
                            options.items.forEach(function (option) {
                                if (option.element.selected && !includes(selectedOptions, option)) {
                                    option.element.selected = false;
                                }
                            });
                        };
                        selectCtrl.readValue = function readNgOptionsMultiple() {
                            var selectedValues = selectElement.val() || [],
                                selections = [];
                            forEach(selectedValues, function (value) {
                                var option = options.selectValueMap[value];
                                if (option && !option.disabled) selections.push(options.getViewValueFromOption(option));
                            });
                            return selections;
                        };
                        if (ngOptions.trackBy) {
                            scope.$watchCollection(
                                function () {
                                    if (isArray(ngModelCtrl.$viewValue)) {
                                        return ngModelCtrl.$viewValue.map(function (value) {
                                            return ngOptions.getTrackByValue(value);
                                        });
                                    }
                                },
                                function () {
                                    ngModelCtrl.$render();
                                }
                            );
                        }
                    }
                    if (providedEmptyOption) {
                        selectCtrl.emptyOption.remove();
                        $compile(selectCtrl.emptyOption)(scope);
                        if (selectCtrl.emptyOption[0].nodeType === NODE_TYPE_COMMENT) {
                            selectCtrl.hasEmptyOption = false;
                            selectCtrl.registerOption = function (optionScope, optionEl) {
                                if (optionEl.val() === "") {
                                    selectCtrl.hasEmptyOption = true;
                                    selectCtrl.emptyOption = optionEl;
                                    selectCtrl.emptyOption.removeClass("ng-scope");
                                    ngModelCtrl.$render();
                                    optionEl.on("$destroy", function () {
                                        selectCtrl.hasEmptyOption = false;
                                        selectCtrl.emptyOption = undefined;
                                    });
                                }
                            };
                        } else {
                            selectCtrl.emptyOption.removeClass("ng-scope");
                        }
                    }
                    selectElement.empty();
                    updateOptions();
                    scope.$watchCollection(ngOptions.getWatchables, updateOptions);
                    function addOptionElement(option, parent) {
                        var optionElement = optionTemplate.cloneNode(false);
                        parent.appendChild(optionElement);
                        updateOptionElement(option, optionElement);
                    }
                    function getAndUpdateSelectedOption(viewValue) {
                        var option = options.getOptionFromViewValue(viewValue);
                        var element = option && option.element;
                        if (element && !element.selected) element.selected = true;
                        return option;
                    }
                    function updateOptionElement(option, element) {
                        option.element = element;
                        element.disabled = option.disabled;
                        if (option.label !== element.label) {
                            element.label = option.label;
                            element.textContent = option.label;
                        }
                        element.value = option.selectValue;
                    }
                    function updateOptions() {
                        var previousValue = options && selectCtrl.readValue();
                        if (options) {
                            for (var i = options.items.length - 1; i >= 0; i--) {
                                var option = options.items[i];
                                if (isDefined(option.group)) {
                                    jqLiteRemove(option.element.parentNode);
                                } else {
                                    jqLiteRemove(option.element);
                                }
                            }
                        }
                        options = ngOptions.getOptions();
                        var groupElementMap = {};
                        if (providedEmptyOption) {
                            selectElement.prepend(selectCtrl.emptyOption);
                        }
                        options.items.forEach(function addOption(option) {
                            var groupElement;
                            if (isDefined(option.group)) {
                                groupElement = groupElementMap[option.group];
                                if (!groupElement) {
                                    groupElement = optGroupTemplate.cloneNode(false);
                                    listFragment.appendChild(groupElement);
                                    groupElement.label = option.group === null ? "null" : option.group;
                                    groupElementMap[option.group] = groupElement;
                                }
                                addOptionElement(option, groupElement);
                            } else {
                                addOptionElement(option, listFragment);
                            }
                        });
                        selectElement[0].appendChild(listFragment);
                        ngModelCtrl.$render();
                        if (!ngModelCtrl.$isEmpty(previousValue)) {
                            var nextValue = selectCtrl.readValue();
                            var isNotPrimitive = ngOptions.trackBy || multiple;
                            if (isNotPrimitive ? !equals(previousValue, nextValue) : previousValue !== nextValue) {
                                ngModelCtrl.$setViewValue(nextValue);
                                ngModelCtrl.$render();
                            }
                        }
                    }
                }
                return {
                    restrict: "A",
                    terminal: true,
                    require: ["select", "ngModel"],
                    link: {
                        pre: function ngOptionsPreLink(scope, selectElement, attr, ctrls) {
                            ctrls[0].registerOption = noop;
                        },
                        post: ngOptionsPostLink,
                    },
                };
            },
        ];
        var ngPluralizeDirective = [
            "$locale",
            "$interpolate",
            "$log",
            function ($locale, $interpolate, $log) {
                var BRACE = /{}/g,
                    IS_WHEN = /^when(Minus)?(.+)$/;
                return {
                    link: function (scope, element, attr) {
                        var numberExp = attr.count,
                            whenExp = attr.$attr.when && element.attr(attr.$attr.when),
                            offset = attr.offset || 0,
                            whens = scope.$eval(whenExp) || {},
                            whensExpFns = {},
                            startSymbol = $interpolate.startSymbol(),
                            endSymbol = $interpolate.endSymbol(),
                            braceReplacement = startSymbol + numberExp + "-" + offset + endSymbol,
                            watchRemover = angular.noop,
                            lastCount;
                        forEach(attr, function (expression, attributeName) {
                            var tmpMatch = IS_WHEN.exec(attributeName);
                            if (tmpMatch) {
                                var whenKey = (tmpMatch[1] ? "-" : "") + lowercase(tmpMatch[2]);
                                whens[whenKey] = element.attr(attr.$attr[attributeName]);
                            }
                        });
                        forEach(whens, function (expression, key) {
                            whensExpFns[key] = $interpolate(expression.replace(BRACE, braceReplacement));
                        });
                        scope.$watch(numberExp, function ngPluralizeWatchAction(newVal) {
                            var count = parseFloat(newVal);
                            var countIsNaN = isNumberNaN(count);
                            if (!countIsNaN && !(count in whens)) {
                                count = $locale.pluralCat(count - offset);
                            }
                            if (count !== lastCount && !(countIsNaN && isNumberNaN(lastCount))) {
                                watchRemover();
                                var whenExpFn = whensExpFns[count];
                                if (isUndefined(whenExpFn)) {
                                    if (newVal != null) {
                                        $log.debug("ngPluralize: no rule defined for '" + count + "' in " + whenExp);
                                    }
                                    watchRemover = noop;
                                    updateElementText();
                                } else {
                                    watchRemover = scope.$watch(whenExpFn, updateElementText);
                                }
                                lastCount = count;
                            }
                        });
                        function updateElementText(newText) {
                            element.text(newText || "");
                        }
                    },
                };
            },
        ];
        var ngRepeatDirective = [
            "$parse",
            "$animate",
            "$compile",
            function ($parse, $animate, $compile) {
                var NG_REMOVED = "$$NG_REMOVED";
                var ngRepeatMinErr = minErr("ngRepeat");
                var updateScope = function (scope, index, valueIdentifier, value, keyIdentifier, key, arrayLength) {
                    scope[valueIdentifier] = value;
                    if (keyIdentifier) scope[keyIdentifier] = key;
                    scope.$index = index;
                    scope.$first = index === 0;
                    scope.$last = index === arrayLength - 1;
                    scope.$middle = !(scope.$first || scope.$last);
                    scope.$odd = !(scope.$even = (index & 1) === 0);
                };
                var getBlockStart = function (block) {
                    return block.clone[0];
                };
                var getBlockEnd = function (block) {
                    return block.clone[block.clone.length - 1];
                };
                return {
                    restrict: "A",
                    multiElement: true,
                    transclude: "element",
                    priority: 1e3,
                    terminal: true,
                    $$tlb: true,
                    compile: function ngRepeatCompile($element, $attr) {
                        var expression = $attr.ngRepeat;
                        var ngRepeatEndComment = $compile.$$createComment("end ngRepeat", expression);
                        var match = expression.match(/^\s*([\s\S]+?)\s+in\s+([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+track\s+by\s+([\s\S]+?))?\s*$/);
                        if (!match) {
                            throw ngRepeatMinErr("iexp", "Expected expression in form of '_item_ in _collection_[ track by _id_]' but got '{0}'.", expression);
                        }
                        var lhs = match[1];
                        var rhs = match[2];
                        var aliasAs = match[3];
                        var trackByExp = match[4];
                        match = lhs.match(/^(?:(\s*[$\w]+)|\(\s*([$\w]+)\s*,\s*([$\w]+)\s*\))$/);
                        if (!match) {
                            throw ngRepeatMinErr("iidexp", "'_item_' in '_item_ in _collection_' should be an identifier or '(_key_, _value_)' expression, but got '{0}'.", lhs);
                        }
                        var valueIdentifier = match[3] || match[1];
                        var keyIdentifier = match[2];
                        if (aliasAs && (!/^[$a-zA-Z_][$a-zA-Z0-9_]*$/.test(aliasAs) || /^(null|undefined|this|\$index|\$first|\$middle|\$last|\$even|\$odd|\$parent|\$root|\$id)$/.test(aliasAs))) {
                            throw ngRepeatMinErr("badident", "alias '{0}' is invalid --- must be a valid JS identifier which is not a reserved name.", aliasAs);
                        }
                        var trackByExpGetter, trackByIdExpFn, trackByIdArrayFn, trackByIdObjFn;
                        var hashFnLocals = { $id: hashKey };
                        if (trackByExp) {
                            trackByExpGetter = $parse(trackByExp);
                        } else {
                            trackByIdArrayFn = function (key, value) {
                                return hashKey(value);
                            };
                            trackByIdObjFn = function (key) {
                                return key;
                            };
                        }
                        return function ngRepeatLink($scope, $element, $attr, ctrl, $transclude) {
                            if (trackByExpGetter) {
                                trackByIdExpFn = function (key, value, index) {
                                    if (keyIdentifier) hashFnLocals[keyIdentifier] = key;
                                    hashFnLocals[valueIdentifier] = value;
                                    hashFnLocals.$index = index;
                                    return trackByExpGetter($scope, hashFnLocals);
                                };
                            }
                            var lastBlockMap = createMap();
                            $scope.$watchCollection(rhs, function ngRepeatAction(collection) {
                                var index,
                                    length,
                                    previousNode = $element[0],
                                    nextNode,
                                    nextBlockMap = createMap(),
                                    collectionLength,
                                    key,
                                    value,
                                    trackById,
                                    trackByIdFn,
                                    collectionKeys,
                                    block,
                                    nextBlockOrder,
                                    elementsToRemove;
                                if (aliasAs) {
                                    $scope[aliasAs] = collection;
                                }
                                if (isArrayLike(collection)) {
                                    collectionKeys = collection;
                                    trackByIdFn = trackByIdExpFn || trackByIdArrayFn;
                                } else {
                                    trackByIdFn = trackByIdExpFn || trackByIdObjFn;
                                    collectionKeys = [];
                                    for (var itemKey in collection) {
                                        if (hasOwnProperty.call(collection, itemKey) && itemKey.charAt(0) !== "$") {
                                            collectionKeys.push(itemKey);
                                        }
                                    }
                                }
                                collectionLength = collectionKeys.length;
                                nextBlockOrder = new Array(collectionLength);
                                for (index = 0; index < collectionLength; index++) {
                                    key = collection === collectionKeys ? index : collectionKeys[index];
                                    value = collection[key];
                                    trackById = trackByIdFn(key, value, index);
                                    if (lastBlockMap[trackById]) {
                                        block = lastBlockMap[trackById];
                                        delete lastBlockMap[trackById];
                                        nextBlockMap[trackById] = block;
                                        nextBlockOrder[index] = block;
                                    } else if (nextBlockMap[trackById]) {
                                        forEach(nextBlockOrder, function (block) {
                                            if (block && block.scope) lastBlockMap[block.id] = block;
                                        });
                                        throw ngRepeatMinErr(
                                            "dupes",
                                            "Duplicates in a repeater are not allowed. Use 'track by' expression to specify unique keys. Repeater: {0}, Duplicate key: {1}, Duplicate value: {2}",
                                            expression,
                                            trackById,
                                            value
                                        );
                                    } else {
                                        nextBlockOrder[index] = { id: trackById, scope: undefined, clone: undefined };
                                        nextBlockMap[trackById] = true;
                                    }
                                }
                                for (var blockKey in lastBlockMap) {
                                    block = lastBlockMap[blockKey];
                                    elementsToRemove = getBlockNodes(block.clone);
                                    $animate.leave(elementsToRemove);
                                    if (elementsToRemove[0].parentNode) {
                                        for (index = 0, length = elementsToRemove.length; index < length; index++) {
                                            elementsToRemove[index][NG_REMOVED] = true;
                                        }
                                    }
                                    block.scope.$destroy();
                                }
                                for (index = 0; index < collectionLength; index++) {
                                    key = collection === collectionKeys ? index : collectionKeys[index];
                                    value = collection[key];
                                    block = nextBlockOrder[index];
                                    if (block.scope) {
                                        nextNode = previousNode;
                                        do {
                                            nextNode = nextNode.nextSibling;
                                        } while (nextNode && nextNode[NG_REMOVED]);
                                        if (getBlockStart(block) !== nextNode) {
                                            $animate.move(getBlockNodes(block.clone), null, previousNode);
                                        }
                                        previousNode = getBlockEnd(block);
                                        updateScope(block.scope, index, valueIdentifier, value, keyIdentifier, key, collectionLength);
                                    } else {
                                        $transclude(function ngRepeatTransclude(clone, scope) {
                                            block.scope = scope;
                                            var endNode = ngRepeatEndComment.cloneNode(false);
                                            clone[clone.length++] = endNode;
                                            $animate.enter(clone, null, previousNode);
                                            previousNode = endNode;
                                            block.clone = clone;
                                            nextBlockMap[block.id] = block;
                                            updateScope(block.scope, index, valueIdentifier, value, keyIdentifier, key, collectionLength);
                                        });
                                    }
                                }
                                lastBlockMap = nextBlockMap;
                            });
                        };
                    },
                };
            },
        ];
        var NG_HIDE_CLASS = "ng-hide";
        var NG_HIDE_IN_PROGRESS_CLASS = "ng-hide-animate";
        var ngShowDirective = [
            "$animate",
            function ($animate) {
                return {
                    restrict: "A",
                    multiElement: true,
                    link: function (scope, element, attr) {
                        scope.$watch(attr.ngShow, function ngShowWatchAction(value) {
                            $animate[value ? "removeClass" : "addClass"](element, NG_HIDE_CLASS, { tempClasses: NG_HIDE_IN_PROGRESS_CLASS });
                        });
                    },
                };
            },
        ];
        var ngHideDirective = [
            "$animate",
            function ($animate) {
                return {
                    restrict: "A",
                    multiElement: true,
                    link: function (scope, element, attr) {
                        scope.$watch(attr.ngHide, function ngHideWatchAction(value) {
                            $animate[value ? "addClass" : "removeClass"](element, NG_HIDE_CLASS, { tempClasses: NG_HIDE_IN_PROGRESS_CLASS });
                        });
                    },
                };
            },
        ];
        var ngStyleDirective = ngDirective(function (scope, element, attr) {
            scope.$watch(
                attr.ngStyle,
                function ngStyleWatchAction(newStyles, oldStyles) {
                    if (oldStyles && newStyles !== oldStyles) {
                        forEach(oldStyles, function (val, style) {
                            element.css(style, "");
                        });
                    }
                    if (newStyles) element.css(newStyles);
                },
                true
            );
        });
        var ngSwitchDirective = [
            "$animate",
            "$compile",
            function ($animate, $compile) {
                return {
                    require: "ngSwitch",
                    controller: [
                        "$scope",
                        function NgSwitchController() {
                            this.cases = {};
                        },
                    ],
                    link: function (scope, element, attr, ngSwitchController) {
                        var watchExpr = attr.ngSwitch || attr.on,
                            selectedTranscludes = [],
                            selectedElements = [],
                            previousLeaveAnimations = [],
                            selectedScopes = [];
                        var spliceFactory = function (array, index) {
                            return function (response) {
                                if (response !== false) array.splice(index, 1);
                            };
                        };
                        scope.$watch(watchExpr, function ngSwitchWatchAction(value) {
                            var i, ii;
                            while (previousLeaveAnimations.length) {
                                $animate.cancel(previousLeaveAnimations.pop());
                            }
                            for (i = 0, ii = selectedScopes.length; i < ii; ++i) {
                                var selected = getBlockNodes(selectedElements[i].clone);
                                selectedScopes[i].$destroy();
                                var runner = (previousLeaveAnimations[i] = $animate.leave(selected));
                                runner.done(spliceFactory(previousLeaveAnimations, i));
                            }
                            selectedElements.length = 0;
                            selectedScopes.length = 0;
                            if ((selectedTranscludes = ngSwitchController.cases["!" + value] || ngSwitchController.cases["?"])) {
                                forEach(selectedTranscludes, function (selectedTransclude) {
                                    selectedTransclude.transclude(function (caseElement, selectedScope) {
                                        selectedScopes.push(selectedScope);
                                        var anchor = selectedTransclude.element;
                                        caseElement[caseElement.length++] = $compile.$$createComment("end ngSwitchWhen");
                                        var block = { clone: caseElement };
                                        selectedElements.push(block);
                                        $animate.enter(caseElement, anchor.parent(), anchor);
                                    });
                                });
                            }
                        });
                    },
                };
            },
        ];
        var ngSwitchWhenDirective = ngDirective({
            transclude: "element",
            priority: 1200,
            require: "^ngSwitch",
            multiElement: true,
            link: function (scope, element, attrs, ctrl, $transclude) {
                var cases = attrs.ngSwitchWhen
                    .split(attrs.ngSwitchWhenSeparator)
                    .sort()
                    .filter(function (element, index, array) {
                        return array[index - 1] !== element;
                    });
                forEach(cases, function (whenCase) {
                    ctrl.cases["!" + whenCase] = ctrl.cases["!" + whenCase] || [];
                    ctrl.cases["!" + whenCase].push({ transclude: $transclude, element: element });
                });
            },
        });
        var ngSwitchDefaultDirective = ngDirective({
            transclude: "element",
            priority: 1200,
            require: "^ngSwitch",
            multiElement: true,
            link: function (scope, element, attr, ctrl, $transclude) {
                ctrl.cases["?"] = ctrl.cases["?"] || [];
                ctrl.cases["?"].push({ transclude: $transclude, element: element });
            },
        });
        var ngTranscludeMinErr = minErr("ngTransclude");
        var ngTranscludeDirective = [
            "$compile",
            function ($compile) {
                return {
                    restrict: "EAC",
                    terminal: true,
                    compile: function ngTranscludeCompile(tElement) {
                        var fallbackLinkFn = $compile(tElement.contents());
                        tElement.empty();
                        return function ngTranscludePostLink($scope, $element, $attrs, controller, $transclude) {
                            if (!$transclude) {
                                throw ngTranscludeMinErr("orphan", "Illegal use of ngTransclude directive in the template! " + "No parent directive that requires a transclusion found. " + "Element: {0}", startingTag($element));
                            }
                            if ($attrs.ngTransclude === $attrs.$attr.ngTransclude) {
                                $attrs.ngTransclude = "";
                            }
                            var slotName = $attrs.ngTransclude || $attrs.ngTranscludeSlot;
                            $transclude(ngTranscludeCloneAttachFn, null, slotName);
                            if (slotName && !$transclude.isSlotFilled(slotName)) {
                                useFallbackContent();
                            }
                            function ngTranscludeCloneAttachFn(clone, transcludedScope) {
                                if (clone.length && notWhitespace(clone)) {
                                    $element.append(clone);
                                } else {
                                    useFallbackContent();
                                    transcludedScope.$destroy();
                                }
                            }
                            function useFallbackContent() {
                                fallbackLinkFn($scope, function (clone) {
                                    $element.append(clone);
                                });
                            }
                            function notWhitespace(nodes) {
                                for (var i = 0, ii = nodes.length; i < ii; i++) {
                                    var node = nodes[i];
                                    if (node.nodeType !== NODE_TYPE_TEXT || node.nodeValue.trim()) {
                                        return true;
                                    }
                                }
                            }
                        };
                    },
                };
            },
        ];
        var scriptDirective = [
            "$templateCache",
            function ($templateCache) {
                return {
                    restrict: "E",
                    terminal: true,
                    compile: function (element, attr) {
                        if (attr.type === "text/ng-template") {
                            var templateUrl = attr.id,
                                text = element[0].text;
                            $templateCache.put(templateUrl, text);
                        }
                    },
                };
            },
        ];
        var noopNgModelController = { $setViewValue: noop, $render: noop };
        function setOptionSelectedStatus(optionEl, value) {
            optionEl.prop("selected", value);
            optionEl.attr("selected", value);
        }
        var SelectController = [
            "$element",
            "$scope",
            function ($element, $scope) {
                var self = this,
                    optionsMap = new NgMap();
                self.selectValueMap = {};
                self.ngModelCtrl = noopNgModelController;
                self.multiple = false;
                self.unknownOption = jqLite(window.document.createElement("option"));
                self.hasEmptyOption = false;
                self.emptyOption = undefined;
                self.renderUnknownOption = function (val) {
                    var unknownVal = self.generateUnknownOptionValue(val);
                    self.unknownOption.val(unknownVal);
                    $element.prepend(self.unknownOption);
                    setOptionSelectedStatus(self.unknownOption, true);
                    $element.val(unknownVal);
                };
                self.updateUnknownOption = function (val) {
                    var unknownVal = self.generateUnknownOptionValue(val);
                    self.unknownOption.val(unknownVal);
                    setOptionSelectedStatus(self.unknownOption, true);
                    $element.val(unknownVal);
                };
                self.generateUnknownOptionValue = function (val) {
                    return "? " + hashKey(val) + " ?";
                };
                self.removeUnknownOption = function () {
                    if (self.unknownOption.parent()) self.unknownOption.remove();
                };
                self.selectEmptyOption = function () {
                    if (self.emptyOption) {
                        $element.val("");
                        setOptionSelectedStatus(self.emptyOption, true);
                    }
                };
                self.unselectEmptyOption = function () {
                    if (self.hasEmptyOption) {
                        self.emptyOption.removeAttr("selected");
                    }
                };
                $scope.$on("$destroy", function () {
                    self.renderUnknownOption = noop;
                });
                self.readValue = function readSingleValue() {
                    var val = $element.val();
                    var realVal = val in self.selectValueMap ? self.selectValueMap[val] : val;
                    if (self.hasOption(realVal)) {
                        return realVal;
                    }
                    return null;
                };
                self.writeValue = function writeSingleValue(value) {
                    var currentlySelectedOption = $element[0].options[$element[0].selectedIndex];
                    if (currentlySelectedOption) setOptionSelectedStatus(jqLite(currentlySelectedOption), false);
                    if (self.hasOption(value)) {
                        self.removeUnknownOption();
                        var hashedVal = hashKey(value);
                        $element.val(hashedVal in self.selectValueMap ? hashedVal : value);
                        var selectedOption = $element[0].options[$element[0].selectedIndex];
                        setOptionSelectedStatus(jqLite(selectedOption), true);
                    } else {
                        if (value == null && self.emptyOption) {
                            self.removeUnknownOption();
                            self.selectEmptyOption();
                        } else if (self.unknownOption.parent().length) {
                            self.updateUnknownOption(value);
                        } else {
                            self.renderUnknownOption(value);
                        }
                    }
                };
                self.addOption = function (value, element) {
                    if (element[0].nodeType === NODE_TYPE_COMMENT) return;
                    assertNotHasOwnProperty(value, '"option value"');
                    if (value === "") {
                        self.hasEmptyOption = true;
                        self.emptyOption = element;
                    }
                    var count = optionsMap.get(value) || 0;
                    optionsMap.set(value, count + 1);
                    scheduleRender();
                };
                self.removeOption = function (value) {
                    var count = optionsMap.get(value);
                    if (count) {
                        if (count === 1) {
                            optionsMap.delete(value);
                            if (value === "") {
                                self.hasEmptyOption = false;
                                self.emptyOption = undefined;
                            }
                        } else {
                            optionsMap.set(value, count - 1);
                        }
                    }
                };
                self.hasOption = function (value) {
                    return !!optionsMap.get(value);
                };
                var renderScheduled = false;
                function scheduleRender() {
                    if (renderScheduled) return;
                    renderScheduled = true;
                    $scope.$$postDigest(function () {
                        renderScheduled = false;
                        self.ngModelCtrl.$render();
                    });
                }
                var updateScheduled = false;
                function scheduleViewValueUpdate(renderAfter) {
                    if (updateScheduled) return;
                    updateScheduled = true;
                    $scope.$$postDigest(function () {
                        if ($scope.$$destroyed) return;
                        updateScheduled = false;
                        self.ngModelCtrl.$setViewValue(self.readValue());
                        if (renderAfter) self.ngModelCtrl.$render();
                    });
                }
                self.registerOption = function (optionScope, optionElement, optionAttrs, interpolateValueFn, interpolateTextFn) {
                    if (optionAttrs.$attr.ngValue) {
                        var oldVal,
                            hashedVal = NaN;
                        optionAttrs.$observe("value", function valueAttributeObserveAction(newVal) {
                            var removal;
                            var previouslySelected = optionElement.prop("selected");
                            if (isDefined(hashedVal)) {
                                self.removeOption(oldVal);
                                delete self.selectValueMap[hashedVal];
                                removal = true;
                            }
                            hashedVal = hashKey(newVal);
                            oldVal = newVal;
                            self.selectValueMap[hashedVal] = newVal;
                            self.addOption(newVal, optionElement);
                            optionElement.attr("value", hashedVal);
                            if (removal && previouslySelected) {
                                scheduleViewValueUpdate();
                            }
                        });
                    } else if (interpolateValueFn) {
                        optionAttrs.$observe("value", function valueAttributeObserveAction(newVal) {
                            self.readValue();
                            var removal;
                            var previouslySelected = optionElement.prop("selected");
                            if (isDefined(oldVal)) {
                                self.removeOption(oldVal);
                                removal = true;
                            }
                            oldVal = newVal;
                            self.addOption(newVal, optionElement);
                            if (removal && previouslySelected) {
                                scheduleViewValueUpdate();
                            }
                        });
                    } else if (interpolateTextFn) {
                        optionScope.$watch(interpolateTextFn, function interpolateWatchAction(newVal, oldVal) {
                            optionAttrs.$set("value", newVal);
                            var previouslySelected = optionElement.prop("selected");
                            if (oldVal !== newVal) {
                                self.removeOption(oldVal);
                            }
                            self.addOption(newVal, optionElement);
                            if (oldVal && previouslySelected) {
                                scheduleViewValueUpdate();
                            }
                        });
                    } else {
                        self.addOption(optionAttrs.value, optionElement);
                    }
                    optionAttrs.$observe("disabled", function (newVal) {
                        if (newVal === "true" || (newVal && optionElement.prop("selected"))) {
                            if (self.multiple) {
                                scheduleViewValueUpdate(true);
                            } else {
                                self.ngModelCtrl.$setViewValue(null);
                                self.ngModelCtrl.$render();
                            }
                        }
                    });
                    optionElement.on("$destroy", function () {
                        var currentValue = self.readValue();
                        var removeValue = optionAttrs.value;
                        self.removeOption(removeValue);
                        scheduleRender();
                        if ((self.multiple && currentValue && currentValue.indexOf(removeValue) !== -1) || currentValue === removeValue) {
                            scheduleViewValueUpdate(true);
                        }
                    });
                };
            },
        ];
        var selectDirective = function () {
            return { restrict: "E", require: ["select", "?ngModel"], controller: SelectController, priority: 1, link: { pre: selectPreLink, post: selectPostLink } };
            function selectPreLink(scope, element, attr, ctrls) {
                var selectCtrl = ctrls[0];
                var ngModelCtrl = ctrls[1];
                if (!ngModelCtrl) {
                    selectCtrl.registerOption = noop;
                    return;
                }
                selectCtrl.ngModelCtrl = ngModelCtrl;
                element.on("change", function () {
                    selectCtrl.removeUnknownOption();
                    scope.$apply(function () {
                        ngModelCtrl.$setViewValue(selectCtrl.readValue());
                    });
                });
                if (attr.multiple) {
                    selectCtrl.multiple = true;
                    selectCtrl.readValue = function readMultipleValue() {
                        var array = [];
                        forEach(element.find("option"), function (option) {
                            if (option.selected && !option.disabled) {
                                var val = option.value;
                                array.push(val in selectCtrl.selectValueMap ? selectCtrl.selectValueMap[val] : val);
                            }
                        });
                        return array;
                    };
                    selectCtrl.writeValue = function writeMultipleValue(value) {
                        forEach(element.find("option"), function (option) {
                            var shouldBeSelected = !!value && (includes(value, option.value) || includes(value, selectCtrl.selectValueMap[option.value]));
                            var currentlySelected = option.selected;
                            if (shouldBeSelected !== currentlySelected) {
                                setOptionSelectedStatus(jqLite(option), shouldBeSelected);
                            }
                        });
                    };
                    var lastView,
                        lastViewRef = NaN;
                    scope.$watch(function selectMultipleWatch() {
                        if (lastViewRef === ngModelCtrl.$viewValue && !equals(lastView, ngModelCtrl.$viewValue)) {
                            lastView = shallowCopy(ngModelCtrl.$viewValue);
                            ngModelCtrl.$render();
                        }
                        lastViewRef = ngModelCtrl.$viewValue;
                    });
                    ngModelCtrl.$isEmpty = function (value) {
                        return !value || value.length === 0;
                    };
                }
            }
            function selectPostLink(scope, element, attrs, ctrls) {
                var ngModelCtrl = ctrls[1];
                if (!ngModelCtrl) return;
                var selectCtrl = ctrls[0];
                ngModelCtrl.$render = function () {
                    selectCtrl.writeValue(ngModelCtrl.$viewValue);
                };
            }
        };
        var optionDirective = [
            "$interpolate",
            function ($interpolate) {
                return {
                    restrict: "E",
                    priority: 100,
                    compile: function (element, attr) {
                        var interpolateValueFn, interpolateTextFn;
                        if (isDefined(attr.ngValue)) {
                        } else if (isDefined(attr.value)) {
                            interpolateValueFn = $interpolate(attr.value, true);
                        } else {
                            interpolateTextFn = $interpolate(element.text(), true);
                            if (!interpolateTextFn) {
                                attr.$set("value", element.text());
                            }
                        }
                        return function (scope, element, attr) {
                            var selectCtrlName = "$selectController",
                                parent = element.parent(),
                                selectCtrl = parent.data(selectCtrlName) || parent.parent().data(selectCtrlName);
                            if (selectCtrl) {
                                selectCtrl.registerOption(scope, element, attr, interpolateValueFn, interpolateTextFn);
                            }
                        };
                    },
                };
            },
        ];
        var requiredDirective = function () {
            return {
                restrict: "A",
                require: "?ngModel",
                link: function (scope, elm, attr, ctrl) {
                    if (!ctrl) return;
                    attr.required = true;
                    ctrl.$validators.required = function (modelValue, viewValue) {
                        return !attr.required || !ctrl.$isEmpty(viewValue);
                    };
                    attr.$observe("required", function () {
                        ctrl.$validate();
                    });
                },
            };
        };
        var patternDirective = function () {
            return {
                restrict: "A",
                require: "?ngModel",
                link: function (scope, elm, attr, ctrl) {
                    if (!ctrl) return;
                    var regexp,
                        patternExp = attr.ngPattern || attr.pattern;
                    attr.$observe("pattern", function (regex) {
                        if (isString(regex) && regex.length > 0) {
                            regex = new RegExp("^" + regex + "$");
                        }
                        if (regex && !regex.test) {
                            throw minErr("ngPattern")("noregexp", "Expected {0} to be a RegExp but was {1}. Element: {2}", patternExp, regex, startingTag(elm));
                        }
                        regexp = regex || undefined;
                        ctrl.$validate();
                    });
                    ctrl.$validators.pattern = function (modelValue, viewValue) {
                        return ctrl.$isEmpty(viewValue) || isUndefined(regexp) || regexp.test(viewValue);
                    };
                },
            };
        };
        var maxlengthDirective = function () {
            return {
                restrict: "A",
                require: "?ngModel",
                link: function (scope, elm, attr, ctrl) {
                    if (!ctrl) return;
                    var maxlength = -1;
                    attr.$observe("maxlength", function (value) {
                        var intVal = toInt(value);
                        maxlength = isNumberNaN(intVal) ? -1 : intVal;
                        ctrl.$validate();
                    });
                    ctrl.$validators.maxlength = function (modelValue, viewValue) {
                        return maxlength < 0 || ctrl.$isEmpty(viewValue) || viewValue.length <= maxlength;
                    };
                },
            };
        };
        var minlengthDirective = function () {
            return {
                restrict: "A",
                require: "?ngModel",
                link: function (scope, elm, attr, ctrl) {
                    if (!ctrl) return;
                    var minlength = 0;
                    attr.$observe("minlength", function (value) {
                        minlength = toInt(value) || 0;
                        ctrl.$validate();
                    });
                    ctrl.$validators.minlength = function (modelValue, viewValue) {
                        return ctrl.$isEmpty(viewValue) || viewValue.length >= minlength;
                    };
                },
            };
        };
        if (window.angular.bootstrap) {
            if (window.console) {
                console.log("WARNING: Tried to load angular more than once.");
            }
            return;
        }
        bindJQuery();
        publishExternalAPI(angular);
        angular.module(
            "ngLocale",
            [],
            [
                "$provide",
                function ($provide) {
                    var PLURAL_CATEGORY = { ZERO: "zero", ONE: "one", TWO: "two", FEW: "few", MANY: "many", OTHER: "other" };
                    function getDecimals(n) {
                        n = n + "";
                        var i = n.indexOf(".");
                        return i == -1 ? 0 : n.length - i - 1;
                    }
                    function getVF(n, opt_precision) {
                        var v = opt_precision;
                        if (undefined === v) {
                            v = Math.min(getDecimals(n), 3);
                        }
                        var base = Math.pow(10, v);
                        var f = ((n * base) | 0) % base;
                        return { v: v, f: f };
                    }
                    $provide.value("$locale", {
                        DATETIME_FORMATS: {
                            AMPMS: ["AM", "PM"],
                            DAY: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
                            ERANAMES: ["Before Christ", "Anno Domini"],
                            ERAS: ["BC", "AD"],
                            FIRSTDAYOFWEEK: 6,
                            MONTH: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
                            SHORTDAY: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
                            SHORTMONTH: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
                            STANDALONEMONTH: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
                            WEEKENDRANGE: [5, 6],
                            fullDate: "EEEE, MMMM d, y",
                            longDate: "MMMM d, y",
                            medium: "MMM d, y h:mm:ss a",
                            mediumDate: "MMM d, y",
                            mediumTime: "h:mm:ss a",
                            short: "M/d/yy h:mm a",
                            shortDate: "M/d/yy",
                            shortTime: "h:mm a",
                        },
                        NUMBER_FORMATS: {
                            CURRENCY_SYM: "$",
                            DECIMAL_SEP: ".",
                            GROUP_SEP: ",",
                            PATTERNS: [
                                { gSize: 3, lgSize: 3, maxFrac: 3, minFrac: 0, minInt: 1, negPre: "-", negSuf: "", posPre: "", posSuf: "" },
                                { gSize: 3, lgSize: 3, maxFrac: 2, minFrac: 2, minInt: 1, negPre: "-Â¤", negSuf: "", posPre: "Â¤", posSuf: "" },
                            ],
                        },
                        id: "en-us",
                        localeID: "en_US",
                        pluralCat: function (n, opt_precision) {
                            var i = n | 0;
                            var vf = getVF(n, opt_precision);
                            if (i == 1 && vf.v == 0) {
                                return PLURAL_CATEGORY.ONE;
                            }
                            return PLURAL_CATEGORY.OTHER;
                        },
                    });
                },
            ]
        );
        jqLite(function () {
            angularInit(window.document, bootstrap);
        });
    })(window);
    !window.angular.$$csp().noInlineStyle &&
        window.angular
            .element(document.head)
            .prepend(
                '<style type="text/css">@charset "UTF-8";[ng\\:cloak],[ng-cloak],[data-ng-cloak],[x-ng-cloak],.ng-cloak,.x-ng-cloak,.ng-hide:not(.ng-hide-animate){display:none !important;}ng\\:form{display:block;}.ng-animate-shim{visibility:hidden;}.ng-anchor{position:absolute;}</style>'
            );
    var index = angular;
    var angularUiRouter = createCommonjsModule(function (module, exports) {
        if ("object" !== "undefined" && "object" !== "undefined" && module.exports === exports) {
            module.exports = "ui.router";
        }
        (function (window, angular, undefined) {
            "use strict";
            var isDefined = angular.isDefined,
                isFunction = angular.isFunction,
                isString = angular.isString,
                isObject = angular.isObject,
                isArray = angular.isArray,
                forEach = angular.forEach,
                extend = angular.extend,
                copy = angular.copy,
                toJson = angular.toJson;
            function inherit(parent, extra) {
                return extend(new (extend(function () { }, { prototype: parent }))(), extra);
            }
            function merge(dst) {
                forEach(arguments, function (obj) {
                    if (obj !== dst) {
                        forEach(obj, function (value, key) {
                            if (!dst.hasOwnProperty(key)) dst[key] = value;
                        });
                    }
                });
                return dst;
            }
            function ancestors(first, second) {
                var path = [];
                for (var n in first.path) {
                    if (first.path[n] !== second.path[n]) break;
                    path.push(first.path[n]);
                }
                return path;
            }
            function objectKeys(object) {
                if (Object.keys) {
                    return Object.keys(object);
                }
                var result = [];
                forEach(object, function (val, key) {
                    result.push(key);
                });
                return result;
            }
            function indexOf(array, value) {
                if (Array.prototype.indexOf) {
                    return array.indexOf(value, Number(arguments[2]) || 0);
                }
                var len = array.length >>> 0,
                    from = Number(arguments[2]) || 0;
                from = from < 0 ? Math.ceil(from) : Math.floor(from);
                if (from < 0) from += len;
                for (; from < len; from++) {
                    if (from in array && array[from] === value) return from;
                }
                return -1;
            }
            function inheritParams(currentParams, newParams, $current, $to) {
                var parents = ancestors($current, $to),
                    parentParams,
                    inherited = {},
                    inheritList = [];
                for (var i in parents) {
                    if (!parents[i] || !parents[i].params) continue;
                    parentParams = objectKeys(parents[i].params);
                    if (!parentParams.length) continue;
                    for (var j in parentParams) {
                        if (indexOf(inheritList, parentParams[j]) >= 0) continue;
                        inheritList.push(parentParams[j]);
                        inherited[parentParams[j]] = currentParams[parentParams[j]];
                    }
                }
                return extend({}, inherited, newParams);
            }
            function equalForKeys(a, b, keys) {
                if (!keys) {
                    keys = [];
                    for (var n in a) keys.push(n);
                }
                for (var i = 0; i < keys.length; i++) {
                    var k = keys[i];
                    if (a[k] != b[k]) return false;
                }
                return true;
            }
            function filterByKeys(keys, values) {
                var filtered = {};
                forEach(keys, function (name) {
                    filtered[name] = values[name];
                });
                return filtered;
            }
            function pick(obj) {
                var copy = {};
                var keys = Array.prototype.concat.apply(Array.prototype, Array.prototype.slice.call(arguments, 1));
                forEach(keys, function (key) {
                    if (key in obj) copy[key] = obj[key];
                });
                return copy;
            }
            function omit(obj) {
                var copy = {};
                var keys = Array.prototype.concat.apply(Array.prototype, Array.prototype.slice.call(arguments, 1));
                for (var key in obj) {
                    if (indexOf(keys, key) == -1) copy[key] = obj[key];
                }
                return copy;
            }
            function filter(collection, callback) {
                var array = isArray(collection);
                var result = array ? [] : {};
                forEach(collection, function (val, i) {
                    if (callback(val, i)) {
                        result[array ? result.length : i] = val;
                    }
                });
                return result;
            }
            function map(collection, callback) {
                var result = isArray(collection) ? [] : {};
                forEach(collection, function (val, i) {
                    result[i] = callback(val, i);
                });
                return result;
            }
            function silenceUncaughtInPromise(promise) {
                return promise.then(undefined, function () { }) && promise;
            }
            angular.module("ui.router.util", ["ng"]);
            angular.module("ui.router.router", ["ui.router.util"]);
            angular.module("ui.router.state", ["ui.router.router", "ui.router.util"]);
            angular.module("ui.router", ["ui.router.state"]);
            angular.module("ui.router.compat", ["ui.router"]);
            $Resolve.$inject = ["$q", "$injector"];
            function $Resolve($q, $injector) {
                var VISIT_IN_PROGRESS = 1,
                    VISIT_DONE = 2,
                    NOTHING = {},
                    NO_DEPENDENCIES = [],
                    NO_LOCALS = NOTHING,
                    NO_PARENT = extend($q.when(NOTHING), { $$promises: NOTHING, $$values: NOTHING });
                this.study = function (invocables) {
                    if (!isObject(invocables)) throw new Error("'invocables' must be an object");
                    var invocableKeys = objectKeys(invocables || {});
                    var plan = [],
                        cycle = [],
                        visited = {};
                    function visit(value, key) {
                        if (visited[key] === VISIT_DONE) return;
                        cycle.push(key);
                        if (visited[key] === VISIT_IN_PROGRESS) {
                            cycle.splice(0, indexOf(cycle, key));
                            throw new Error("Cyclic dependency: " + cycle.join(" -> "));
                        }
                        visited[key] = VISIT_IN_PROGRESS;
                        if (isString(value)) {
                            plan.push(
                                key,
                                [
                                    function () {
                                        return $injector.get(value);
                                    },
                                ],
                                NO_DEPENDENCIES
                            );
                        } else {
                            var params = $injector.annotate(value);
                            forEach(params, function (param) {
                                if (param !== key && invocables.hasOwnProperty(param)) visit(invocables[param], param);
                            });
                            plan.push(key, value, params);
                        }
                        cycle.pop();
                        visited[key] = VISIT_DONE;
                    }
                    forEach(invocables, visit);
                    invocables = cycle = visited = null;
                    function isResolve(value) {
                        return isObject(value) && value.then && value.$$promises;
                    }
                    return function (locals, parent, self) {
                        if (isResolve(locals) && self === undefined) {
                            self = parent;
                            parent = locals;
                            locals = null;
                        }
                        if (!locals) locals = NO_LOCALS;
                        else if (!isObject(locals)) {
                            throw new Error("'locals' must be an object");
                        }
                        if (!parent) parent = NO_PARENT;
                        else if (!isResolve(parent)) {
                            throw new Error("'parent' must be a promise returned by $resolve.resolve()");
                        }
                        var resolution = $q.defer(),
                            result = silenceUncaughtInPromise(resolution.promise),
                            promises = (result.$$promises = {}),
                            values = extend({}, locals),
                            wait = 1 + plan.length / 3,
                            merged = false;
                        silenceUncaughtInPromise(result);
                        function done() {
                            if (!--wait) {
                                if (!merged) merge(values, parent.$$values);
                                result.$$values = values;
                                result.$$promises = result.$$promises || true;
                                delete result.$$inheritedValues;
                                resolution.resolve(values);
                            }
                        }
                        function fail(reason) {
                            result.$$failure = reason;
                            resolution.reject(reason);
                        }
                        if (isDefined(parent.$$failure)) {
                            fail(parent.$$failure);
                            return result;
                        }
                        if (parent.$$inheritedValues) {
                            merge(values, omit(parent.$$inheritedValues, invocableKeys));
                        }
                        extend(promises, parent.$$promises);
                        if (parent.$$values) {
                            merged = merge(values, omit(parent.$$values, invocableKeys));
                            result.$$inheritedValues = omit(parent.$$values, invocableKeys);
                            done();
                        } else {
                            if (parent.$$inheritedValues) {
                                result.$$inheritedValues = omit(parent.$$inheritedValues, invocableKeys);
                            }
                            parent.then(done, fail);
                        }
                        for (var i = 0, ii = plan.length; i < ii; i += 3) {
                            if (locals.hasOwnProperty(plan[i])) done();
                            else invoke(plan[i], plan[i + 1], plan[i + 2]);
                        }
                        function invoke(key, invocable, params) {
                            var invocation = $q.defer(),
                                waitParams = 0;
                            function onfailure(reason) {
                                invocation.reject(reason);
                                fail(reason);
                            }
                            forEach(params, function (dep) {
                                if (promises.hasOwnProperty(dep) && !locals.hasOwnProperty(dep)) {
                                    waitParams++;
                                    promises[dep].then(function (result) {
                                        values[dep] = result;
                                        if (!--waitParams) proceed();
                                    }, onfailure);
                                }
                            });
                            if (!waitParams) proceed();
                            function proceed() {
                                if (isDefined(result.$$failure)) return;
                                try {
                                    invocation.resolve($injector.invoke(invocable, self, values));
                                    invocation.promise.then(function (result) {
                                        values[key] = result;
                                        done();
                                    }, onfailure);
                                } catch (e) {
                                    onfailure(e);
                                }
                            }
                            promises[key] = silenceUncaughtInPromise(invocation.promise);
                        }
                        return result;
                    };
                };
                this.resolve = function (invocables, locals, parent, self) {
                    return this.study(invocables)(locals, parent, self);
                };
            }
            angular.module("ui.router.util").service("$resolve", $Resolve);
            function TemplateFactoryProvider() {
                var shouldUnsafelyUseHttp = angular.version.minor < 3;
                this.shouldUnsafelyUseHttp = function (value) {
                    shouldUnsafelyUseHttp = !!value;
                };
                this.$get = [
                    "$http",
                    "$templateCache",
                    "$injector",
                    function ($http, $templateCache, $injector) {
                        return new TemplateFactory($http, $templateCache, $injector, shouldUnsafelyUseHttp);
                    },
                ];
            }
            function TemplateFactory($http, $templateCache, $injector, shouldUnsafelyUseHttp) {
                this.fromConfig = function (config, params, locals) {
                    return isDefined(config.template)
                        ? this.fromString(config.template, params)
                        : isDefined(config.templateUrl)
                            ? this.fromUrl(config.templateUrl, params)
                            : isDefined(config.templateProvider)
                                ? this.fromProvider(config.templateProvider, params, locals)
                                : null;
                };
                this.fromString = function (template, params) {
                    return isFunction(template) ? template(params) : template;
                };
                this.fromUrl = function (url, params) {
                    if (isFunction(url)) url = url(params);
                    if (url == null) return null;
                    else {
                        if (!shouldUnsafelyUseHttp) {
                            return $injector.get("$templateRequest")(url);
                        } else {
                            return $http.get(url, { cache: $templateCache, headers: { Accept: "text/html" } }).then(function (response) {
                                return response.data;
                            });
                        }
                    }
                };
                this.fromProvider = function (provider, params, locals) {
                    return $injector.invoke(provider, null, locals || { params: params });
                };
            }
            angular.module("ui.router.util").provider("$templateFactory", TemplateFactoryProvider);
            var $$UMFP;
            function UrlMatcher(pattern, config, parentMatcher) {
                config = extend({ params: {} }, isObject(config) ? config : {});
                var placeholder = /([:*])([\w\[\]]+)|\{([\w\[\]]+)(?:\:\s*((?:[^{}\\]+|\\.|\{(?:[^{}\\]+|\\.)*\})+))?\}/g,
                    searchPlaceholder = /([:]?)([\w\[\].-]+)|\{([\w\[\].-]+)(?:\:\s*((?:[^{}\\]+|\\.|\{(?:[^{}\\]+|\\.)*\})+))?\}/g,
                    compiled = "^",
                    last = 0,
                    m,
                    segments = (this.segments = []),
                    parentParams = parentMatcher ? parentMatcher.params : {},
                    params = (this.params = parentMatcher ? parentMatcher.params.$$new() : new $$UMFP.ParamSet()),
                    paramNames = [];
                function addParameter(id, type, config, location) {
                    paramNames.push(id);
                    if (parentParams[id]) return parentParams[id];
                    if (!/^\w+([-.]+\w+)*(?:\[\])?$/.test(id)) throw new Error("Invalid parameter name '" + id + "' in pattern '" + pattern + "'");
                    if (params[id]) throw new Error("Duplicate parameter name '" + id + "' in pattern '" + pattern + "'");
                    params[id] = new $$UMFP.Param(id, type, config, location);
                    return params[id];
                }
                function quoteRegExp(string, pattern, squash, optional) {
                    var surroundPattern = ["", ""],
                        result = string.replace(/[\\\[\]\^$*+?.()|{}]/g, "\\$&");
                    if (!pattern) return result;
                    switch (squash) {
                        case false:
                            surroundPattern = ["(", ")" + (optional ? "?" : "")];
                            break;
                        case true:
                            result = result.replace(/\/$/, "");
                            surroundPattern = ["(?:/(", ")|/)?"];
                            break;
                        default:
                            surroundPattern = ["(" + squash + "|", ")?"];
                            break;
                    }
                    return result + surroundPattern[0] + pattern + surroundPattern[1];
                }
                this.source = pattern;
                function matchDetails(m, isSearch) {
                    var id, regexp, segment, type, cfg, arrayMode;
                    id = m[2] || m[3];
                    cfg = config.params[id];
                    segment = pattern.substring(last, m.index);
                    regexp = isSearch ? m[4] : m[4] || (m[1] == "*" ? ".*" : null);
                    if (regexp) {
                        type = $$UMFP.type(regexp) || inherit($$UMFP.type("string"), { pattern: new RegExp(regexp, config.caseInsensitive ? "i" : undefined) });
                    }
                    return { id: id, regexp: regexp, segment: segment, type: type, cfg: cfg };
                }
                var p, param, segment;
                while ((m = placeholder.exec(pattern))) {
                    p = matchDetails(m, false);
                    if (p.segment.indexOf("?") >= 0) break;
                    param = addParameter(p.id, p.type, p.cfg, "path");
                    compiled += quoteRegExp(p.segment, param.type.pattern.source, param.squash, param.isOptional);
                    segments.push(p.segment);
                    last = placeholder.lastIndex;
                }
                segment = pattern.substring(last);
                var i = segment.indexOf("?");
                if (i >= 0) {
                    var search = (this.sourceSearch = segment.substring(i));
                    segment = segment.substring(0, i);
                    this.sourcePath = pattern.substring(0, last + i);
                    if (search.length > 0) {
                        last = 0;
                        while ((m = searchPlaceholder.exec(search))) {
                            p = matchDetails(m, true);
                            param = addParameter(p.id, p.type, p.cfg, "search");
                            last = placeholder.lastIndex;
                        }
                    }
                } else {
                    this.sourcePath = pattern;
                    this.sourceSearch = "";
                }
                compiled += quoteRegExp(segment) + (config.strict === false ? "/?" : "") + "$";
                segments.push(segment);
                this.regexp = new RegExp(compiled, config.caseInsensitive ? "i" : undefined);
                this.prefix = segments[0];
                this.$$paramNames = paramNames;
            }
            UrlMatcher.prototype.concat = function (pattern, config) {
                var defaultConfig = { caseInsensitive: $$UMFP.caseInsensitive(), strict: $$UMFP.strictMode(), squash: $$UMFP.defaultSquashPolicy() };
                return new UrlMatcher(this.sourcePath + pattern + this.sourceSearch, extend(defaultConfig, config), this);
            };
            UrlMatcher.prototype.toString = function () {
                return this.source;
            };
            UrlMatcher.prototype.exec = function (path, searchParams) {
                var m = this.regexp.exec(path);
                if (!m) return null;
                searchParams = searchParams || {};
                var paramNames = this.parameters(),
                    nTotal = paramNames.length,
                    nPath = this.segments.length - 1,
                    values = {},
                    i,
                    j,
                    cfg,
                    paramName;
                if (nPath !== m.length - 1) throw new Error("Unbalanced capture group in route '" + this.source + "'");
                function decodePathArray(string) {
                    function reverseString(str) {
                        return str.split("").reverse().join("");
                    }
                    function unquoteDashes(str) {
                        return str.replace(/\\-/g, "-");
                    }
                    var split = reverseString(string).split(/-(?!\\)/);
                    var allReversed = map(split, reverseString);
                    return map(allReversed, unquoteDashes).reverse();
                }
                var param, paramVal;
                for (i = 0; i < nPath; i++) {
                    paramName = paramNames[i];
                    param = this.params[paramName];
                    paramVal = m[i + 1];
                    for (j = 0; j < param.replace.length; j++) {
                        if (param.replace[j].from === paramVal) paramVal = param.replace[j].to;
                    }
                    if (paramVal && param.array === true) paramVal = decodePathArray(paramVal);
                    if (isDefined(paramVal)) paramVal = param.type.decode(paramVal);
                    values[paramName] = param.value(paramVal);
                }
                for (; i < nTotal; i++) {
                    paramName = paramNames[i];
                    values[paramName] = this.params[paramName].value(searchParams[paramName]);
                    param = this.params[paramName];
                    paramVal = searchParams[paramName];
                    for (j = 0; j < param.replace.length; j++) {
                        if (param.replace[j].from === paramVal) paramVal = param.replace[j].to;
                    }
                    if (isDefined(paramVal)) paramVal = param.type.decode(paramVal);
                    values[paramName] = param.value(paramVal);
                }
                return values;
            };
            UrlMatcher.prototype.parameters = function (param) {
                if (!isDefined(param)) return this.$$paramNames;
                return this.params[param] || null;
            };
            UrlMatcher.prototype.validates = function (params) {
                return this.params.$$validates(params);
            };
            UrlMatcher.prototype.format = function (values) {
                values = values || {};
                var segments = this.segments,
                    params = this.parameters(),
                    paramset = this.params;
                if (!this.validates(values)) return null;
                var i,
                    search = false,
                    nPath = segments.length - 1,
                    nTotal = params.length,
                    result = segments[0];
                function encodeDashes(str) {
                    return encodeURIComponent(str).replace(/-/g, function (c) {
                        return "%5C%" + c.charCodeAt(0).toString(16).toUpperCase();
                    });
                }
                for (i = 0; i < nTotal; i++) {
                    var isPathParam = i < nPath;
                    var name = params[i],
                        param = paramset[name],
                        value = param.value(values[name]);
                    var isDefaultValue = param.isOptional && param.type.equals(param.value(), value);
                    var squash = isDefaultValue ? param.squash : false;
                    var encoded = param.type.encode(value);
                    if (isPathParam) {
                        var nextSegment = segments[i + 1];
                        var isFinalPathParam = i + 1 === nPath;
                        if (squash === false) {
                            if (encoded != null) {
                                if (isArray(encoded)) {
                                    result += map(encoded, encodeDashes).join("-");
                                } else {
                                    result += encodeURIComponent(encoded);
                                }
                            }
                            result += nextSegment;
                        } else if (squash === true) {
                            var capture = result.match(/\/$/) ? /\/?(.*)/ : /(.*)/;
                            result += nextSegment.match(capture)[1];
                        } else if (isString(squash)) {
                            result += squash + nextSegment;
                        }
                        if (isFinalPathParam && param.squash === true && result.slice(-1) === "/") result = result.slice(0, -1);
                    } else {
                        if (encoded == null || (isDefaultValue && squash !== false)) continue;
                        if (!isArray(encoded)) encoded = [encoded];
                        if (encoded.length === 0) continue;
                        encoded = map(encoded, encodeURIComponent).join("&" + name + "=");
                        result += (search ? "&" : "?") + (name + "=" + encoded);
                        search = true;
                    }
                }
                return result;
            };
            function Type(config) {
                extend(this, config);
            }
            Type.prototype.is = function (val, key) {
                return true;
            };
            Type.prototype.encode = function (val, key) {
                return val;
            };
            Type.prototype.decode = function (val, key) {
                return val;
            };
            Type.prototype.equals = function (a, b) {
                return a == b;
            };
            Type.prototype.$subPattern = function () {
                var sub = this.pattern.toString();
                return sub.substr(1, sub.length - 2);
            };
            Type.prototype.pattern = /.*/;
            Type.prototype.toString = function () {
                return "{Type:" + this.name + "}";
            };
            Type.prototype.$normalize = function (val) {
                return this.is(val) ? val : this.decode(val);
            };
            Type.prototype.$asArray = function (mode, isSearch) {
                if (!mode) return this;
                if (mode === "auto" && !isSearch) throw new Error("'auto' array mode is for query parameters only");
                function ArrayType(type, mode) {
                    function bindTo(type, callbackName) {
                        return function () {
                            return type[callbackName].apply(type, arguments);
                        };
                    }
                    function arrayWrap(val) {
                        return isArray(val) ? val : isDefined(val) ? [val] : [];
                    }
                    function arrayUnwrap(val) {
                        switch (val.length) {
                            case 0:
                                return undefined;
                            case 1:
                                return mode === "auto" ? val[0] : val;
                            default:
                                return val;
                        }
                    }
                    function falsey(val) {
                        return !val;
                    }
                    function arrayHandler(callback, allTruthyMode) {
                        return function handleArray(val) {
                            if (isArray(val) && val.length === 0) return val;
                            val = arrayWrap(val);
                            var result = map(val, callback);
                            if (allTruthyMode === true) return filter(result, falsey).length === 0;
                            return arrayUnwrap(result);
                        };
                    }
                    function arrayEqualsHandler(callback) {
                        return function handleArray(val1, val2) {
                            var left = arrayWrap(val1),
                                right = arrayWrap(val2);
                            if (left.length !== right.length) return false;
                            for (var i = 0; i < left.length; i++) {
                                if (!callback(left[i], right[i])) return false;
                            }
                            return true;
                        };
                    }
                    this.encode = arrayHandler(bindTo(type, "encode"));
                    this.decode = arrayHandler(bindTo(type, "decode"));
                    this.is = arrayHandler(bindTo(type, "is"), true);
                    this.equals = arrayEqualsHandler(bindTo(type, "equals"));
                    this.pattern = type.pattern;
                    this.$normalize = arrayHandler(bindTo(type, "$normalize"));
                    this.name = type.name;
                    this.$arrayMode = mode;
                }
                return new ArrayType(this, mode);
            };
            function $UrlMatcherFactory() {
                $$UMFP = this;
                var isCaseInsensitive = false,
                    isStrictMode = true,
                    defaultSquashPolicy = false;
                function valToString(val) {
                    return val != null
                        ? val.toString().replace(/(~|\/)/g, function (m) {
                            return { "~": "~~", "/": "~2F" }[m];
                        })
                        : val;
                }
                function valFromString(val) {
                    return val != null
                        ? val.toString().replace(/(~~|~2F)/g, function (m) {
                            return { "~~": "~", "~2F": "/" }[m];
                        })
                        : val;
                }
                var $types = {},
                    enqueue = true,
                    typeQueue = [],
                    injector,
                    defaultTypes = {
                        string: {
                            encode: valToString,
                            decode: valFromString,
                            is: function (val) {
                                return val == null || !isDefined(val) || typeof val === "string";
                            },
                            pattern: /[^\/]*/,
                        },
                        int: {
                            encode: valToString,
                            decode: function (val) {
                                return parseInt(val, 10);
                            },
                            is: function (val) {
                                return val !== undefined && val !== null && this.decode(val.toString()) === val;
                            },
                            pattern: /\d+/,
                        },
                        bool: {
                            encode: function (val) {
                                return val ? 1 : 0;
                            },
                            decode: function (val) {
                                return parseInt(val, 10) !== 0;
                            },
                            is: function (val) {
                                return val === true || val === false;
                            },
                            pattern: /0|1/,
                        },
                        date: {
                            encode: function (val) {
                                if (!this.is(val)) return undefined;
                                return [val.getFullYear(), ("0" + (val.getMonth() + 1)).slice(-2), ("0" + val.getDate()).slice(-2)].join("-");
                            },
                            decode: function (val) {
                                if (this.is(val)) return val;
                                var match = this.capture.exec(val);
                                return match ? new Date(match[1], match[2] - 1, match[3]) : undefined;
                            },
                            is: function (val) {
                                return val instanceof Date && !isNaN(val.valueOf());
                            },
                            equals: function (a, b) {
                                return this.is(a) && this.is(b) && a.toISOString() === b.toISOString();
                            },
                            pattern: /[0-9]{4}-(?:0[1-9]|1[0-2])-(?:0[1-9]|[1-2][0-9]|3[0-1])/,
                            capture: /([0-9]{4})-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])/,
                        },
                        json: { encode: angular.toJson, decode: angular.fromJson, is: angular.isObject, equals: angular.equals, pattern: /[^\/]*/ },
                        any: { encode: angular.identity, decode: angular.identity, equals: angular.equals, pattern: /.*/ },
                    };
                function getDefaultConfig() {
                    return { strict: isStrictMode, caseInsensitive: isCaseInsensitive };
                }
                function isInjectable(value) {
                    return isFunction(value) || (isArray(value) && isFunction(value[value.length - 1]));
                }
                $UrlMatcherFactory.$$getDefaultValue = function (config) {
                    if (!isInjectable(config.value)) return config.value;
                    if (!injector) throw new Error("Injectable functions cannot be called at configuration time");
                    return injector.invoke(config.value);
                };
                this.caseInsensitive = function (value) {
                    if (isDefined(value)) isCaseInsensitive = value;
                    return isCaseInsensitive;
                };
                this.strictMode = function (value) {
                    if (isDefined(value)) isStrictMode = value;
                    return isStrictMode;
                };
                this.defaultSquashPolicy = function (value) {
                    if (!isDefined(value)) return defaultSquashPolicy;
                    if (value !== true && value !== false && !isString(value)) throw new Error("Invalid squash policy: " + value + ". Valid policies: false, true, arbitrary-string");
                    defaultSquashPolicy = value;
                    return value;
                };
                this.compile = function (pattern, config) {
                    return new UrlMatcher(pattern, extend(getDefaultConfig(), config));
                };
                this.isMatcher = function (o) {
                    if (!isObject(o)) return false;
                    var result = true;
                    forEach(UrlMatcher.prototype, function (val, name) {
                        if (isFunction(val)) {
                            result = result && isDefined(o[name]) && isFunction(o[name]);
                        }
                    });
                    return result;
                };
                this.type = function (name, definition, definitionFn) {
                    if (!isDefined(definition)) return $types[name];
                    if ($types.hasOwnProperty(name)) throw new Error("A type named '" + name + "' has already been defined.");
                    $types[name] = new Type(extend({ name: name }, definition));
                    if (definitionFn) {
                        typeQueue.push({ name: name, def: definitionFn });
                        if (!enqueue) flushTypeQueue();
                    }
                    return this;
                };
                function flushTypeQueue() {
                    while (typeQueue.length) {
                        var type = typeQueue.shift();
                        if (type.pattern) throw new Error("You cannot override a type's .pattern at runtime.");
                        angular.extend($types[type.name], injector.invoke(type.def));
                    }
                }
                forEach(defaultTypes, function (type, name) {
                    $types[name] = new Type(extend({ name: name }, type));
                });
                $types = inherit($types, {});
                this.$get = [
                    "$injector",
                    function ($injector) {
                        injector = $injector;
                        enqueue = false;
                        flushTypeQueue();
                        forEach(defaultTypes, function (type, name) {
                            if (!$types[name]) $types[name] = new Type(type);
                        });
                        return this;
                    },
                ];
                this.Param = function Param(id, type, config, location) {
                    var self = this;
                    config = unwrapShorthand(config);
                    type = getType(config, type, location);
                    var arrayMode = getArrayMode();
                    type = arrayMode ? type.$asArray(arrayMode, location === "search") : type;
                    if (type.name === "string" && !arrayMode && location === "path" && config.value === undefined) config.value = "";
                    var isOptional = config.value !== undefined;
                    var squash = getSquashPolicy(config, isOptional);
                    var replace = getReplace(config, arrayMode, isOptional, squash);
                    function unwrapShorthand(config) {
                        var keys = isObject(config) ? objectKeys(config) : [];
                        var isShorthand = indexOf(keys, "value") === -1 && indexOf(keys, "type") === -1 && indexOf(keys, "squash") === -1 && indexOf(keys, "array") === -1;
                        if (isShorthand) config = { value: config };
                        config.$$fn = isInjectable(config.value)
                            ? config.value
                            : function () {
                                return config.value;
                            };
                        return config;
                    }
                    function getType(config, urlType, location) {
                        if (config.type && urlType) throw new Error("Param '" + id + "' has two type configurations.");
                        if (urlType) return urlType;
                        if (!config.type) return location === "config" ? $types.any : $types.string;
                        if (angular.isString(config.type)) return $types[config.type];
                        if (config.type instanceof Type) return config.type;
                        return new Type(config.type);
                    }
                    function getArrayMode() {
                        var arrayDefaults = { array: location === "search" ? "auto" : false };
                        var arrayParamNomenclature = id.match(/\[\]$/) ? { array: true } : {};
                        return extend(arrayDefaults, arrayParamNomenclature, config).array;
                    }
                    function getSquashPolicy(config, isOptional) {
                        var squash = config.squash;
                        if (!isOptional || squash === false) return false;
                        if (!isDefined(squash) || squash == null) return defaultSquashPolicy;
                        if (squash === true || isString(squash)) return squash;
                        throw new Error("Invalid squash policy: '" + squash + "'. Valid policies: false, true, or arbitrary string");
                    }
                    function getReplace(config, arrayMode, isOptional, squash) {
                        var replace,
                            configuredKeys,
                            defaultPolicy = [
                                { from: "", to: isOptional || arrayMode ? undefined : "" },
                                { from: null, to: isOptional || arrayMode ? undefined : "" },
                            ];
                        replace = isArray(config.replace) ? config.replace : [];
                        if (isString(squash)) replace.push({ from: squash, to: undefined });
                        configuredKeys = map(replace, function (item) {
                            return item.from;
                        });
                        return filter(defaultPolicy, function (item) {
                            return indexOf(configuredKeys, item.from) === -1;
                        }).concat(replace);
                    }
                    function $$getDefaultValue() {
                        if (!injector) throw new Error("Injectable functions cannot be called at configuration time");
                        var defaultValue = injector.invoke(config.$$fn);
                        if (defaultValue !== null && defaultValue !== undefined && !self.type.is(defaultValue))
                            throw new Error("Default value (" + defaultValue + ") for parameter '" + self.id + "' is not an instance of Type (" + self.type.name + ")");
                        return defaultValue;
                    }
                    function $value(value) {
                        function hasReplaceVal(val) {
                            return function (obj) {
                                return obj.from === val;
                            };
                        }
                        function $replace(value) {
                            var replacement = map(filter(self.replace, hasReplaceVal(value)), function (obj) {
                                return obj.to;
                            });
                            return replacement.length ? replacement[0] : value;
                        }
                        value = $replace(value);
                        return !isDefined(value) ? $$getDefaultValue() : self.type.$normalize(value);
                    }
                    function toString() {
                        return "{Param:" + id + " " + type + " squash: '" + squash + "' optional: " + isOptional + "}";
                    }
                    extend(this, { id: id, type: type, location: location, array: arrayMode, squash: squash, replace: replace, isOptional: isOptional, value: $value, dynamic: undefined, config: config, toString: toString });
                };
                function ParamSet(params) {
                    extend(this, params || {});
                }
                ParamSet.prototype = {
                    $$new: function () {
                        return inherit(this, extend(new ParamSet(), { $$parent: this }));
                    },
                    $$keys: function () {
                        var keys = [],
                            chain = [],
                            parent = this,
                            ignore = objectKeys(ParamSet.prototype);
                        while (parent) {
                            chain.push(parent);
                            parent = parent.$$parent;
                        }
                        chain.reverse();
                        forEach(chain, function (paramset) {
                            forEach(objectKeys(paramset), function (key) {
                                if (indexOf(keys, key) === -1 && indexOf(ignore, key) === -1) keys.push(key);
                            });
                        });
                        return keys;
                    },
                    $$values: function (paramValues) {
                        var values = {},
                            self = this;
                        forEach(self.$$keys(), function (key) {
                            values[key] = self[key].value(paramValues && paramValues[key]);
                        });
                        return values;
                    },
                    $$equals: function (paramValues1, paramValues2) {
                        var equal = true,
                            self = this;
                        forEach(self.$$keys(), function (key) {
                            var left = paramValues1 && paramValues1[key],
                                right = paramValues2 && paramValues2[key];
                            if (!self[key].type.equals(left, right)) equal = false;
                        });
                        return equal;
                    },
                    $$validates: function $$validate(paramValues) {
                        var keys = this.$$keys(),
                            i,
                            param,
                            rawVal,
                            normalized,
                            encoded;
                        for (i = 0; i < keys.length; i++) {
                            param = this[keys[i]];
                            rawVal = paramValues[keys[i]];
                            if ((rawVal === undefined || rawVal === null) && param.isOptional) break;
                            normalized = param.type.$normalize(rawVal);
                            if (!param.type.is(normalized)) return false;
                            encoded = param.type.encode(normalized);
                            if (angular.isString(encoded) && !param.type.pattern.exec(encoded)) return false;
                        }
                        return true;
                    },
                    $$parent: undefined,
                };
                this.ParamSet = ParamSet;
            }
            angular.module("ui.router.util").provider("$urlMatcherFactory", $UrlMatcherFactory);
            angular.module("ui.router.util").run(["$urlMatcherFactory", function ($urlMatcherFactory) { }]);
            $UrlRouterProvider.$inject = ["$locationProvider", "$urlMatcherFactoryProvider"];
            function $UrlRouterProvider($locationProvider, $urlMatcherFactory) {
                var rules = [],
                    otherwise = null,
                    interceptDeferred = false,
                    listener;
                function regExpPrefix(re) {
                    var prefix = /^\^((?:\\[^a-zA-Z0-9]|[^\\\[\]\^$*+?.()|{}]+)*)/.exec(re.source);
                    return prefix != null ? prefix[1].replace(/\\(.)/g, "$1") : "";
                }
                function interpolate(pattern, match) {
                    return pattern.replace(/\$(\$|\d{1,2})/, function (m, what) {
                        return match[what === "$" ? 0 : Number(what)];
                    });
                }
                this.rule = function (rule) {
                    if (!isFunction(rule)) throw new Error("'rule' must be a function");
                    rules.push(rule);
                    return this;
                };
                this.otherwise = function (rule) {
                    if (isString(rule)) {
                        var redirect = rule;
                        rule = function () {
                            return redirect;
                        };
                    } else if (!isFunction(rule)) throw new Error("'rule' must be a function");
                    otherwise = rule;
                    return this;
                };
                function handleIfMatch($injector, handler, match) {
                    if (!match) return false;
                    var result = $injector.invoke(handler, handler, { $match: match });
                    return isDefined(result) ? result : true;
                }
                this.when = function (what, handler) {
                    var redirect,
                        handlerIsString = isString(handler);
                    if (isString(what)) what = $urlMatcherFactory.compile(what);
                    if (!handlerIsString && !isFunction(handler) && !isArray(handler)) throw new Error("invalid 'handler' in when()");
                    var strategies = {
                        matcher: function (what, handler) {
                            if (handlerIsString) {
                                redirect = $urlMatcherFactory.compile(handler);
                                handler = [
                                    "$match",
                                    function ($match) {
                                        return redirect.format($match);
                                    },
                                ];
                            }
                            return extend(
                                function ($injector, $location) {
                                    return handleIfMatch($injector, handler, what.exec($location.path(), $location.search()));
                                },
                                { prefix: isString(what.prefix) ? what.prefix : "" }
                            );
                        },
                        regex: function (what, handler) {
                            if (what.global || what.sticky) throw new Error("when() RegExp must not be global or sticky");
                            if (handlerIsString) {
                                redirect = handler;
                                handler = [
                                    "$match",
                                    function ($match) {
                                        return interpolate(redirect, $match);
                                    },
                                ];
                            }
                            return extend(
                                function ($injector, $location) {
                                    return handleIfMatch($injector, handler, what.exec($location.path()));
                                },
                                { prefix: regExpPrefix(what) }
                            );
                        },
                    };
                    var check = { matcher: $urlMatcherFactory.isMatcher(what), regex: what instanceof RegExp };
                    for (var n in check) {
                        if (check[n]) return this.rule(strategies[n](what, handler));
                    }
                    throw new Error("invalid 'what' in when()");
                };
                this.deferIntercept = function (defer) {
                    if (defer === undefined) defer = true;
                    interceptDeferred = defer;
                };
                this.$get = $get;
                $get.$inject = ["$location", "$rootScope", "$injector", "$browser", "$sniffer"];
                function $get($location, $rootScope, $injector, $browser, $sniffer) {
                    var baseHref = $browser.baseHref(),
                        location = $location.url(),
                        lastPushedUrl;
                    function appendBasePath(url, isHtml5, absolute) {
                        if (baseHref === "/") return url;
                        if (isHtml5) return baseHref.slice(0, -1) + url;
                        if (absolute) return baseHref.slice(1) + url;
                        return url;
                    }
                    function update(evt) {
                        if (evt && evt.defaultPrevented) return;
                        var ignoreUpdate = lastPushedUrl && $location.url() === lastPushedUrl;
                        lastPushedUrl = undefined;
                        function check(rule) {
                            var handled = rule($injector, $location);
                            if (!handled) return false;
                            if (isString(handled)) $location.replace().url(handled);
                            return true;
                        }
                        var n = rules.length,
                            i;
                        for (i = 0; i < n; i++) {
                            if (check(rules[i])) return;
                        }
                        if (otherwise) check(otherwise);
                    }
                    function listen() {
                        listener = listener || $rootScope.$on("$locationChangeSuccess", update);
                        return listener;
                    }
                    if (!interceptDeferred) listen();
                    return {
                        sync: function () {
                            update();
                        },
                        listen: function () {
                            return listen();
                        },
                        update: function (read) {
                            if (read) {
                                location = $location.url();
                                return;
                            }
                            if ($location.url() === location) return;
                            $location.url(location);
                            $location.replace();
                        },
                        push: function (urlMatcher, params, options) {
                            var url = urlMatcher.format(params || {});
                            if (url !== null && params && params["#"]) {
                                url += "#" + params["#"];
                            }
                            $location.url(url);
                            lastPushedUrl = options && options.$$avoidResync ? $location.url() : undefined;
                            if (options && options.replace) $location.replace();
                        },
                        href: function (urlMatcher, params, options) {
                            if (!urlMatcher.validates(params)) return null;
                            var isHtml5 = $locationProvider.html5Mode();
                            if (angular.isObject(isHtml5)) {
                                isHtml5 = isHtml5.enabled;
                            }
                            isHtml5 = isHtml5 && $sniffer.history;
                            var url = urlMatcher.format(params);
                            options = options || {};
                            if (!isHtml5 && url !== null) {
                                url = "#" + $locationProvider.hashPrefix() + url;
                            }
                            if (url !== null && params && params["#"]) {
                                url += "#" + params["#"];
                            }
                            url = appendBasePath(url, isHtml5, options.absolute);
                            if (!options.absolute || !url) {
                                return url;
                            }
                            var slash = !isHtml5 && url ? "/" : "",
                                port = $location.port();
                            port = port === 80 || port === 443 ? "" : ":" + port;
                            return [$location.protocol(), "://", $location.host(), port, slash, url].join("");
                        },
                    };
                }
            }
            angular.module("ui.router.router").provider("$urlRouter", $UrlRouterProvider);
            $StateProvider.$inject = ["$urlRouterProvider", "$urlMatcherFactoryProvider"];
            function $StateProvider($urlRouterProvider, $urlMatcherFactory) {
                var root,
                    states = {},
                    $state,
                    queue = {},
                    abstractKey = "abstract";
                var stateBuilder = {
                    parent: function (state) {
                        if (isDefined(state.parent) && state.parent) return findState(state.parent);
                        var compositeName = /^(.+)\.[^.]+$/.exec(state.name);
                        return compositeName ? findState(compositeName[1]) : root;
                    },
                    data: function (state) {
                        if (state.parent && state.parent.data) {
                            state.data = state.self.data = inherit(state.parent.data, state.data);
                        }
                        return state.data;
                    },
                    url: function (state) {
                        var url = state.url,
                            config = { params: state.params || {} };
                        if (isString(url)) {
                            if (url.charAt(0) == "^") return $urlMatcherFactory.compile(url.substring(1), config);
                            return (state.parent.navigable || root).url.concat(url, config);
                        }
                        if (!url || $urlMatcherFactory.isMatcher(url)) return url;
                        throw new Error("Invalid url '" + url + "' in state '" + state + "'");
                    },
                    navigable: function (state) {
                        return state.url ? state : state.parent ? state.parent.navigable : null;
                    },
                    ownParams: function (state) {
                        var params = (state.url && state.url.params) || new $$UMFP.ParamSet();
                        forEach(state.params || {}, function (config, id) {
                            if (!params[id]) params[id] = new $$UMFP.Param(id, null, config, "config");
                        });
                        return params;
                    },
                    params: function (state) {
                        var ownParams = pick(state.ownParams, state.ownParams.$$keys());
                        return state.parent && state.parent.params ? extend(state.parent.params.$$new(), ownParams) : new $$UMFP.ParamSet();
                    },
                    views: function (state) {
                        var views = {};
                        forEach(isDefined(state.views) ? state.views : { "": state }, function (view, name) {
                            if (name.indexOf("@") < 0) name += "@" + state.parent.name;
                            view.resolveAs = view.resolveAs || state.resolveAs || "$resolve";
                            views[name] = view;
                        });
                        return views;
                    },
                    path: function (state) {
                        return state.parent ? state.parent.path.concat(state) : [];
                    },
                    includes: function (state) {
                        var includes = state.parent ? extend({}, state.parent.includes) : {};
                        includes[state.name] = true;
                        return includes;
                    },
                    $delegates: {},
                };
                function isRelative(stateName) {
                    return stateName.indexOf(".") === 0 || stateName.indexOf("^") === 0;
                }
                function findState(stateOrName, base) {
                    if (!stateOrName) return undefined;
                    var isStr = isString(stateOrName),
                        name = isStr ? stateOrName : stateOrName.name,
                        path = isRelative(name);
                    if (path) {
                        if (!base) throw new Error("No reference point given for path '" + name + "'");
                        base = findState(base);
                        var rel = name.split("."),
                            i = 0,
                            pathLength = rel.length,
                            current = base;
                        for (; i < pathLength; i++) {
                            if (rel[i] === "" && i === 0) {
                                current = base;
                                continue;
                            }
                            if (rel[i] === "^") {
                                if (!current.parent) throw new Error("Path '" + name + "' not valid for state '" + base.name + "'");
                                current = current.parent;
                                continue;
                            }
                            break;
                        }
                        rel = rel.slice(i).join(".");
                        name = current.name + (current.name && rel ? "." : "") + rel;
                    }
                    var state = states[name];
                    if (state && (isStr || (!isStr && (state === stateOrName || state.self === stateOrName)))) {
                        return state;
                    }
                    return undefined;
                }
                function queueState(parentName, state) {
                    if (!queue[parentName]) {
                        queue[parentName] = [];
                    }
                    queue[parentName].push(state);
                }
                function flushQueuedChildren(parentName) {
                    var queued = queue[parentName] || [];
                    while (queued.length) {
                        registerState(queued.shift());
                    }
                }
                function registerState(state) {
                    state = inherit(state, {
                        self: state,
                        resolve: state.resolve || {},
                        toString: function () {
                            return this.name;
                        },
                    });
                    var name = state.name;
                    if (!isString(name) || name.indexOf("@") >= 0) throw new Error("State must have a valid name");
                    if (states.hasOwnProperty(name)) throw new Error("State '" + name + "' is already defined");
                    var parentName = name.indexOf(".") !== -1 ? name.substring(0, name.lastIndexOf(".")) : isString(state.parent) ? state.parent : isObject(state.parent) && isString(state.parent.name) ? state.parent.name : "";
                    if (parentName && !states[parentName]) {
                        return queueState(parentName, state.self);
                    }
                    for (var key in stateBuilder) {
                        if (isFunction(stateBuilder[key])) state[key] = stateBuilder[key](state, stateBuilder.$delegates[key]);
                    }
                    states[name] = state;
                    if (!state[abstractKey] && state.url) {
                        $urlRouterProvider.when(state.url, [
                            "$match",
                            "$stateParams",
                            function ($match, $stateParams) {
                                if ($state.$current.navigable != state || !equalForKeys($match, $stateParams)) {
                                    $state.transitionTo(state, $match, { inherit: true, location: false });
                                }
                            },
                        ]);
                    }
                    flushQueuedChildren(name);
                    return state;
                }
                function isGlob(text) {
                    return text.indexOf("*") > -1;
                }
                function doesStateMatchGlob(glob) {
                    var globSegments = glob.split("."),
                        segments = $state.$current.name.split(".");
                    for (var i = 0, l = globSegments.length; i < l; i++) {
                        if (globSegments[i] === "*") {
                            segments[i] = "*";
                        }
                    }
                    if (globSegments[0] === "**") {
                        segments = segments.slice(indexOf(segments, globSegments[1]));
                        segments.unshift("**");
                    }
                    if (globSegments[globSegments.length - 1] === "**") {
                        segments.splice(indexOf(segments, globSegments[globSegments.length - 2]) + 1, Number.MAX_VALUE);
                        segments.push("**");
                    }
                    if (globSegments.length != segments.length) {
                        return false;
                    }
                    return segments.join("") === globSegments.join("");
                }
                root = registerState({ name: "", url: "^", views: null, abstract: true });
                root.navigable = null;
                this.decorator = decorator;
                function decorator(name, func) {
                    if (isString(name) && !isDefined(func)) {
                        return stateBuilder[name];
                    }
                    if (!isFunction(func) || !isString(name)) {
                        return this;
                    }
                    if (stateBuilder[name] && !stateBuilder.$delegates[name]) {
                        stateBuilder.$delegates[name] = stateBuilder[name];
                    }
                    stateBuilder[name] = func;
                    return this;
                }
                this.state = state;
                function state(name, definition) {
                    if (isObject(name)) definition = name;
                    else definition.name = name;
                    registerState(definition);
                    return this;
                }
                this.$get = $get;
                $get.$inject = ["$rootScope", "$q", "$view", "$injector", "$resolve", "$stateParams", "$urlRouter", "$location", "$urlMatcherFactory"];
                function $get($rootScope, $q, $view, $injector, $resolve, $stateParams, $urlRouter, $location, $urlMatcherFactory) {
                    var TransitionSupersededError = new Error("transition superseded");
                    var TransitionSuperseded = silenceUncaughtInPromise($q.reject(TransitionSupersededError));
                    var TransitionPrevented = silenceUncaughtInPromise($q.reject(new Error("transition prevented")));
                    var TransitionAborted = silenceUncaughtInPromise($q.reject(new Error("transition aborted")));
                    var TransitionFailed = silenceUncaughtInPromise($q.reject(new Error("transition failed")));
                    function handleRedirect(redirect, state, params, options) {
                        var evt = $rootScope.$broadcast("$stateNotFound", redirect, state, params);
                        if (evt.defaultPrevented) {
                            $urlRouter.update();
                            return TransitionAborted;
                        }
                        if (!evt.retry) {
                            return null;
                        }
                        if (options.$retry) {
                            $urlRouter.update();
                            return TransitionFailed;
                        }
                        var retryTransition = ($state.transition = $q.when(evt.retry));
                        retryTransition.then(
                            function () {
                                if (retryTransition !== $state.transition) {
                                    $rootScope.$broadcast("$stateChangeCancel", redirect.to, redirect.toParams, state, params);
                                    return TransitionSuperseded;
                                }
                                redirect.options.$retry = true;
                                return $state.transitionTo(redirect.to, redirect.toParams, redirect.options);
                            },
                            function () {
                                return TransitionAborted;
                            }
                        );
                        $urlRouter.update();
                        return retryTransition;
                    }
                    root.locals = { resolve: null, globals: { $stateParams: {} } };
                    $state = { params: {}, current: root.self, $current: root, transition: null };
                    $state.reload = function reload(state) {
                        return $state.transitionTo($state.current, $stateParams, { reload: state || true, inherit: false, notify: true });
                    };
                    $state.go = function go(to, params, options) {
                        return $state.transitionTo(to, params, extend({ inherit: true, relative: $state.$current }, options));
                    };
                    $state.transitionTo = function transitionTo(to, toParams, options) {
                        toParams = toParams || {};
                        options = extend({ location: true, inherit: false, relative: null, notify: true, reload: false, $retry: false }, options || {});
                        var from = $state.$current,
                            fromParams = $state.params,
                            fromPath = from.path;
                        var evt,
                            toState = findState(to, options.relative);
                        var hash = toParams["#"];
                        if (!isDefined(toState)) {
                            var redirect = { to: to, toParams: toParams, options: options };
                            var redirectResult = handleRedirect(redirect, from.self, fromParams, options);
                            if (redirectResult) {
                                return redirectResult;
                            }
                            to = redirect.to;
                            toParams = redirect.toParams;
                            options = redirect.options;
                            toState = findState(to, options.relative);
                            if (!isDefined(toState)) {
                                if (!options.relative) throw new Error("No such state '" + to + "'");
                                throw new Error("Could not resolve '" + to + "' from state '" + options.relative + "'");
                            }
                        }
                        if (toState[abstractKey]) throw new Error("Cannot transition to abstract state '" + to + "'");
                        if (options.inherit) toParams = inheritParams($stateParams, toParams || {}, $state.$current, toState);
                        if (!toState.params.$$validates(toParams)) return TransitionFailed;
                        toParams = toState.params.$$values(toParams);
                        to = toState;
                        var toPath = to.path;
                        var keep = 0,
                            state = toPath[keep],
                            locals = root.locals,
                            toLocals = [];
                        if (!options.reload) {
                            while (state && state === fromPath[keep] && state.ownParams.$$equals(toParams, fromParams)) {
                                locals = toLocals[keep] = state.locals;
                                keep++;
                                state = toPath[keep];
                            }
                        } else if (isString(options.reload) || isObject(options.reload)) {
                            if (isObject(options.reload) && !options.reload.name) {
                                throw new Error("Invalid reload state object");
                            }
                            var reloadState = options.reload === true ? fromPath[0] : findState(options.reload);
                            if (options.reload && !reloadState) {
                                throw new Error("No such reload state '" + (isString(options.reload) ? options.reload : options.reload.name) + "'");
                            }
                            while (state && state === fromPath[keep] && state !== reloadState) {
                                locals = toLocals[keep] = state.locals;
                                keep++;
                                state = toPath[keep];
                            }
                        }
                        if (shouldSkipReload(to, toParams, from, fromParams, locals, options)) {
                            if (hash) toParams["#"] = hash;
                            $state.params = toParams;
                            copy($state.params, $stateParams);
                            copy(filterByKeys(to.params.$$keys(), $stateParams), to.locals.globals.$stateParams);
                            if (options.location && to.navigable && to.navigable.url) {
                                $urlRouter.push(to.navigable.url, toParams, { $$avoidResync: true, replace: options.location === "replace" });
                                $urlRouter.update(true);
                            }
                            $state.transition = null;
                            return $q.when($state.current);
                        }
                        toParams = filterByKeys(to.params.$$keys(), toParams || {});
                        if (hash) toParams["#"] = hash;
                        if (options.notify) {
                            if ($rootScope.$broadcast("$stateChangeStart", to.self, toParams, from.self, fromParams, options).defaultPrevented) {
                                $rootScope.$broadcast("$stateChangeCancel", to.self, toParams, from.self, fromParams);
                                if ($state.transition == null) $urlRouter.update();
                                return TransitionPrevented;
                            }
                        }
                        var resolved = $q.when(locals);
                        for (var l = keep; l < toPath.length; l++, state = toPath[l]) {
                            locals = toLocals[l] = inherit(locals);
                            resolved = resolveState(state, toParams, state === to, resolved, locals, options);
                        }
                        var transition = ($state.transition = resolved
                            .then(function () {
                                var l, entering, exiting;
                                if ($state.transition !== transition) {
                                    $rootScope.$broadcast("$stateChangeCancel", to.self, toParams, from.self, fromParams);
                                    return TransitionSuperseded;
                                }
                                for (l = fromPath.length - 1; l >= keep; l--) {
                                    exiting = fromPath[l];
                                    if (exiting.self.onExit) {
                                        $injector.invoke(exiting.self.onExit, exiting.self, exiting.locals.globals);
                                    }
                                    exiting.locals = null;
                                }
                                for (l = keep; l < toPath.length; l++) {
                                    entering = toPath[l];
                                    entering.locals = toLocals[l];
                                    if (entering.self.onEnter) {
                                        $injector.invoke(entering.self.onEnter, entering.self, entering.locals.globals);
                                    }
                                }
                                if ($state.transition !== transition) {
                                    $rootScope.$broadcast("$stateChangeCancel", to.self, toParams, from.self, fromParams);
                                    return TransitionSuperseded;
                                }
                                $state.$current = to;
                                $state.current = to.self;
                                $state.params = toParams;
                                copy($state.params, $stateParams);
                                $state.transition = null;
                                if (options.location && to.navigable) {
                                    $urlRouter.push(to.navigable.url, to.navigable.locals.globals.$stateParams, { $$avoidResync: true, replace: options.location === "replace" });
                                }
                                if (options.notify) {
                                    $rootScope.$broadcast("$stateChangeSuccess", to.self, toParams, from.self, fromParams);
                                }
                                $urlRouter.update(true);
                                return $state.current;
                            })
                            .then(null, function (error) {
                                if (error === TransitionSupersededError) return TransitionSuperseded;
                                if ($state.transition !== transition) {
                                    $rootScope.$broadcast("$stateChangeCancel", to.self, toParams, from.self, fromParams);
                                    return TransitionSuperseded;
                                }
                                $state.transition = null;
                                evt = $rootScope.$broadcast("$stateChangeError", to.self, toParams, from.self, fromParams, error);
                                if (!evt.defaultPrevented) {
                                    $urlRouter.update();
                                }
                                return $q.reject(error);
                            }));
                        silenceUncaughtInPromise(transition);
                        return transition;
                    };
                    $state.is = function is(stateOrName, params, options) {
                        options = extend({ relative: $state.$current }, options || {});
                        var state = findState(stateOrName, options.relative);
                        if (!isDefined(state)) {
                            return undefined;
                        }
                        if ($state.$current !== state) {
                            return false;
                        }
                        return (
                            !params ||
                            objectKeys(params).reduce(function (acc, key) {
                                var paramDef = state.params[key];
                                return (acc && !paramDef) || paramDef.type.equals($stateParams[key], params[key]);
                            }, true)
                        );
                    };
                    $state.includes = function includes(stateOrName, params, options) {
                        options = extend({ relative: $state.$current }, options || {});
                        if (isString(stateOrName) && isGlob(stateOrName)) {
                            if (!doesStateMatchGlob(stateOrName)) {
                                return false;
                            }
                            stateOrName = $state.$current.name;
                        }
                        var state = findState(stateOrName, options.relative);
                        if (!isDefined(state)) {
                            return undefined;
                        }
                        if (!isDefined($state.$current.includes[state.name])) {
                            return false;
                        }
                        if (!params) {
                            return true;
                        }
                        var keys = objectKeys(params);
                        for (var i = 0; i < keys.length; i++) {
                            var key = keys[i],
                                paramDef = state.params[key];
                            if (paramDef && !paramDef.type.equals($stateParams[key], params[key])) {
                                return false;
                            }
                        }
                        return objectKeys(params).reduce(function (acc, key) {
                            var paramDef = state.params[key];
                            return (acc && !paramDef) || paramDef.type.equals($stateParams[key], params[key]);
                        }, true);
                    };
                    $state.href = function href(stateOrName, params, options) {
                        options = extend({ lossy: true, inherit: true, absolute: false, relative: $state.$current }, options || {});
                        var state = findState(stateOrName, options.relative);
                        if (!isDefined(state)) return null;
                        if (options.inherit) params = inheritParams($stateParams, params || {}, $state.$current, state);
                        var nav = state && options.lossy ? state.navigable : state;
                        if (!nav || nav.url === undefined || nav.url === null) {
                            return null;
                        }
                        return $urlRouter.href(nav.url, filterByKeys(state.params.$$keys().concat("#"), params || {}), { absolute: options.absolute });
                    };
                    $state.get = function (stateOrName, context) {
                        if (arguments.length === 0)
                            return map(objectKeys(states), function (name) {
                                return states[name].self;
                            });
                        var state = findState(stateOrName, context || $state.$current);
                        return state && state.self ? state.self : null;
                    };
                    function resolveState(state, params, paramsAreFiltered, inherited, dst, options) {
                        var $stateParams = paramsAreFiltered ? params : filterByKeys(state.params.$$keys(), params);
                        var locals = { $stateParams: $stateParams };
                        dst.resolve = $resolve.resolve(state.resolve, locals, dst.resolve, state);
                        var promises = [
                            dst.resolve.then(function (globals) {
                                dst.globals = globals;
                            }),
                        ];
                        if (inherited) promises.push(inherited);
                        function resolveViews() {
                            var viewsPromises = [];
                            forEach(state.views, function (view, name) {
                                var injectables = view.resolve && view.resolve !== state.resolve ? view.resolve : {};
                                injectables.$template = [
                                    function () {
                                        return $view.load(name, { view: view, locals: dst.globals, params: $stateParams, notify: options.notify }) || "";
                                    },
                                ];
                                viewsPromises.push(
                                    $resolve.resolve(injectables, dst.globals, dst.resolve, state).then(function (result) {
                                        if (isFunction(view.controllerProvider) || isArray(view.controllerProvider)) {
                                            var injectLocals = angular.extend({}, injectables, dst.globals);
                                            result.$$controller = $injector.invoke(view.controllerProvider, null, injectLocals);
                                        } else {
                                            result.$$controller = view.controller;
                                        }
                                        result.$$state = state;
                                        result.$$controllerAs = view.controllerAs;
                                        result.$$resolveAs = view.resolveAs;
                                        dst[name] = result;
                                    })
                                );
                            });
                            return $q.all(viewsPromises).then(function () {
                                return dst.globals;
                            });
                        }
                        return $q
                            .all(promises)
                            .then(resolveViews)
                            .then(function (values) {
                                return dst;
                            });
                    }
                    return $state;
                }
                function shouldSkipReload(to, toParams, from, fromParams, locals, options) {
                    function nonSearchParamsEqual(fromAndToState, fromParams, toParams) {
                        function notSearchParam(key) {
                            return fromAndToState.params[key].location != "search";
                        }
                        var nonQueryParamKeys = fromAndToState.params.$$keys().filter(notSearchParam);
                        var nonQueryParams = pick.apply({}, [fromAndToState.params].concat(nonQueryParamKeys));
                        var nonQueryParamSet = new $$UMFP.ParamSet(nonQueryParams);
                        return nonQueryParamSet.$$equals(fromParams, toParams);
                    }
                    if (!options.reload && to === from && (locals === from.locals || (to.self.reloadOnSearch === false && nonSearchParamsEqual(from, fromParams, toParams)))) {
                        return true;
                    }
                }
            }
            angular
                .module("ui.router.state")
                .factory("$stateParams", function () {
                    return {};
                })
                .constant("$state.runtime", { autoinject: true })
                .provider("$state", $StateProvider)
                .run([
                    "$injector",
                    function ($injector) {
                        if ($injector.get("$state.runtime").autoinject) {
                            $injector.get("$state");
                        }
                    },
                ]);
            $ViewProvider.$inject = [];
            function $ViewProvider() {
                this.$get = $get;
                $get.$inject = ["$rootScope", "$templateFactory"];
                function $get($rootScope, $templateFactory) {
                    return {
                        load: function load(name, options) {
                            var result,
                                defaults = { template: null, controller: null, view: null, locals: null, notify: true, async: true, params: {} };
                            options = extend(defaults, options);
                            if (options.view) {
                                result = $templateFactory.fromConfig(options.view, options.params, options.locals);
                            }
                            return result;
                        },
                    };
                }
            }
            angular.module("ui.router.state").provider("$view", $ViewProvider);
            function $ViewScrollProvider() {
                var useAnchorScroll = false;
                this.useAnchorScroll = function () {
                    useAnchorScroll = true;
                };
                this.$get = [
                    "$anchorScroll",
                    "$timeout",
                    function ($anchorScroll, $timeout) {
                        if (useAnchorScroll) {
                            return $anchorScroll;
                        }
                        return function ($element) {
                            return $timeout(
                                function () {
                                    $element[0].scrollIntoView();
                                },
                                0,
                                false
                            );
                        };
                    },
                ];
            }
            angular.module("ui.router.state").provider("$uiViewScroll", $ViewScrollProvider);
            $ViewDirective.$inject = ["$state", "$injector", "$uiViewScroll", "$interpolate", "$q"];
            function $ViewDirective($state, $injector, $uiViewScroll, $interpolate, $q) {
                function getService() {
                    return $injector.has
                        ? function (service) {
                            return $injector.has(service) ? $injector.get(service) : null;
                        }
                        : function (service) {
                            try {
                                return $injector.get(service);
                            } catch (e) {
                                return null;
                            }
                        };
                }
                var service = getService(),
                    $animator = service("$animator"),
                    $animate = service("$animate");
                function getRenderer(attrs, scope) {
                    var statics = function () {
                        return {
                            enter: function (element, target, cb) {
                                target.after(element);
                                cb();
                            },
                            leave: function (element, cb) {
                                element.remove();
                                cb();
                            },
                        };
                    };
                    if ($animate) {
                        return {
                            enter: function (element, target, cb) {
                                if (angular.version.minor > 2) {
                                    $animate.enter(element, null, target).then(cb);
                                } else {
                                    $animate.enter(element, null, target, cb);
                                }
                            },
                            leave: function (element, cb) {
                                if (angular.version.minor > 2) {
                                    $animate.leave(element).then(cb);
                                } else {
                                    $animate.leave(element, cb);
                                }
                            },
                        };
                    }
                    if ($animator) {
                        var animate = $animator && $animator(scope, attrs);
                        return {
                            enter: function (element, target, cb) {
                                animate.enter(element, null, target);
                                cb();
                            },
                            leave: function (element, cb) {
                                animate.leave(element);
                                cb();
                            },
                        };
                    }
                    return statics();
                }
                var directive = {
                    restrict: "ECA",
                    terminal: true,
                    priority: 400,
                    transclude: "element",
                    compile: function (tElement, tAttrs, $transclude) {
                        return function (scope, $element, attrs) {
                            var previousEl,
                                currentEl,
                                currentScope,
                                latestLocals,
                                onloadExp = attrs.onload || "",
                                autoScrollExp = attrs.autoscroll,
                                renderer = getRenderer(attrs, scope),
                                inherited = $element.inheritedData("$uiView");
                            scope.$on("$stateChangeSuccess", function () {
                                updateView(false);
                            });
                            updateView(true);
                            function cleanupLastView() {
                                if (previousEl) {
                                    previousEl.remove();
                                    previousEl = null;
                                }
                                if (currentScope) {
                                    currentScope.$destroy();
                                    currentScope = null;
                                }
                                if (currentEl) {
                                    var $uiViewData = currentEl.data("$uiViewAnim");
                                    renderer.leave(currentEl, function () {
                                        $uiViewData.$$animLeave.resolve();
                                        previousEl = null;
                                    });
                                    previousEl = currentEl;
                                    currentEl = null;
                                }
                            }
                            function updateView(firstTime) {
                                var newScope,
                                    name = getUiViewName(scope, attrs, $element, $interpolate),
                                    previousLocals = name && $state.$current && $state.$current.locals[name];
                                if (!firstTime && previousLocals === latestLocals) return;
                                newScope = scope.$new();
                                latestLocals = $state.$current.locals[name];
                                newScope.$emit("$viewContentLoading", name);
                                var clone = $transclude(newScope, function (clone) {
                                    var animEnter = $q.defer(),
                                        animLeave = $q.defer();
                                    var viewAnimData = { $animEnter: animEnter.promise, $animLeave: animLeave.promise, $$animLeave: animLeave };
                                    clone.data("$uiViewAnim", viewAnimData);
                                    renderer.enter(clone, $element, function onUiViewEnter() {
                                        animEnter.resolve();
                                        if (currentScope) {
                                            currentScope.$emit("$viewContentAnimationEnded");
                                        }
                                        if ((angular.isDefined(autoScrollExp) && !autoScrollExp) || scope.$eval(autoScrollExp)) {
                                            $uiViewScroll(clone);
                                        }
                                    });
                                    cleanupLastView();
                                });
                                currentEl = clone;
                                currentScope = newScope;
                                currentScope.$emit("$viewContentLoaded", name);
                                currentScope.$eval(onloadExp);
                            }
                        };
                    },
                };
                return directive;
            }
            $ViewDirectiveFill.$inject = ["$compile", "$controller", "$state", "$interpolate"];
            function $ViewDirectiveFill($compile, $controller, $state, $interpolate) {
                return {
                    restrict: "ECA",
                    priority: -400,
                    compile: function (tElement) {
                        var initial = tElement.html();
                        if (tElement.empty) {
                            tElement.empty();
                        } else {
                            tElement[0].innerHTML = null;
                        }
                        return function (scope, $element, attrs) {
                            var current = $state.$current,
                                name = getUiViewName(scope, attrs, $element, $interpolate),
                                locals = current && current.locals[name];
                            if (!locals) {
                                $element.html(initial);
                                $compile($element.contents())(scope);
                                return;
                            }
                            $element.data("$uiView", { name: name, state: locals.$$state });
                            $element.html(locals.$template ? locals.$template : initial);
                            var resolveData = angular.extend({}, locals);
                            scope[locals.$$resolveAs] = resolveData;
                            var link = $compile($element.contents());
                            if (locals.$$controller) {
                                locals.$scope = scope;
                                locals.$element = $element;
                                var controller = $controller(locals.$$controller, locals);
                                if (locals.$$controllerAs) {
                                    scope[locals.$$controllerAs] = controller;
                                    scope[locals.$$controllerAs][locals.$$resolveAs] = resolveData;
                                }
                                if (isFunction(controller.$onInit)) controller.$onInit();
                                $element.data("$ngControllerController", controller);
                                $element.children().data("$ngControllerController", controller);
                            }
                            link(scope);
                        };
                    },
                };
            }
            function getUiViewName(scope, attrs, element, $interpolate) {
                var name = $interpolate(attrs.uiView || attrs.name || "")(scope);
                var uiViewCreatedBy = element.inheritedData("$uiView");
                return name.indexOf("@") >= 0 ? name : name + "@" + (uiViewCreatedBy ? uiViewCreatedBy.state.name : "");
            }
            angular.module("ui.router.state").directive("uiView", $ViewDirective);
            angular.module("ui.router.state").directive("uiView", $ViewDirectiveFill);
            function parseStateRef(ref, current) {
                var preparsed = ref.match(/^\s*({[^}]*})\s*$/),
                    parsed;
                if (preparsed) ref = current + "(" + preparsed[1] + ")";
                parsed = ref.replace(/\n/g, " ").match(/^([^(]+?)\s*(\((.*)\))?$/);
                if (!parsed || parsed.length !== 4) throw new Error("Invalid state ref '" + ref + "'");
                return { state: parsed[1], paramExpr: parsed[3] || null };
            }
            function stateContext(el) {
                var stateData = el.parent().inheritedData("$uiView");
                if (stateData && stateData.state && stateData.state.name) {
                    return stateData.state;
                }
            }
            function getTypeInfo(el) {
                var isSvg = Object.prototype.toString.call(el.prop("href")) === "[object SVGAnimatedString]";
                var isForm = el[0].nodeName === "FORM";
                return { attr: isForm ? "action" : isSvg ? "xlink:href" : "href", isAnchor: el.prop("tagName").toUpperCase() === "A", clickable: !isForm };
            }
            function clickHook(el, $state, $timeout, type, current) {
                return function (e) {
                    var button = e.which || e.button,
                        target = current();
                    if (!(button > 1 || e.ctrlKey || e.metaKey || e.shiftKey || el.attr("target"))) {
                        var transition = $timeout(function () {
                            $state.go(target.state, target.params, target.options);
                        });
                        e.preventDefault();
                        var ignorePreventDefaultCount = type.isAnchor && !target.href ? 1 : 0;
                        e.preventDefault = function () {
                            if (ignorePreventDefaultCount-- <= 0) $timeout.cancel(transition);
                        };
                    }
                };
            }
            function defaultOpts(el, $state) {
                return { relative: stateContext(el) || $state.$current, inherit: true };
            }
            $StateRefDirective.$inject = ["$state", "$timeout"];
            function $StateRefDirective($state, $timeout) {
                return {
                    restrict: "A",
                    require: ["?^uiSrefActive", "?^uiSrefActiveEq"],
                    link: function (scope, element, attrs, uiSrefActive) {
                        var ref = parseStateRef(attrs.uiSref, $state.current.name);
                        var def = { state: ref.state, href: null, params: null };
                        var type = getTypeInfo(element);
                        var active = uiSrefActive[1] || uiSrefActive[0];
                        var unlinkInfoFn = null;
                        var hookFn;
                        def.options = extend(defaultOpts(element, $state), attrs.uiSrefOpts ? scope.$eval(attrs.uiSrefOpts) : {});
                        var update = function (val) {
                            if (val) def.params = angular.copy(val);
                            def.href = $state.href(ref.state, def.params, def.options);
                            if (unlinkInfoFn) unlinkInfoFn();
                            if (active) unlinkInfoFn = active.$$addStateInfo(ref.state, def.params);
                            if (def.href !== null) attrs.$set(type.attr, def.href);
                        };
                        if (ref.paramExpr) {
                            scope.$watch(
                                ref.paramExpr,
                                function (val) {
                                    if (val !== def.params) update(val);
                                },
                                true
                            );
                            def.params = angular.copy(scope.$eval(ref.paramExpr));
                        }
                        update();
                        if (!type.clickable) return;
                        hookFn = clickHook(element, $state, $timeout, type, function () {
                            return def;
                        });
                        element[element.on ? "on" : "bind"]("click", hookFn);
                        scope.$on("$destroy", function () {
                            element[element.off ? "off" : "unbind"]("click", hookFn);
                        });
                    },
                };
            }
            $StateRefDynamicDirective.$inject = ["$state", "$timeout"];
            function $StateRefDynamicDirective($state, $timeout) {
                return {
                    restrict: "A",
                    require: ["?^uiSrefActive", "?^uiSrefActiveEq"],
                    link: function (scope, element, attrs, uiSrefActive) {
                        var type = getTypeInfo(element);
                        var active = uiSrefActive[1] || uiSrefActive[0];
                        var group = [attrs.uiState, attrs.uiStateParams || null, attrs.uiStateOpts || null];
                        var watch =
                            "[" +
                            group
                                .map(function (val) {
                                    return val || "null";
                                })
                                .join(", ") +
                            "]";
                        var def = { state: null, params: null, options: null, href: null };
                        var unlinkInfoFn = null;
                        var hookFn;
                        function runStateRefLink(group) {
                            def.state = group[0];
                            def.params = group[1];
                            def.options = group[2];
                            def.href = $state.href(def.state, def.params, def.options);
                            if (unlinkInfoFn) unlinkInfoFn();
                            if (active) unlinkInfoFn = active.$$addStateInfo(def.state, def.params);
                            if (def.href) attrs.$set(type.attr, def.href);
                        }
                        scope.$watch(watch, runStateRefLink, true);
                        runStateRefLink(scope.$eval(watch));
                        if (!type.clickable) return;
                        hookFn = clickHook(element, $state, $timeout, type, function () {
                            return def;
                        });
                        element[element.on ? "on" : "bind"]("click", hookFn);
                        scope.$on("$destroy", function () {
                            element[element.off ? "off" : "unbind"]("click", hookFn);
                        });
                    },
                };
            }
            $StateRefActiveDirective.$inject = ["$state", "$stateParams", "$interpolate"];
            function $StateRefActiveDirective($state, $stateParams, $interpolate) {
                return {
                    restrict: "A",
                    controller: [
                        "$scope",
                        "$element",
                        "$attrs",
                        "$timeout",
                        function ($scope, $element, $attrs, $timeout) {
                            var states = [],
                                activeClasses = {},
                                activeEqClass,
                                uiSrefActive;
                            activeEqClass = $interpolate($attrs.uiSrefActiveEq || "", false)($scope);
                            try {
                                uiSrefActive = $scope.$eval($attrs.uiSrefActive);
                            } catch (e) { }
                            uiSrefActive = uiSrefActive || $interpolate($attrs.uiSrefActive || "", false)($scope);
                            if (isObject(uiSrefActive)) {
                                forEach(uiSrefActive, function (stateOrName, activeClass) {
                                    if (isString(stateOrName)) {
                                        var ref = parseStateRef(stateOrName, $state.current.name);
                                        addState(ref.state, $scope.$eval(ref.paramExpr), activeClass);
                                    }
                                });
                            }
                            this.$$addStateInfo = function (newState, newParams) {
                                if (isObject(uiSrefActive) && states.length > 0) {
                                    return;
                                }
                                var deregister = addState(newState, newParams, uiSrefActive);
                                update();
                                return deregister;
                            };
                            $scope.$on("$stateChangeSuccess", update);
                            function addState(stateName, stateParams, activeClass) {
                                var state = $state.get(stateName, stateContext($element));
                                var stateHash = createStateHash(stateName, stateParams);
                                var stateInfo = { state: state || { name: stateName }, params: stateParams, hash: stateHash };
                                states.push(stateInfo);
                                activeClasses[stateHash] = activeClass;
                                return function removeState() {
                                    var idx = states.indexOf(stateInfo);
                                    if (idx !== -1) states.splice(idx, 1);
                                };
                            }
                            function createStateHash(state, params) {
                                if (!isString(state)) {
                                    throw new Error("state should be a string");
                                }
                                if (isObject(params)) {
                                    return state + toJson(params);
                                }
                                params = $scope.$eval(params);
                                if (isObject(params)) {
                                    return state + toJson(params);
                                }
                                return state;
                            }
                            function update() {
                                for (var i = 0; i < states.length; i++) {
                                    if (anyMatch(states[i].state, states[i].params)) {
                                        addClass($element, activeClasses[states[i].hash]);
                                    } else {
                                        removeClass($element, activeClasses[states[i].hash]);
                                    }
                                    if (exactMatch(states[i].state, states[i].params)) {
                                        addClass($element, activeEqClass);
                                    } else {
                                        removeClass($element, activeEqClass);
                                    }
                                }
                            }
                            function addClass(el, className) {
                                $timeout(function () {
                                    el.addClass(className);
                                });
                            }
                            function removeClass(el, className) {
                                el.removeClass(className);
                            }
                            function anyMatch(state, params) {
                                return $state.includes(state.name, params);
                            }
                            function exactMatch(state, params) {
                                return $state.is(state.name, params);
                            }
                            update();
                        },
                    ],
                };
            }
            angular.module("ui.router.state").directive("uiSref", $StateRefDirective).directive("uiSrefActive", $StateRefActiveDirective).directive("uiSrefActiveEq", $StateRefActiveDirective).directive("uiState", $StateRefDynamicDirective);
            $IsStateFilter.$inject = ["$state"];
            function $IsStateFilter($state) {
                var isFilter = function (state, params) {
                    return $state.is(state, params);
                };
                isFilter.$stateful = true;
                return isFilter;
            }
            $IncludedByStateFilter.$inject = ["$state"];
            function $IncludedByStateFilter($state) {
                var includesFilter = function (state, params, options) {
                    return $state.includes(state, params, options);
                };
                includesFilter.$stateful = true;
                return includesFilter;
            }
            angular.module("ui.router.state").filter("isState", $IsStateFilter).filter("includedByState", $IncludedByStateFilter);
        })(window, window.angular);
    });
    (function (window, angular) {
        "use strict";
        var $sanitizeMinErr = angular.$$minErr("$sanitize");
        var bind;
        var extend;
        var forEach;
        var isDefined;
        var lowercase;
        var noop;
        var nodeContains;
        var htmlParser;
        var htmlSanitizeWriter;
        function $SanitizeProvider() {
            var svgEnabled = false;
            this.$get = [
                "$$sanitizeUri",
                function ($$sanitizeUri) {
                    if (svgEnabled) {
                        extend(validElements, svgElements);
                    }
                    return function (html) {
                        var buf = [];
                        htmlParser(
                            html,
                            htmlSanitizeWriter(buf, function (uri, isImage) {
                                return !/^unsafe:/.test($$sanitizeUri(uri, isImage));
                            })
                        );
                        return buf.join("");
                    };
                },
            ];
            this.enableSvg = function (enableSvg) {
                if (isDefined(enableSvg)) {
                    svgEnabled = enableSvg;
                    return this;
                } else {
                    return svgEnabled;
                }
            };
            bind = angular.bind;
            extend = angular.extend;
            forEach = angular.forEach;
            isDefined = angular.isDefined;
            lowercase = angular.lowercase;
            noop = angular.noop;
            htmlParser = htmlParserImpl;
            htmlSanitizeWriter = htmlSanitizeWriterImpl;
            nodeContains =
                window.Node.prototype.contains ||
                function (arg) {
                    return !!(this.compareDocumentPosition(arg) & 16);
                };
            var SURROGATE_PAIR_REGEXP = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g,
                NON_ALPHANUMERIC_REGEXP = /([^#-~ |!])/g;
            var voidElements = toMap("area,br,col,hr,img,wbr");
            var optionalEndTagBlockElements = toMap("colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr"),
                optionalEndTagInlineElements = toMap("rp,rt"),
                optionalEndTagElements = extend({}, optionalEndTagInlineElements, optionalEndTagBlockElements);
            var blockElements = extend(
                {},
                optionalEndTagBlockElements,
                toMap("address,article," + "aside,blockquote,caption,center,del,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5," + "h6,header,hgroup,hr,ins,map,menu,nav,ol,pre,section,table,ul")
            );
            var inlineElements = extend(
                {},
                optionalEndTagInlineElements,
                toMap("a,abbr,acronym,b," + "bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,q,ruby,rp,rt,s," + "samp,small,span,strike,strong,sub,sup,time,tt,u,var")
            );
            var svgElements = toMap(
                "circle,defs,desc,ellipse,font-face,font-face-name,font-face-src,g,glyph," +
                "hkern,image,linearGradient,line,marker,metadata,missing-glyph,mpath,path,polygon,polyline," +
                "radialGradient,rect,stop,svg,switch,text,title,tspan"
            );
            var blockedElements = toMap("script,style");
            var validElements = extend({}, voidElements, blockElements, inlineElements, optionalEndTagElements);
            var uriAttrs = toMap("background,cite,href,longdesc,src,xlink:href");
            var htmlAttrs = toMap(
                "abbr,align,alt,axis,bgcolor,border,cellpadding,cellspacing,class,clear," +
                "color,cols,colspan,compact,coords,dir,face,headers,height,hreflang,hspace," +
                "ismap,lang,language,nohref,nowrap,rel,rev,rows,rowspan,rules," +
                "scope,scrolling,shape,size,span,start,summary,tabindex,target,title,type," +
                "valign,value,vspace,width"
            );
            var svgAttrs = toMap(
                "accent-height,accumulate,additive,alphabetic,arabic-form,ascent," +
                "baseProfile,bbox,begin,by,calcMode,cap-height,class,color,color-rendering,content," +
                "cx,cy,d,dx,dy,descent,display,dur,end,fill,fill-rule,font-family,font-size,font-stretch," +
                "font-style,font-variant,font-weight,from,fx,fy,g1,g2,glyph-name,gradientUnits,hanging," +
                "height,horiz-adv-x,horiz-origin-x,ideographic,k,keyPoints,keySplines,keyTimes,lang," +
                "marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,mathematical," +
                "max,min,offset,opacity,orient,origin,overline-position,overline-thickness,panose-1," +
                "path,pathLength,points,preserveAspectRatio,r,refX,refY,repeatCount,repeatDur," +
                "requiredExtensions,requiredFeatures,restart,rotate,rx,ry,slope,stemh,stemv,stop-color," +
                "stop-opacity,strikethrough-position,strikethrough-thickness,stroke,stroke-dasharray," +
                "stroke-dashoffset,stroke-linecap,stroke-linejoin,stroke-miterlimit,stroke-opacity," +
                "stroke-width,systemLanguage,target,text-anchor,to,transform,type,u1,u2,underline-position," +
                "underline-thickness,unicode,unicode-range,units-per-em,values,version,viewBox,visibility," +
                "width,widths,x,x-height,x1,x2,xlink:actuate,xlink:arcrole,xlink:role,xlink:show,xlink:title," +
                "xlink:type,xml:base,xml:lang,xml:space,xmlns,xmlns:xlink,y,y1,y2,zoomAndPan",
                true
            );
            var validAttrs = extend({}, uriAttrs, svgAttrs, htmlAttrs);
            function toMap(str, lowercaseKeys) {
                var obj = {},
                    items = str.split(","),
                    i;
                for (i = 0; i < items.length; i++) {
                    obj[lowercaseKeys ? lowercase(items[i]) : items[i]] = true;
                }
                return obj;
            }
            var inertBodyElement;
            (function (window) {
                var doc;
                if (window.document && window.document.implementation) {
                    doc = window.document.implementation.createHTMLDocument("inert");
                } else {
                    throw $sanitizeMinErr("noinert", "Can't create an inert html document");
                }
                var docElement = doc.documentElement || doc.getDocumentElement();
                var bodyElements = docElement.getElementsByTagName("body");
                if (bodyElements.length === 1) {
                    inertBodyElement = bodyElements[0];
                } else {
                    var html = doc.createElement("html");
                    inertBodyElement = doc.createElement("body");
                    html.appendChild(inertBodyElement);
                    doc.appendChild(html);
                }
            })(window);
            function htmlParserImpl(html, handler) {
                if (html === null || html === undefined) {
                    html = "";
                } else if (typeof html !== "string") {
                    html = "" + html;
                }
                inertBodyElement.innerHTML = html;
                var mXSSAttempts = 5;
                do {
                    if (mXSSAttempts === 0) {
                        throw $sanitizeMinErr("uinput", "Failed to sanitize html because the input is unstable");
                    }
                    mXSSAttempts--;
                    if (window.document.documentMode) {
                        stripCustomNsAttrs(inertBodyElement);
                    }
                    html = inertBodyElement.innerHTML;
                    inertBodyElement.innerHTML = html;
                } while (html !== inertBodyElement.innerHTML);
                var node = inertBodyElement.firstChild;
                while (node) {
                    switch (node.nodeType) {
                        case 1:
                            handler.start(node.nodeName.toLowerCase(), attrToMap(node.attributes));
                            break;
                        case 3:
                            handler.chars(node.textContent);
                            break;
                    }
                    var nextNode;
                    if (!(nextNode = node.firstChild)) {
                        if (node.nodeType === 1) {
                            handler.end(node.nodeName.toLowerCase());
                        }
                        nextNode = getNonDescendant("nextSibling", node);
                        if (!nextNode) {
                            while (nextNode == null) {
                                node = getNonDescendant("parentNode", node);
                                if (node === inertBodyElement) break;
                                nextNode = getNonDescendant("nextSibling", node);
                                if (node.nodeType === 1) {
                                    handler.end(node.nodeName.toLowerCase());
                                }
                            }
                        }
                    }
                    node = nextNode;
                }
                while ((node = inertBodyElement.firstChild)) {
                    inertBodyElement.removeChild(node);
                }
            }
            function attrToMap(attrs) {
                var map = {};
                for (var i = 0, ii = attrs.length; i < ii; i++) {
                    var attr = attrs[i];
                    map[attr.name] = attr.value;
                }
                return map;
            }
            function encodeEntities(value) {
                return value
                    .replace(/&/g, "&amp;")
                    .replace(SURROGATE_PAIR_REGEXP, function (value) {
                        var hi = value.charCodeAt(0);
                        var low = value.charCodeAt(1);
                        return "&#" + ((hi - 55296) * 1024 + (low - 56320) + 65536) + ";";
                    })
                    .replace(NON_ALPHANUMERIC_REGEXP, function (value) {
                        return "&#" + value.charCodeAt(0) + ";";
                    })
                    .replace(/</g, "&lt;")
                    .replace(/>/g, "&gt;");
            }
            function htmlSanitizeWriterImpl(buf, uriValidator) {
                var ignoreCurrentElement = false;
                var out = bind(buf, buf.push);
                return {
                    start: function (tag, attrs) {
                        tag = lowercase(tag);
                        if (!ignoreCurrentElement && blockedElements[tag]) {
                            ignoreCurrentElement = tag;
                        }
                        if (!ignoreCurrentElement && validElements[tag] === true) {
                            out("<");
                            out(tag);
                            forEach(attrs, function (value, key) {
                                var lkey = lowercase(key);
                                var isImage = (tag === "img" && lkey === "src") || lkey === "background";
                                if (validAttrs[lkey] === true && (uriAttrs[lkey] !== true || uriValidator(value, isImage))) {
                                    out(" ");
                                    out(key);
                                    out('="');
                                    out(encodeEntities(value));
                                    out('"');
                                }
                            });
                            out(">");
                        }
                    },
                    end: function (tag) {
                        tag = lowercase(tag);
                        if (!ignoreCurrentElement && validElements[tag] === true && voidElements[tag] !== true) {
                            out("</");
                            out(tag);
                            out(">");
                        }
                        if (tag == ignoreCurrentElement) {
                            ignoreCurrentElement = false;
                        }
                    },
                    chars: function (chars) {
                        if (!ignoreCurrentElement) {
                            out(encodeEntities(chars));
                        }
                    },
                };
            }
            function stripCustomNsAttrs(node) {
                while (node) {
                    if (node.nodeType === window.Node.ELEMENT_NODE) {
                        var attrs = node.attributes;
                        for (var i = 0, l = attrs.length; i < l; i++) {
                            var attrNode = attrs[i];
                            var attrName = attrNode.name.toLowerCase();
                            if (attrName === "xmlns:ns1" || attrName.lastIndexOf("ns1:", 0) === 0) {
                                node.removeAttributeNode(attrNode);
                                i--;
                                l--;
                            }
                        }
                    }
                    var nextNode = node.firstChild;
                    if (nextNode) {
                        stripCustomNsAttrs(nextNode);
                    }
                    node = getNonDescendant("nextSibling", node);
                }
            }
            function getNonDescendant(propName, node) {
                var nextNode = node[propName];
                if (nextNode && nodeContains.call(node, nextNode)) {
                    throw $sanitizeMinErr("elclob", "Failed to sanitize html because the element is clobbered: {0}", node.outerHTML || node.outerText);
                }
                return nextNode;
            }
        }
        function sanitizeText(chars) {
            var buf = [];
            var writer = htmlSanitizeWriter(buf, noop);
            writer.chars(chars);
            return buf.join("");
        }
        angular.module("ngSanitize", []).provider("$sanitize", $SanitizeProvider).info({ angularVersion: "1.6.4" });
        angular.module("ngSanitize").filter("linky", [
            "$sanitize",
            function ($sanitize) {
                var LINKY_URL_REGEXP = /((ftp|https?):\/\/|(www\.)|(mailto:)?[A-Za-z0-9._%+-]+@)\S*[^\s.;,(){}<>"\u201d\u2019]/i,
                    MAILTO_REGEXP = /^mailto:/i;
                var linkyMinErr = angular.$$minErr("linky");
                var isDefined = angular.isDefined;
                var isFunction = angular.isFunction;
                var isObject = angular.isObject;
                var isString = angular.isString;
                return function (text, target, attributes) {
                    if (text == null || text === "") return text;
                    if (!isString(text)) throw linkyMinErr("notstring", "Expected string but received: {0}", text);
                    var attributesFn = isFunction(attributes)
                        ? attributes
                        : isObject(attributes)
                            ? function getAttributesObject() {
                                return attributes;
                            }
                            : function getEmptyAttributesObject() {
                                return {};
                            };
                    var match;
                    var raw = text;
                    var html = [];
                    var url;
                    var i;
                    while ((match = raw.match(LINKY_URL_REGEXP))) {
                        url = match[0];
                        if (!match[2] && !match[4]) {
                            url = (match[3] ? "http://" : "mailto:") + url;
                        }
                        i = match.index;
                        addText(raw.substr(0, i));
                        addLink(url, match[0].replace(MAILTO_REGEXP, ""));
                        raw = raw.substring(i + match[0].length);
                    }
                    addText(raw);
                    return $sanitize(html.join(""));
                    function addText(text) {
                        if (!text) {
                            return;
                        }
                        html.push(sanitizeText(text));
                    }
                    function addLink(url, text) {
                        var key,
                            linkAttributes = attributesFn(url);
                        html.push("<a ");
                        for (key in linkAttributes) {
                            html.push(key + '="' + linkAttributes[key] + '" ');
                        }
                        if (isDefined(target) && !("target" in linkAttributes)) {
                            html.push('target="', target, '" ');
                        }
                        html.push('href="', url.replace(/"/g, "&quot;"), '">');
                        addText(text);
                        html.push("</a>");
                    }
                };
            },
        ]);
    })(window, window.angular);
    (function (window, angular) {
        "use strict";
        var ELEMENT_NODE = 1;
        var COMMENT_NODE = 8;
        var ADD_CLASS_SUFFIX = "-add";
        var REMOVE_CLASS_SUFFIX = "-remove";
        var EVENT_CLASS_PREFIX = "ng-";
        var ACTIVE_CLASS_SUFFIX = "-active";
        var PREPARE_CLASS_SUFFIX = "-prepare";
        var NG_ANIMATE_CLASSNAME = "ng-animate";
        var NG_ANIMATE_CHILDREN_DATA = "$$ngAnimateChildren";
        var CSS_PREFIX = "",
            TRANSITION_PROP,
            TRANSITIONEND_EVENT,
            ANIMATION_PROP,
            ANIMATIONEND_EVENT;
        if (window.ontransitionend === undefined && window.onwebkittransitionend !== undefined) {
            CSS_PREFIX = "-webkit-";
            TRANSITION_PROP = "WebkitTransition";
            TRANSITIONEND_EVENT = "webkitTransitionEnd transitionend";
        } else {
            TRANSITION_PROP = "transition";
            TRANSITIONEND_EVENT = "transitionend";
        }
        if (window.onanimationend === undefined && window.onwebkitanimationend !== undefined) {
            CSS_PREFIX = "-webkit-";
            ANIMATION_PROP = "WebkitAnimation";
            ANIMATIONEND_EVENT = "webkitAnimationEnd animationend";
        } else {
            ANIMATION_PROP = "animation";
            ANIMATIONEND_EVENT = "animationend";
        }
        var DURATION_KEY = "Duration";
        var PROPERTY_KEY = "Property";
        var DELAY_KEY = "Delay";
        var TIMING_KEY = "TimingFunction";
        var ANIMATION_ITERATION_COUNT_KEY = "IterationCount";
        var ANIMATION_PLAYSTATE_KEY = "PlayState";
        var SAFE_FAST_FORWARD_DURATION_VALUE = 9999;
        var ANIMATION_DELAY_PROP = ANIMATION_PROP + DELAY_KEY;
        var ANIMATION_DURATION_PROP = ANIMATION_PROP + DURATION_KEY;
        var TRANSITION_DELAY_PROP = TRANSITION_PROP + DELAY_KEY;
        var TRANSITION_DURATION_PROP = TRANSITION_PROP + DURATION_KEY;
        var ngMinErr = angular.$$minErr("ng");
        function assertArg(arg, name, reason) {
            if (!arg) {
                throw ngMinErr("areq", "Argument '{0}' is {1}", name || "?", reason || "required");
            }
            return arg;
        }
        function mergeClasses(a, b) {
            if (!a && !b) return "";
            if (!a) return b;
            if (!b) return a;
            if (isArray(a)) a = a.join(" ");
            if (isArray(b)) b = b.join(" ");
            return a + " " + b;
        }
        function packageStyles(options) {
            var styles = {};
            if (options && (options.to || options.from)) {
                styles.to = options.to;
                styles.from = options.from;
            }
            return styles;
        }
        function pendClasses(classes, fix, isPrefix) {
            var className = "";
            classes = isArray(classes) ? classes : classes && isString(classes) && classes.length ? classes.split(/\s+/) : [];
            forEach(classes, function (klass, i) {
                if (klass && klass.length > 0) {
                    className += i > 0 ? " " : "";
                    className += isPrefix ? fix + klass : klass + fix;
                }
            });
            return className;
        }
        function removeFromArray(arr, val) {
            var index = arr.indexOf(val);
            if (val >= 0) {
                arr.splice(index, 1);
            }
        }
        function stripCommentsFromElement(element) {
            if (element instanceof jqLite) {
                switch (element.length) {
                    case 0:
                        return element;
                    case 1:
                        if (element[0].nodeType === ELEMENT_NODE) {
                            return element;
                        }
                        break;
                    default:
                        return jqLite(extractElementNode(element));
                }
            }
            if (element.nodeType === ELEMENT_NODE) {
                return jqLite(element);
            }
        }
        function extractElementNode(element) {
            if (!element[0]) return element;
            for (var i = 0; i < element.length; i++) {
                var elm = element[i];
                if (elm.nodeType === ELEMENT_NODE) {
                    return elm;
                }
            }
        }
        function $$addClass($$jqLite, element, className) {
            forEach(element, function (elm) {
                $$jqLite.addClass(elm, className);
            });
        }
        function $$removeClass($$jqLite, element, className) {
            forEach(element, function (elm) {
                $$jqLite.removeClass(elm, className);
            });
        }
        function applyAnimationClassesFactory($$jqLite) {
            return function (element, options) {
                if (options.addClass) {
                    $$addClass($$jqLite, element, options.addClass);
                    options.addClass = null;
                }
                if (options.removeClass) {
                    $$removeClass($$jqLite, element, options.removeClass);
                    options.removeClass = null;
                }
            };
        }
        function prepareAnimationOptions(options) {
            options = options || {};
            if (!options.$$prepared) {
                var domOperation = options.domOperation || noop;
                options.domOperation = function () {
                    options.$$domOperationFired = true;
                    domOperation();
                    domOperation = noop;
                };
                options.$$prepared = true;
            }
            return options;
        }
        function applyAnimationStyles(element, options) {
            applyAnimationFromStyles(element, options);
            applyAnimationToStyles(element, options);
        }
        function applyAnimationFromStyles(element, options) {
            if (options.from) {
                element.css(options.from);
                options.from = null;
            }
        }
        function applyAnimationToStyles(element, options) {
            if (options.to) {
                element.css(options.to);
                options.to = null;
            }
        }
        function mergeAnimationDetails(element, oldAnimation, newAnimation) {
            var target = oldAnimation.options || {};
            var newOptions = newAnimation.options || {};
            var toAdd = (target.addClass || "") + " " + (newOptions.addClass || "");
            var toRemove = (target.removeClass || "") + " " + (newOptions.removeClass || "");
            var classes = resolveElementClasses(element.attr("class"), toAdd, toRemove);
            if (newOptions.preparationClasses) {
                target.preparationClasses = concatWithSpace(newOptions.preparationClasses, target.preparationClasses);
                delete newOptions.preparationClasses;
            }
            var realDomOperation = target.domOperation !== noop ? target.domOperation : null;
            extend(target, newOptions);
            if (realDomOperation) {
                target.domOperation = realDomOperation;
            }
            if (classes.addClass) {
                target.addClass = classes.addClass;
            } else {
                target.addClass = null;
            }
            if (classes.removeClass) {
                target.removeClass = classes.removeClass;
            } else {
                target.removeClass = null;
            }
            oldAnimation.addClass = target.addClass;
            oldAnimation.removeClass = target.removeClass;
            return target;
        }
        function resolveElementClasses(existing, toAdd, toRemove) {
            var ADD_CLASS = 1;
            var REMOVE_CLASS = -1;
            var flags = {};
            existing = splitClassesToLookup(existing);
            toAdd = splitClassesToLookup(toAdd);
            forEach(toAdd, function (value, key) {
                flags[key] = ADD_CLASS;
            });
            toRemove = splitClassesToLookup(toRemove);
            forEach(toRemove, function (value, key) {
                flags[key] = flags[key] === ADD_CLASS ? null : REMOVE_CLASS;
            });
            var classes = { addClass: "", removeClass: "" };
            forEach(flags, function (val, klass) {
                var prop, allow;
                if (val === ADD_CLASS) {
                    prop = "addClass";
                    allow = !existing[klass] || existing[klass + REMOVE_CLASS_SUFFIX];
                } else if (val === REMOVE_CLASS) {
                    prop = "removeClass";
                    allow = existing[klass] || existing[klass + ADD_CLASS_SUFFIX];
                }
                if (allow) {
                    if (classes[prop].length) {
                        classes[prop] += " ";
                    }
                    classes[prop] += klass;
                }
            });
            function splitClassesToLookup(classes) {
                if (isString(classes)) {
                    classes = classes.split(" ");
                }
                var obj = {};
                forEach(classes, function (klass) {
                    if (klass.length) {
                        obj[klass] = true;
                    }
                });
                return obj;
            }
            return classes;
        }
        function getDomNode(element) {
            return element instanceof jqLite ? element[0] : element;
        }
        function applyGeneratedPreparationClasses(element, event, options) {
            var classes = "";
            if (event) {
                classes = pendClasses(event, EVENT_CLASS_PREFIX, true);
            }
            if (options.addClass) {
                classes = concatWithSpace(classes, pendClasses(options.addClass, ADD_CLASS_SUFFIX));
            }
            if (options.removeClass) {
                classes = concatWithSpace(classes, pendClasses(options.removeClass, REMOVE_CLASS_SUFFIX));
            }
            if (classes.length) {
                options.preparationClasses = classes;
                element.addClass(classes);
            }
        }
        function clearGeneratedClasses(element, options) {
            if (options.preparationClasses) {
                element.removeClass(options.preparationClasses);
                options.preparationClasses = null;
            }
            if (options.activeClasses) {
                element.removeClass(options.activeClasses);
                options.activeClasses = null;
            }
        }
        function blockTransitions(node, duration) {
            var value = duration ? "-" + duration + "s" : "";
            applyInlineStyle(node, [TRANSITION_DELAY_PROP, value]);
            return [TRANSITION_DELAY_PROP, value];
        }
        function blockKeyframeAnimations(node, applyBlock) {
            var value = applyBlock ? "paused" : "";
            var key = ANIMATION_PROP + ANIMATION_PLAYSTATE_KEY;
            applyInlineStyle(node, [key, value]);
            return [key, value];
        }
        function applyInlineStyle(node, styleTuple) {
            var prop = styleTuple[0];
            var value = styleTuple[1];
            node.style[prop] = value;
        }
        function concatWithSpace(a, b) {
            if (!a) return b;
            if (!b) return a;
            return a + " " + b;
        }
        var $$rAFSchedulerFactory = [
            "$$rAF",
            function ($$rAF) {
                var queue, cancelFn;
                function scheduler(tasks) {
                    queue = queue.concat(tasks);
                    nextTick();
                }
                queue = scheduler.queue = [];
                scheduler.waitUntilQuiet = function (fn) {
                    if (cancelFn) cancelFn();
                    cancelFn = $$rAF(function () {
                        cancelFn = null;
                        fn();
                        nextTick();
                    });
                };
                return scheduler;
                function nextTick() {
                    if (!queue.length) return;
                    var items = queue.shift();
                    for (var i = 0; i < items.length; i++) {
                        items[i]();
                    }
                    if (!cancelFn) {
                        $$rAF(function () {
                            if (!cancelFn) nextTick();
                        });
                    }
                }
            },
        ];
        var $$AnimateChildrenDirective = [
            "$interpolate",
            function ($interpolate) {
                return {
                    link: function (scope, element, attrs) {
                        var val = attrs.ngAnimateChildren;
                        if (isString(val) && val.length === 0) {
                            element.data(NG_ANIMATE_CHILDREN_DATA, true);
                        } else {
                            setData($interpolate(val)(scope));
                            attrs.$observe("ngAnimateChildren", setData);
                        }
                        function setData(value) {
                            value = value === "on" || value === "true";
                            element.data(NG_ANIMATE_CHILDREN_DATA, value);
                        }
                    },
                };
            },
        ];
        var ANIMATE_TIMER_KEY = "$$animateCss";
        var ONE_SECOND = 1e3;
        var ELAPSED_TIME_MAX_DECIMAL_PLACES = 3;
        var CLOSING_TIME_BUFFER = 1.5;
        var DETECT_CSS_PROPERTIES = {
            transitionDuration: TRANSITION_DURATION_PROP,
            transitionDelay: TRANSITION_DELAY_PROP,
            transitionProperty: TRANSITION_PROP + PROPERTY_KEY,
            animationDuration: ANIMATION_DURATION_PROP,
            animationDelay: ANIMATION_DELAY_PROP,
            animationIterationCount: ANIMATION_PROP + ANIMATION_ITERATION_COUNT_KEY,
        };
        var DETECT_STAGGER_CSS_PROPERTIES = { transitionDuration: TRANSITION_DURATION_PROP, transitionDelay: TRANSITION_DELAY_PROP, animationDuration: ANIMATION_DURATION_PROP, animationDelay: ANIMATION_DELAY_PROP };
        function getCssKeyframeDurationStyle(duration) {
            return [ANIMATION_DURATION_PROP, duration + "s"];
        }
        function getCssDelayStyle(delay, isKeyframeAnimation) {
            var prop = isKeyframeAnimation ? ANIMATION_DELAY_PROP : TRANSITION_DELAY_PROP;
            return [prop, delay + "s"];
        }
        function computeCssStyles($window, element, properties) {
            var styles = Object.create(null);
            var detectedStyles = $window.getComputedStyle(element) || {};
            forEach(properties, function (formalStyleName, actualStyleName) {
                var val = detectedStyles[formalStyleName];
                if (val) {
                    var c = val.charAt(0);
                    if (c === "-" || c === "+" || c >= 0) {
                        val = parseMaxTime(val);
                    }
                    if (val === 0) {
                        val = null;
                    }
                    styles[actualStyleName] = val;
                }
            });
            return styles;
        }
        function parseMaxTime(str) {
            var maxValue = 0;
            var values = str.split(/\s*,\s*/);
            forEach(values, function (value) {
                if (value.charAt(value.length - 1) === "s") {
                    value = value.substring(0, value.length - 1);
                }
                value = parseFloat(value) || 0;
                maxValue = maxValue ? Math.max(value, maxValue) : value;
            });
            return maxValue;
        }
        function truthyTimingValue(val) {
            return val === 0 || val != null;
        }
        function getCssTransitionDurationStyle(duration, applyOnlyDuration) {
            var style = TRANSITION_PROP;
            var value = duration + "s";
            if (applyOnlyDuration) {
                style += DURATION_KEY;
            } else {
                value += " linear all";
            }
            return [style, value];
        }
        function createLocalCacheLookup() {
            var cache = Object.create(null);
            return {
                flush: function () {
                    cache = Object.create(null);
                },
                count: function (key) {
                    var entry = cache[key];
                    return entry ? entry.total : 0;
                },
                get: function (key) {
                    var entry = cache[key];
                    return entry && entry.value;
                },
                put: function (key, value) {
                    if (!cache[key]) {
                        cache[key] = { total: 1, value: value };
                    } else {
                        cache[key].total++;
                    }
                },
            };
        }
        function registerRestorableStyles(backup, node, properties) {
            forEach(properties, function (prop) {
                backup[prop] = isDefined(backup[prop]) ? backup[prop] : node.style.getPropertyValue(prop);
            });
        }
        var $AnimateCssProvider = [
            "$animateProvider",
            function ($animateProvider) {
                var gcsLookup = createLocalCacheLookup();
                var gcsStaggerLookup = createLocalCacheLookup();
                this.$get = [
                    "$window",
                    "$$jqLite",
                    "$$AnimateRunner",
                    "$timeout",
                    "$$forceReflow",
                    "$sniffer",
                    "$$rAFScheduler",
                    "$$animateQueue",
                    function ($window, $$jqLite, $$AnimateRunner, $timeout, $$forceReflow, $sniffer, $$rAFScheduler, $$animateQueue) {
                        var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);
                        var parentCounter = 0;
                        function gcsHashFn(node, extraClasses) {
                            var KEY = "$$ngAnimateParentKey";
                            var parentNode = node.parentNode;
                            var parentID = parentNode[KEY] || (parentNode[KEY] = ++parentCounter);
                            return parentID + "-" + node.getAttribute("class") + "-" + extraClasses;
                        }
                        function computeCachedCssStyles(node, className, cacheKey, properties) {
                            var timings = gcsLookup.get(cacheKey);
                            if (!timings) {
                                timings = computeCssStyles($window, node, properties);
                                if (timings.animationIterationCount === "infinite") {
                                    timings.animationIterationCount = 1;
                                }
                            }
                            gcsLookup.put(cacheKey, timings);
                            return timings;
                        }
                        function computeCachedCssStaggerStyles(node, className, cacheKey, properties) {
                            var stagger;
                            if (gcsLookup.count(cacheKey) > 0) {
                                stagger = gcsStaggerLookup.get(cacheKey);
                                if (!stagger) {
                                    var staggerClassName = pendClasses(className, "-stagger");
                                    $$jqLite.addClass(node, staggerClassName);
                                    stagger = computeCssStyles($window, node, properties);
                                    stagger.animationDuration = Math.max(stagger.animationDuration, 0);
                                    stagger.transitionDuration = Math.max(stagger.transitionDuration, 0);
                                    $$jqLite.removeClass(node, staggerClassName);
                                    gcsStaggerLookup.put(cacheKey, stagger);
                                }
                            }
                            return stagger || {};
                        }
                        var rafWaitQueue = [];
                        function waitUntilQuiet(callback) {
                            rafWaitQueue.push(callback);
                            $$rAFScheduler.waitUntilQuiet(function () {
                                gcsLookup.flush();
                                gcsStaggerLookup.flush();
                                var pageWidth = $$forceReflow();
                                for (var i = 0; i < rafWaitQueue.length; i++) {
                                    rafWaitQueue[i](pageWidth);
                                }
                                rafWaitQueue.length = 0;
                            });
                        }
                        function computeTimings(node, className, cacheKey) {
                            var timings = computeCachedCssStyles(node, className, cacheKey, DETECT_CSS_PROPERTIES);
                            var aD = timings.animationDelay;
                            var tD = timings.transitionDelay;
                            timings.maxDelay = aD && tD ? Math.max(aD, tD) : aD || tD;
                            timings.maxDuration = Math.max(timings.animationDuration * timings.animationIterationCount, timings.transitionDuration);
                            return timings;
                        }
                        return function init(element, initialOptions) {
                            var options = initialOptions || {};
                            if (!options.$$prepared) {
                                options = prepareAnimationOptions(copy(options));
                            }
                            var restoreStyles = {};
                            var node = getDomNode(element);
                            if (!node || !node.parentNode || !$$animateQueue.enabled()) {
                                return closeAndReturnNoopAnimator();
                            }
                            var temporaryStyles = [];
                            var classes = element.attr("class");
                            var styles = packageStyles(options);
                            var animationClosed;
                            var animationPaused;
                            var animationCompleted;
                            var runner;
                            var runnerHost;
                            var maxDelay;
                            var maxDelayTime;
                            var maxDuration;
                            var maxDurationTime;
                            var startTime;
                            var events = [];
                            if (options.duration === 0 || (!$sniffer.animations && !$sniffer.transitions)) {
                                return closeAndReturnNoopAnimator();
                            }
                            var method = options.event && isArray(options.event) ? options.event.join(" ") : options.event;
                            var isStructural = method && options.structural;
                            var structuralClassName = "";
                            var addRemoveClassName = "";
                            if (isStructural) {
                                structuralClassName = pendClasses(method, EVENT_CLASS_PREFIX, true);
                            } else if (method) {
                                structuralClassName = method;
                            }
                            if (options.addClass) {
                                addRemoveClassName += pendClasses(options.addClass, ADD_CLASS_SUFFIX);
                            }
                            if (options.removeClass) {
                                if (addRemoveClassName.length) {
                                    addRemoveClassName += " ";
                                }
                                addRemoveClassName += pendClasses(options.removeClass, REMOVE_CLASS_SUFFIX);
                            }
                            if (options.applyClassesEarly && addRemoveClassName.length) {
                                applyAnimationClasses(element, options);
                            }
                            var preparationClasses = [structuralClassName, addRemoveClassName].join(" ").trim();
                            var fullClassName = classes + " " + preparationClasses;
                            var activeClasses = pendClasses(preparationClasses, ACTIVE_CLASS_SUFFIX);
                            var hasToStyles = styles.to && Object.keys(styles.to).length > 0;
                            var containsKeyframeAnimation = (options.keyframeStyle || "").length > 0;
                            if (!containsKeyframeAnimation && !hasToStyles && !preparationClasses) {
                                return closeAndReturnNoopAnimator();
                            }
                            var cacheKey, stagger;
                            if (options.stagger > 0) {
                                var staggerVal = parseFloat(options.stagger);
                                stagger = { transitionDelay: staggerVal, animationDelay: staggerVal, transitionDuration: 0, animationDuration: 0 };
                            } else {
                                cacheKey = gcsHashFn(node, fullClassName);
                                stagger = computeCachedCssStaggerStyles(node, preparationClasses, cacheKey, DETECT_STAGGER_CSS_PROPERTIES);
                            }
                            if (!options.$$skipPreparationClasses) {
                                $$jqLite.addClass(element, preparationClasses);
                            }
                            var applyOnlyDuration;
                            if (options.transitionStyle) {
                                var transitionStyle = [TRANSITION_PROP, options.transitionStyle];
                                applyInlineStyle(node, transitionStyle);
                                temporaryStyles.push(transitionStyle);
                            }
                            if (options.duration >= 0) {
                                applyOnlyDuration = node.style[TRANSITION_PROP].length > 0;
                                var durationStyle = getCssTransitionDurationStyle(options.duration, applyOnlyDuration);
                                applyInlineStyle(node, durationStyle);
                                temporaryStyles.push(durationStyle);
                            }
                            if (options.keyframeStyle) {
                                var keyframeStyle = [ANIMATION_PROP, options.keyframeStyle];
                                applyInlineStyle(node, keyframeStyle);
                                temporaryStyles.push(keyframeStyle);
                            }
                            var itemIndex = stagger ? (options.staggerIndex >= 0 ? options.staggerIndex : gcsLookup.count(cacheKey)) : 0;
                            var isFirst = itemIndex === 0;
                            if (isFirst && !options.skipBlocking) {
                                blockTransitions(node, SAFE_FAST_FORWARD_DURATION_VALUE);
                            }
                            var timings = computeTimings(node, fullClassName, cacheKey);
                            var relativeDelay = timings.maxDelay;
                            maxDelay = Math.max(relativeDelay, 0);
                            maxDuration = timings.maxDuration;
                            var flags = {};
                            flags.hasTransitions = timings.transitionDuration > 0;
                            flags.hasAnimations = timings.animationDuration > 0;
                            flags.hasTransitionAll = flags.hasTransitions && timings.transitionProperty === "all";
                            flags.applyTransitionDuration = hasToStyles && ((flags.hasTransitions && !flags.hasTransitionAll) || (flags.hasAnimations && !flags.hasTransitions));
                            flags.applyAnimationDuration = options.duration && flags.hasAnimations;
                            flags.applyTransitionDelay = truthyTimingValue(options.delay) && (flags.applyTransitionDuration || flags.hasTransitions);
                            flags.applyAnimationDelay = truthyTimingValue(options.delay) && flags.hasAnimations;
                            flags.recalculateTimingStyles = addRemoveClassName.length > 0;
                            if (flags.applyTransitionDuration || flags.applyAnimationDuration) {
                                maxDuration = options.duration ? parseFloat(options.duration) : maxDuration;
                                if (flags.applyTransitionDuration) {
                                    flags.hasTransitions = true;
                                    timings.transitionDuration = maxDuration;
                                    applyOnlyDuration = node.style[TRANSITION_PROP + PROPERTY_KEY].length > 0;
                                    temporaryStyles.push(getCssTransitionDurationStyle(maxDuration, applyOnlyDuration));
                                }
                                if (flags.applyAnimationDuration) {
                                    flags.hasAnimations = true;
                                    timings.animationDuration = maxDuration;
                                    temporaryStyles.push(getCssKeyframeDurationStyle(maxDuration));
                                }
                            }
                            if (maxDuration === 0 && !flags.recalculateTimingStyles) {
                                return closeAndReturnNoopAnimator();
                            }
                            if (options.delay != null) {
                                var delayStyle;
                                if (typeof options.delay !== "boolean") {
                                    delayStyle = parseFloat(options.delay);
                                    maxDelay = Math.max(delayStyle, 0);
                                }
                                if (flags.applyTransitionDelay) {
                                    temporaryStyles.push(getCssDelayStyle(delayStyle));
                                }
                                if (flags.applyAnimationDelay) {
                                    temporaryStyles.push(getCssDelayStyle(delayStyle, true));
                                }
                            }
                            if (options.duration == null && timings.transitionDuration > 0) {
                                flags.recalculateTimingStyles = flags.recalculateTimingStyles || isFirst;
                            }
                            maxDelayTime = maxDelay * ONE_SECOND;
                            maxDurationTime = maxDuration * ONE_SECOND;
                            if (!options.skipBlocking) {
                                flags.blockTransition = timings.transitionDuration > 0;
                                flags.blockKeyframeAnimation = timings.animationDuration > 0 && stagger.animationDelay > 0 && stagger.animationDuration === 0;
                            }
                            if (options.from) {
                                if (options.cleanupStyles) {
                                    registerRestorableStyles(restoreStyles, node, Object.keys(options.from));
                                }
                                applyAnimationFromStyles(element, options);
                            }
                            if (flags.blockTransition || flags.blockKeyframeAnimation) {
                                applyBlocking(maxDuration);
                            } else if (!options.skipBlocking) {
                                blockTransitions(node, false);
                            }
                            return {
                                $$willAnimate: true,
                                end: endFn,
                                start: function () {
                                    if (animationClosed) return;
                                    runnerHost = { end: endFn, cancel: cancelFn, resume: null, pause: null };
                                    runner = new $$AnimateRunner(runnerHost);
                                    waitUntilQuiet(start);
                                    return runner;
                                },
                            };
                            function endFn() {
                                close();
                            }
                            function cancelFn() {
                                close(true);
                            }
                            function close(rejected) {
                                if (animationClosed || (animationCompleted && animationPaused)) return;
                                animationClosed = true;
                                animationPaused = false;
                                if (!options.$$skipPreparationClasses) {
                                    $$jqLite.removeClass(element, preparationClasses);
                                }
                                $$jqLite.removeClass(element, activeClasses);
                                blockKeyframeAnimations(node, false);
                                blockTransitions(node, false);
                                forEach(temporaryStyles, function (entry) {
                                    node.style[entry[0]] = "";
                                });
                                applyAnimationClasses(element, options);
                                applyAnimationStyles(element, options);
                                if (Object.keys(restoreStyles).length) {
                                    forEach(restoreStyles, function (value, prop) {
                                        if (value) {
                                            node.style.setProperty(prop, value);
                                        } else {
                                            node.style.removeProperty(prop);
                                        }
                                    });
                                }
                                if (options.onDone) {
                                    options.onDone();
                                }
                                if (events && events.length) {
                                    element.off(events.join(" "), onAnimationProgress);
                                }
                                var animationTimerData = element.data(ANIMATE_TIMER_KEY);
                                if (animationTimerData) {
                                    $timeout.cancel(animationTimerData[0].timer);
                                    element.removeData(ANIMATE_TIMER_KEY);
                                }
                                if (runner) {
                                    runner.complete(!rejected);
                                }
                            }
                            function applyBlocking(duration) {
                                if (flags.blockTransition) {
                                    blockTransitions(node, duration);
                                }
                                if (flags.blockKeyframeAnimation) {
                                    blockKeyframeAnimations(node, !!duration);
                                }
                            }
                            function closeAndReturnNoopAnimator() {
                                runner = new $$AnimateRunner({ end: endFn, cancel: cancelFn });
                                waitUntilQuiet(noop);
                                close();
                                return {
                                    $$willAnimate: false,
                                    start: function () {
                                        return runner;
                                    },
                                    end: endFn,
                                };
                            }
                            function onAnimationProgress(event) {
                                event.stopPropagation();
                                var ev = event.originalEvent || event;
                                var timeStamp = ev.$manualTimeStamp || Date.now();
                                var elapsedTime = parseFloat(ev.elapsedTime.toFixed(ELAPSED_TIME_MAX_DECIMAL_PLACES));
                                if (Math.max(timeStamp - startTime, 0) >= maxDelayTime && elapsedTime >= maxDuration) {
                                    animationCompleted = true;
                                    close();
                                }
                            }
                            function start() {
                                if (animationClosed) return;
                                if (!node.parentNode) {
                                    close();
                                    return;
                                }
                                var playPause = function (playAnimation) {
                                    if (!animationCompleted) {
                                        animationPaused = !playAnimation;
                                        if (timings.animationDuration) {
                                            var value = blockKeyframeAnimations(node, animationPaused);
                                            if (animationPaused) {
                                                temporaryStyles.push(value);
                                            } else {
                                                removeFromArray(temporaryStyles, value);
                                            }
                                        }
                                    } else if (animationPaused && playAnimation) {
                                        animationPaused = false;
                                        close();
                                    }
                                };
                                var maxStagger =
                                    itemIndex > 0 &&
                                    ((timings.transitionDuration && stagger.transitionDuration === 0) || (timings.animationDuration && stagger.animationDuration === 0)) &&
                                    Math.max(stagger.animationDelay, stagger.transitionDelay);
                                if (maxStagger) {
                                    $timeout(triggerAnimationStart, Math.floor(maxStagger * itemIndex * ONE_SECOND), false);
                                } else {
                                    triggerAnimationStart();
                                }
                                runnerHost.resume = function () {
                                    playPause(true);
                                };
                                runnerHost.pause = function () {
                                    playPause(false);
                                };
                                function triggerAnimationStart() {
                                    if (animationClosed) return;
                                    applyBlocking(false);
                                    forEach(temporaryStyles, function (entry) {
                                        var key = entry[0];
                                        var value = entry[1];
                                        node.style[key] = value;
                                    });
                                    applyAnimationClasses(element, options);
                                    $$jqLite.addClass(element, activeClasses);
                                    if (flags.recalculateTimingStyles) {
                                        fullClassName = node.getAttribute("class") + " " + preparationClasses;
                                        cacheKey = gcsHashFn(node, fullClassName);
                                        timings = computeTimings(node, fullClassName, cacheKey);
                                        relativeDelay = timings.maxDelay;
                                        maxDelay = Math.max(relativeDelay, 0);
                                        maxDuration = timings.maxDuration;
                                        if (maxDuration === 0) {
                                            close();
                                            return;
                                        }
                                        flags.hasTransitions = timings.transitionDuration > 0;
                                        flags.hasAnimations = timings.animationDuration > 0;
                                    }
                                    if (flags.applyAnimationDelay) {
                                        relativeDelay = typeof options.delay !== "boolean" && truthyTimingValue(options.delay) ? parseFloat(options.delay) : relativeDelay;
                                        maxDelay = Math.max(relativeDelay, 0);
                                        timings.animationDelay = relativeDelay;
                                        delayStyle = getCssDelayStyle(relativeDelay, true);
                                        temporaryStyles.push(delayStyle);
                                        node.style[delayStyle[0]] = delayStyle[1];
                                    }
                                    maxDelayTime = maxDelay * ONE_SECOND;
                                    maxDurationTime = maxDuration * ONE_SECOND;
                                    if (options.easing) {
                                        var easeProp,
                                            easeVal = options.easing;
                                        if (flags.hasTransitions) {
                                            easeProp = TRANSITION_PROP + TIMING_KEY;
                                            temporaryStyles.push([easeProp, easeVal]);
                                            node.style[easeProp] = easeVal;
                                        }
                                        if (flags.hasAnimations) {
                                            easeProp = ANIMATION_PROP + TIMING_KEY;
                                            temporaryStyles.push([easeProp, easeVal]);
                                            node.style[easeProp] = easeVal;
                                        }
                                    }
                                    if (timings.transitionDuration) {
                                        events.push(TRANSITIONEND_EVENT);
                                    }
                                    if (timings.animationDuration) {
                                        events.push(ANIMATIONEND_EVENT);
                                    }
                                    startTime = Date.now();
                                    var timerTime = maxDelayTime + CLOSING_TIME_BUFFER * maxDurationTime;
                                    var endTime = startTime + timerTime;
                                    var animationsData = element.data(ANIMATE_TIMER_KEY) || [];
                                    var setupFallbackTimer = true;
                                    if (animationsData.length) {
                                        var currentTimerData = animationsData[0];
                                        setupFallbackTimer = endTime > currentTimerData.expectedEndTime;
                                        if (setupFallbackTimer) {
                                            $timeout.cancel(currentTimerData.timer);
                                        } else {
                                            animationsData.push(close);
                                        }
                                    }
                                    if (setupFallbackTimer) {
                                        var timer = $timeout(onAnimationExpired, timerTime, false);
                                        animationsData[0] = { timer: timer, expectedEndTime: endTime };
                                        animationsData.push(close);
                                        element.data(ANIMATE_TIMER_KEY, animationsData);
                                    }
                                    if (events.length) {
                                        element.on(events.join(" "), onAnimationProgress);
                                    }
                                    if (options.to) {
                                        if (options.cleanupStyles) {
                                            registerRestorableStyles(restoreStyles, node, Object.keys(options.to));
                                        }
                                        applyAnimationToStyles(element, options);
                                    }
                                }
                                function onAnimationExpired() {
                                    var animationsData = element.data(ANIMATE_TIMER_KEY);
                                    if (animationsData) {
                                        for (var i = 1; i < animationsData.length; i++) {
                                            animationsData[i]();
                                        }
                                        element.removeData(ANIMATE_TIMER_KEY);
                                    }
                                }
                            }
                        };
                    },
                ];
            },
        ];
        var $$AnimateCssDriverProvider = [
            "$$animationProvider",
            function ($$animationProvider) {
                $$animationProvider.drivers.push("$$animateCssDriver");
                var NG_ANIMATE_SHIM_CLASS_NAME = "ng-animate-shim";
                var NG_ANIMATE_ANCHOR_CLASS_NAME = "ng-anchor";
                var NG_OUT_ANCHOR_CLASS_NAME = "ng-anchor-out";
                var NG_IN_ANCHOR_CLASS_NAME = "ng-anchor-in";
                function isDocumentFragment(node) {
                    return node.parentNode && node.parentNode.nodeType === 11;
                }
                this.$get = [
                    "$animateCss",
                    "$rootScope",
                    "$$AnimateRunner",
                    "$rootElement",
                    "$sniffer",
                    "$$jqLite",
                    "$document",
                    function ($animateCss, $rootScope, $$AnimateRunner, $rootElement, $sniffer, $$jqLite, $document) {
                        if (!$sniffer.animations && !$sniffer.transitions) return noop;
                        var bodyNode = $document[0].body;
                        var rootNode = getDomNode($rootElement);
                        var rootBodyElement = jqLite(isDocumentFragment(rootNode) || bodyNode.contains(rootNode) ? rootNode : bodyNode);
                        return function initDriverFn(animationDetails) {
                            return animationDetails.from && animationDetails.to
                                ? prepareFromToAnchorAnimation(animationDetails.from, animationDetails.to, animationDetails.classes, animationDetails.anchors)
                                : prepareRegularAnimation(animationDetails);
                        };
                        function filterCssClasses(classes) {
                            return classes.replace(/\bng-\S+\b/g, "");
                        }
                        function getUniqueValues(a, b) {
                            if (isString(a)) a = a.split(" ");
                            if (isString(b)) b = b.split(" ");
                            return a
                                .filter(function (val) {
                                    return b.indexOf(val) === -1;
                                })
                                .join(" ");
                        }
                        function prepareAnchoredAnimation(classes, outAnchor, inAnchor) {
                            var clone = jqLite(getDomNode(outAnchor).cloneNode(true));
                            var startingClasses = filterCssClasses(getClassVal(clone));
                            outAnchor.addClass(NG_ANIMATE_SHIM_CLASS_NAME);
                            inAnchor.addClass(NG_ANIMATE_SHIM_CLASS_NAME);
                            clone.addClass(NG_ANIMATE_ANCHOR_CLASS_NAME);
                            rootBodyElement.append(clone);
                            var animatorIn,
                                animatorOut = prepareOutAnimation();
                            if (!animatorOut) {
                                animatorIn = prepareInAnimation();
                                if (!animatorIn) {
                                    return end();
                                }
                            }
                            var startingAnimator = animatorOut || animatorIn;
                            return {
                                start: function () {
                                    var runner;
                                    var currentAnimation = startingAnimator.start();
                                    currentAnimation.done(function () {
                                        currentAnimation = null;
                                        if (!animatorIn) {
                                            animatorIn = prepareInAnimation();
                                            if (animatorIn) {
                                                currentAnimation = animatorIn.start();
                                                currentAnimation.done(function () {
                                                    currentAnimation = null;
                                                    end();
                                                    runner.complete();
                                                });
                                                return currentAnimation;
                                            }
                                        }
                                        end();
                                        runner.complete();
                                    });
                                    runner = new $$AnimateRunner({ end: endFn, cancel: endFn });
                                    return runner;
                                    function endFn() {
                                        if (currentAnimation) {
                                            currentAnimation.end();
                                        }
                                    }
                                },
                            };
                            function calculateAnchorStyles(anchor) {
                                var styles = {};
                                var coords = getDomNode(anchor).getBoundingClientRect();
                                forEach(["width", "height", "top", "left"], function (key) {
                                    var value = coords[key];
                                    switch (key) {
                                        case "top":
                                            value += bodyNode.scrollTop;
                                            break;
                                        case "left":
                                            value += bodyNode.scrollLeft;
                                            break;
                                    }
                                    styles[key] = Math.floor(value) + "px";
                                });
                                return styles;
                            }
                            function prepareOutAnimation() {
                                var animator = $animateCss(clone, { addClass: NG_OUT_ANCHOR_CLASS_NAME, delay: true, from: calculateAnchorStyles(outAnchor) });
                                return animator.$$willAnimate ? animator : null;
                            }
                            function getClassVal(element) {
                                return element.attr("class") || "";
                            }
                            function prepareInAnimation() {
                                var endingClasses = filterCssClasses(getClassVal(inAnchor));
                                var toAdd = getUniqueValues(endingClasses, startingClasses);
                                var toRemove = getUniqueValues(startingClasses, endingClasses);
                                var animator = $animateCss(clone, { to: calculateAnchorStyles(inAnchor), addClass: NG_IN_ANCHOR_CLASS_NAME + " " + toAdd, removeClass: NG_OUT_ANCHOR_CLASS_NAME + " " + toRemove, delay: true });
                                return animator.$$willAnimate ? animator : null;
                            }
                            function end() {
                                clone.remove();
                                outAnchor.removeClass(NG_ANIMATE_SHIM_CLASS_NAME);
                                inAnchor.removeClass(NG_ANIMATE_SHIM_CLASS_NAME);
                            }
                        }
                        function prepareFromToAnchorAnimation(from, to, classes, anchors) {
                            var fromAnimation = prepareRegularAnimation(from, noop);
                            var toAnimation = prepareRegularAnimation(to, noop);
                            var anchorAnimations = [];
                            forEach(anchors, function (anchor) {
                                var outElement = anchor["out"];
                                var inElement = anchor["in"];
                                var animator = prepareAnchoredAnimation(classes, outElement, inElement);
                                if (animator) {
                                    anchorAnimations.push(animator);
                                }
                            });
                            if (!fromAnimation && !toAnimation && anchorAnimations.length === 0) return;
                            return {
                                start: function () {
                                    var animationRunners = [];
                                    if (fromAnimation) {
                                        animationRunners.push(fromAnimation.start());
                                    }
                                    if (toAnimation) {
                                        animationRunners.push(toAnimation.start());
                                    }
                                    forEach(anchorAnimations, function (animation) {
                                        animationRunners.push(animation.start());
                                    });
                                    var runner = new $$AnimateRunner({ end: endFn, cancel: endFn });
                                    $$AnimateRunner.all(animationRunners, function (status) {
                                        runner.complete(status);
                                    });
                                    return runner;
                                    function endFn() {
                                        forEach(animationRunners, function (runner) {
                                            runner.end();
                                        });
                                    }
                                },
                            };
                        }
                        function prepareRegularAnimation(animationDetails) {
                            var element = animationDetails.element;
                            var options = animationDetails.options || {};
                            if (animationDetails.structural) {
                                options.event = animationDetails.event;
                                options.structural = true;
                                options.applyClassesEarly = true;
                                if (animationDetails.event === "leave") {
                                    options.onDone = options.domOperation;
                                }
                            }
                            if (options.preparationClasses) {
                                options.event = concatWithSpace(options.event, options.preparationClasses);
                            }
                            var animator = $animateCss(element, options);
                            return animator.$$willAnimate ? animator : null;
                        }
                    },
                ];
            },
        ];
        var $$AnimateJsProvider = [
            "$animateProvider",
            function ($animateProvider) {
                this.$get = [
                    "$injector",
                    "$$AnimateRunner",
                    "$$jqLite",
                    function ($injector, $$AnimateRunner, $$jqLite) {
                        var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);
                        return function (element, event, classes, options) {
                            var animationClosed = false;
                            if (arguments.length === 3 && isObject(classes)) {
                                options = classes;
                                classes = null;
                            }
                            options = prepareAnimationOptions(options);
                            if (!classes) {
                                classes = element.attr("class") || "";
                                if (options.addClass) {
                                    classes += " " + options.addClass;
                                }
                                if (options.removeClass) {
                                    classes += " " + options.removeClass;
                                }
                            }
                            var classesToAdd = options.addClass;
                            var classesToRemove = options.removeClass;
                            var animations = lookupAnimations(classes);
                            var before, after;
                            if (animations.length) {
                                var afterFn, beforeFn;
                                if (event === "leave") {
                                    beforeFn = "leave";
                                    afterFn = "afterLeave";
                                } else {
                                    beforeFn = "before" + event.charAt(0).toUpperCase() + event.substr(1);
                                    afterFn = event;
                                }
                                if (event !== "enter" && event !== "move") {
                                    before = packageAnimations(element, event, options, animations, beforeFn);
                                }
                                after = packageAnimations(element, event, options, animations, afterFn);
                            }
                            if (!before && !after) return;
                            function applyOptions() {
                                options.domOperation();
                                applyAnimationClasses(element, options);
                            }
                            function close() {
                                animationClosed = true;
                                applyOptions();
                                applyAnimationStyles(element, options);
                            }
                            var runner;
                            return {
                                $$willAnimate: true,
                                end: function () {
                                    if (runner) {
                                        runner.end();
                                    } else {
                                        close();
                                        runner = new $$AnimateRunner();
                                        runner.complete(true);
                                    }
                                    return runner;
                                },
                                start: function () {
                                    if (runner) {
                                        return runner;
                                    }
                                    runner = new $$AnimateRunner();
                                    var closeActiveAnimations;
                                    var chain = [];
                                    if (before) {
                                        chain.push(function (fn) {
                                            closeActiveAnimations = before(fn);
                                        });
                                    }
                                    if (chain.length) {
                                        chain.push(function (fn) {
                                            applyOptions();
                                            fn(true);
                                        });
                                    } else {
                                        applyOptions();
                                    }
                                    if (after) {
                                        chain.push(function (fn) {
                                            closeActiveAnimations = after(fn);
                                        });
                                    }
                                    runner.setHost({
                                        end: function () {
                                            endAnimations();
                                        },
                                        cancel: function () {
                                            endAnimations(true);
                                        },
                                    });
                                    $$AnimateRunner.chain(chain, onComplete);
                                    return runner;
                                    function onComplete(success) {
                                        close(success);
                                        runner.complete(success);
                                    }
                                    function endAnimations(cancelled) {
                                        if (!animationClosed) {
                                            (closeActiveAnimations || noop)(cancelled);
                                            onComplete(cancelled);
                                        }
                                    }
                                },
                            };
                            function executeAnimationFn(fn, element, event, options, onDone) {
                                var args;
                                switch (event) {
                                    case "animate":
                                        args = [element, options.from, options.to, onDone];
                                        break;
                                    case "setClass":
                                        args = [element, classesToAdd, classesToRemove, onDone];
                                        break;
                                    case "addClass":
                                        args = [element, classesToAdd, onDone];
                                        break;
                                    case "removeClass":
                                        args = [element, classesToRemove, onDone];
                                        break;
                                    default:
                                        args = [element, onDone];
                                        break;
                                }
                                args.push(options);
                                var value = fn.apply(fn, args);
                                if (value) {
                                    if (isFunction(value.start)) {
                                        value = value.start();
                                    }
                                    if (value instanceof $$AnimateRunner) {
                                        value.done(onDone);
                                    } else if (isFunction(value)) {
                                        return value;
                                    }
                                }
                                return noop;
                            }
                            function groupEventedAnimations(element, event, options, animations, fnName) {
                                var operations = [];
                                forEach(animations, function (ani) {
                                    var animation = ani[fnName];
                                    if (!animation) return;
                                    operations.push(function () {
                                        var runner;
                                        var endProgressCb;
                                        var resolved = false;
                                        var onAnimationComplete = function (rejected) {
                                            if (!resolved) {
                                                resolved = true;
                                                (endProgressCb || noop)(rejected);
                                                runner.complete(!rejected);
                                            }
                                        };
                                        runner = new $$AnimateRunner({
                                            end: function () {
                                                onAnimationComplete();
                                            },
                                            cancel: function () {
                                                onAnimationComplete(true);
                                            },
                                        });
                                        endProgressCb = executeAnimationFn(animation, element, event, options, function (result) {
                                            var cancelled = result === false;
                                            onAnimationComplete(cancelled);
                                        });
                                        return runner;
                                    });
                                });
                                return operations;
                            }
                            function packageAnimations(element, event, options, animations, fnName) {
                                var operations = groupEventedAnimations(element, event, options, animations, fnName);
                                if (operations.length === 0) {
                                    var a, b;
                                    if (fnName === "beforeSetClass") {
                                        a = groupEventedAnimations(element, "removeClass", options, animations, "beforeRemoveClass");
                                        b = groupEventedAnimations(element, "addClass", options, animations, "beforeAddClass");
                                    } else if (fnName === "setClass") {
                                        a = groupEventedAnimations(element, "removeClass", options, animations, "removeClass");
                                        b = groupEventedAnimations(element, "addClass", options, animations, "addClass");
                                    }
                                    if (a) {
                                        operations = operations.concat(a);
                                    }
                                    if (b) {
                                        operations = operations.concat(b);
                                    }
                                }
                                if (operations.length === 0) return;
                                return function startAnimation(callback) {
                                    var runners = [];
                                    if (operations.length) {
                                        forEach(operations, function (animateFn) {
                                            runners.push(animateFn());
                                        });
                                    }
                                    if (runners.length) {
                                        $$AnimateRunner.all(runners, callback);
                                    } else {
                                        callback();
                                    }
                                    return function endFn(reject) {
                                        forEach(runners, function (runner) {
                                            if (reject) {
                                                runner.cancel();
                                            } else {
                                                runner.end();
                                            }
                                        });
                                    };
                                };
                            }
                        };
                        function lookupAnimations(classes) {
                            classes = isArray(classes) ? classes : classes.split(" ");
                            var matches = [],
                                flagMap = {};
                            for (var i = 0; i < classes.length; i++) {
                                var klass = classes[i],
                                    animationFactory = $animateProvider.$$registeredAnimations[klass];
                                if (animationFactory && !flagMap[klass]) {
                                    matches.push($injector.get(animationFactory));
                                    flagMap[klass] = true;
                                }
                            }
                            return matches;
                        }
                    },
                ];
            },
        ];
        var $$AnimateJsDriverProvider = [
            "$$animationProvider",
            function ($$animationProvider) {
                $$animationProvider.drivers.push("$$animateJsDriver");
                this.$get = [
                    "$$animateJs",
                    "$$AnimateRunner",
                    function ($$animateJs, $$AnimateRunner) {
                        return function initDriverFn(animationDetails) {
                            if (animationDetails.from && animationDetails.to) {
                                var fromAnimation = prepareAnimation(animationDetails.from);
                                var toAnimation = prepareAnimation(animationDetails.to);
                                if (!fromAnimation && !toAnimation) return;
                                return {
                                    start: function () {
                                        var animationRunners = [];
                                        if (fromAnimation) {
                                            animationRunners.push(fromAnimation.start());
                                        }
                                        if (toAnimation) {
                                            animationRunners.push(toAnimation.start());
                                        }
                                        $$AnimateRunner.all(animationRunners, done);
                                        var runner = new $$AnimateRunner({ end: endFnFactory(), cancel: endFnFactory() });
                                        return runner;
                                        function endFnFactory() {
                                            return function () {
                                                forEach(animationRunners, function (runner) {
                                                    runner.end();
                                                });
                                            };
                                        }
                                        function done(status) {
                                            runner.complete(status);
                                        }
                                    },
                                };
                            } else {
                                return prepareAnimation(animationDetails);
                            }
                        };
                        function prepareAnimation(animationDetails) {
                            var element = animationDetails.element;
                            var event = animationDetails.event;
                            var options = animationDetails.options;
                            var classes = animationDetails.classes;
                            return $$animateJs(element, event, classes, options);
                        }
                    },
                ];
            },
        ];
        var NG_ANIMATE_ATTR_NAME = "data-ng-animate";
        var NG_ANIMATE_PIN_DATA = "$ngAnimatePin";
        var $$AnimateQueueProvider = [
            "$animateProvider",
            function ($animateProvider) {
                var PRE_DIGEST_STATE = 1;
                var RUNNING_STATE = 2;
                var ONE_SPACE = " ";
                var rules = (this.rules = { skip: [], cancel: [], join: [] });
                function makeTruthyCssClassMap(classString) {
                    if (!classString) {
                        return null;
                    }
                    var keys = classString.split(ONE_SPACE);
                    var map = Object.create(null);
                    forEach(keys, function (key) {
                        map[key] = true;
                    });
                    return map;
                }
                function hasMatchingClasses(newClassString, currentClassString) {
                    if (newClassString && currentClassString) {
                        var currentClassMap = makeTruthyCssClassMap(currentClassString);
                        return newClassString.split(ONE_SPACE).some(function (className) {
                            return currentClassMap[className];
                        });
                    }
                }
                function isAllowed(ruleType, currentAnimation, previousAnimation) {
                    return rules[ruleType].some(function (fn) {
                        return fn(currentAnimation, previousAnimation);
                    });
                }
                function hasAnimationClasses(animation, and) {
                    var a = (animation.addClass || "").length > 0;
                    var b = (animation.removeClass || "").length > 0;
                    return and ? a && b : a || b;
                }
                rules.join.push(function (newAnimation, currentAnimation) {
                    return !newAnimation.structural && hasAnimationClasses(newAnimation);
                });
                rules.skip.push(function (newAnimation, currentAnimation) {
                    return !newAnimation.structural && !hasAnimationClasses(newAnimation);
                });
                rules.skip.push(function (newAnimation, currentAnimation) {
                    return currentAnimation.event === "leave" && newAnimation.structural;
                });
                rules.skip.push(function (newAnimation, currentAnimation) {
                    return currentAnimation.structural && currentAnimation.state === RUNNING_STATE && !newAnimation.structural;
                });
                rules.cancel.push(function (newAnimation, currentAnimation) {
                    return currentAnimation.structural && newAnimation.structural;
                });
                rules.cancel.push(function (newAnimation, currentAnimation) {
                    return currentAnimation.state === RUNNING_STATE && newAnimation.structural;
                });
                rules.cancel.push(function (newAnimation, currentAnimation) {
                    if (currentAnimation.structural) return false;
                    var nA = newAnimation.addClass;
                    var nR = newAnimation.removeClass;
                    var cA = currentAnimation.addClass;
                    var cR = currentAnimation.removeClass;
                    if ((isUndefined(nA) && isUndefined(nR)) || (isUndefined(cA) && isUndefined(cR))) {
                        return false;
                    }
                    return hasMatchingClasses(nA, cR) || hasMatchingClasses(nR, cA);
                });
                this.$get = [
                    "$$rAF",
                    "$rootScope",
                    "$rootElement",
                    "$document",
                    "$$Map",
                    "$$animation",
                    "$$AnimateRunner",
                    "$templateRequest",
                    "$$jqLite",
                    "$$forceReflow",
                    "$$isDocumentHidden",
                    function ($$rAF, $rootScope, $rootElement, $document, $$Map, $$animation, $$AnimateRunner, $templateRequest, $$jqLite, $$forceReflow, $$isDocumentHidden) {
                        var activeAnimationsLookup = new $$Map();
                        var disabledElementsLookup = new $$Map();
                        var animationsEnabled = null;
                        function postDigestTaskFactory() {
                            var postDigestCalled = false;
                            return function (fn) {
                                if (postDigestCalled) {
                                    fn();
                                } else {
                                    $rootScope.$$postDigest(function () {
                                        postDigestCalled = true;
                                        fn();
                                    });
                                }
                            };
                        }
                        var deregisterWatch = $rootScope.$watch(
                            function () {
                                return $templateRequest.totalPendingRequests === 0;
                            },
                            function (isEmpty) {
                                if (!isEmpty) return;
                                deregisterWatch();
                                $rootScope.$$postDigest(function () {
                                    $rootScope.$$postDigest(function () {
                                        if (animationsEnabled === null) {
                                            animationsEnabled = true;
                                        }
                                    });
                                });
                            }
                        );
                        var callbackRegistry = Object.create(null);
                        var classNameFilter = $animateProvider.classNameFilter();
                        var isAnimatableClassName = !classNameFilter
                            ? function () {
                                return true;
                            }
                            : function (className) {
                                return classNameFilter.test(className);
                            };
                        var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);
                        function normalizeAnimationDetails(element, animation) {
                            return mergeAnimationDetails(element, animation, {});
                        }
                        var contains =
                            window.Node.prototype.contains ||
                            function (arg) {
                                return this === arg || !!(this.compareDocumentPosition(arg) & 16);
                            };
                        function findCallbacks(targetParentNode, targetNode, event) {
                            var matches = [];
                            var entries = callbackRegistry[event];
                            if (entries) {
                                forEach(entries, function (entry) {
                                    if (contains.call(entry.node, targetNode)) {
                                        matches.push(entry.callback);
                                    } else if (event === "leave" && contains.call(entry.node, targetParentNode)) {
                                        matches.push(entry.callback);
                                    }
                                });
                            }
                            return matches;
                        }
                        function filterFromRegistry(list, matchContainer, matchCallback) {
                            var containerNode = extractElementNode(matchContainer);
                            return list.filter(function (entry) {
                                var isMatch = entry.node === containerNode && (!matchCallback || entry.callback === matchCallback);
                                return !isMatch;
                            });
                        }
                        function cleanupEventListeners(phase, node) {
                            if (phase === "close" && !node.parentNode) {
                                $animate.off(node);
                            }
                        }
                        var $animate = {
                            on: function (event, container, callback) {
                                var node = extractElementNode(container);
                                callbackRegistry[event] = callbackRegistry[event] || [];
                                callbackRegistry[event].push({ node: node, callback: callback });
                                jqLite(container).on("$destroy", function () {
                                    var animationDetails = activeAnimationsLookup.get(node);
                                    if (!animationDetails) {
                                        $animate.off(event, container, callback);
                                    }
                                });
                            },
                            off: function (event, container, callback) {
                                if (arguments.length === 1 && !isString(arguments[0])) {
                                    container = arguments[0];
                                    for (var eventType in callbackRegistry) {
                                        callbackRegistry[eventType] = filterFromRegistry(callbackRegistry[eventType], container);
                                    }
                                    return;
                                }
                                var entries = callbackRegistry[event];
                                if (!entries) return;
                                callbackRegistry[event] = arguments.length === 1 ? null : filterFromRegistry(entries, container, callback);
                            },
                            pin: function (element, parentElement) {
                                assertArg(isElement(element), "element", "not an element");
                                assertArg(isElement(parentElement), "parentElement", "not an element");
                                element.data(NG_ANIMATE_PIN_DATA, parentElement);
                            },
                            push: function (element, event, options, domOperation) {
                                options = options || {};
                                options.domOperation = domOperation;
                                return queueAnimation(element, event, options);
                            },
                            enabled: function (element, bool) {
                                var argCount = arguments.length;
                                if (argCount === 0) {
                                    bool = !!animationsEnabled;
                                } else {
                                    var hasElement = isElement(element);
                                    if (!hasElement) {
                                        bool = animationsEnabled = !!element;
                                    } else {
                                        var node = getDomNode(element);
                                        if (argCount === 1) {
                                            bool = !disabledElementsLookup.get(node);
                                        } else {
                                            disabledElementsLookup.set(node, !bool);
                                        }
                                    }
                                }
                                return bool;
                            },
                        };
                        return $animate;
                        function queueAnimation(originalElement, event, initialOptions) {
                            var options = copy(initialOptions);
                            var element = stripCommentsFromElement(originalElement);
                            var node = getDomNode(element);
                            var parentNode = node && node.parentNode;
                            options = prepareAnimationOptions(options);
                            var runner = new $$AnimateRunner();
                            var runInNextPostDigestOrNow = postDigestTaskFactory();
                            if (isArray(options.addClass)) {
                                options.addClass = options.addClass.join(" ");
                            }
                            if (options.addClass && !isString(options.addClass)) {
                                options.addClass = null;
                            }
                            if (isArray(options.removeClass)) {
                                options.removeClass = options.removeClass.join(" ");
                            }
                            if (options.removeClass && !isString(options.removeClass)) {
                                options.removeClass = null;
                            }
                            if (options.from && !isObject(options.from)) {
                                options.from = null;
                            }
                            if (options.to && !isObject(options.to)) {
                                options.to = null;
                            }
                            if (!node) {
                                close();
                                return runner;
                            }
                            var className = [node.getAttribute("class"), options.addClass, options.removeClass].join(" ");
                            if (!isAnimatableClassName(className)) {
                                close();
                                return runner;
                            }
                            var isStructural = ["enter", "move", "leave"].indexOf(event) >= 0;
                            var documentHidden = $$isDocumentHidden();
                            var skipAnimations = !animationsEnabled || documentHidden || disabledElementsLookup.get(node);
                            var existingAnimation = (!skipAnimations && activeAnimationsLookup.get(node)) || {};
                            var hasExistingAnimation = !!existingAnimation.state;
                            if (!skipAnimations && (!hasExistingAnimation || existingAnimation.state !== PRE_DIGEST_STATE)) {
                                skipAnimations = !areAnimationsAllowed(node, parentNode, event);
                            }
                            if (skipAnimations) {
                                if (documentHidden) notifyProgress(runner, event, "start");
                                close();
                                if (documentHidden) notifyProgress(runner, event, "close");
                                return runner;
                            }
                            if (isStructural) {
                                closeChildAnimations(node);
                            }
                            var newAnimation = { structural: isStructural, element: element, event: event, addClass: options.addClass, removeClass: options.removeClass, close: close, options: options, runner: runner };
                            if (hasExistingAnimation) {
                                var skipAnimationFlag = isAllowed("skip", newAnimation, existingAnimation);
                                if (skipAnimationFlag) {
                                    if (existingAnimation.state === RUNNING_STATE) {
                                        close();
                                        return runner;
                                    } else {
                                        mergeAnimationDetails(element, existingAnimation, newAnimation);
                                        return existingAnimation.runner;
                                    }
                                }
                                var cancelAnimationFlag = isAllowed("cancel", newAnimation, existingAnimation);
                                if (cancelAnimationFlag) {
                                    if (existingAnimation.state === RUNNING_STATE) {
                                        existingAnimation.runner.end();
                                    } else if (existingAnimation.structural) {
                                        existingAnimation.close();
                                    } else {
                                        mergeAnimationDetails(element, existingAnimation, newAnimation);
                                        return existingAnimation.runner;
                                    }
                                } else {
                                    var joinAnimationFlag = isAllowed("join", newAnimation, existingAnimation);
                                    if (joinAnimationFlag) {
                                        if (existingAnimation.state === RUNNING_STATE) {
                                            normalizeAnimationDetails(element, newAnimation);
                                        } else {
                                            applyGeneratedPreparationClasses(element, isStructural ? event : null, options);
                                            event = newAnimation.event = existingAnimation.event;
                                            options = mergeAnimationDetails(element, existingAnimation, newAnimation);
                                            return existingAnimation.runner;
                                        }
                                    }
                                }
                            } else {
                                normalizeAnimationDetails(element, newAnimation);
                            }
                            var isValidAnimation = newAnimation.structural;
                            if (!isValidAnimation) {
                                isValidAnimation = (newAnimation.event === "animate" && Object.keys(newAnimation.options.to || {}).length > 0) || hasAnimationClasses(newAnimation);
                            }
                            if (!isValidAnimation) {
                                close();
                                clearElementAnimationState(node);
                                return runner;
                            }
                            var counter = (existingAnimation.counter || 0) + 1;
                            newAnimation.counter = counter;
                            markElementAnimationState(node, PRE_DIGEST_STATE, newAnimation);
                            $rootScope.$$postDigest(function () {
                                element = stripCommentsFromElement(originalElement);
                                var animationDetails = activeAnimationsLookup.get(node);
                                var animationCancelled = !animationDetails;
                                animationDetails = animationDetails || {};
                                var parentElement = element.parent() || [];
                                var isValidAnimation = parentElement.length > 0 && (animationDetails.event === "animate" || animationDetails.structural || hasAnimationClasses(animationDetails));
                                if (animationCancelled || animationDetails.counter !== counter || !isValidAnimation) {
                                    if (animationCancelled) {
                                        applyAnimationClasses(element, options);
                                        applyAnimationStyles(element, options);
                                    }
                                    if (animationCancelled || (isStructural && animationDetails.event !== event)) {
                                        options.domOperation();
                                        runner.end();
                                    }
                                    if (!isValidAnimation) {
                                        clearElementAnimationState(node);
                                    }
                                    return;
                                }
                                event = !animationDetails.structural && hasAnimationClasses(animationDetails, true) ? "setClass" : animationDetails.event;
                                markElementAnimationState(node, RUNNING_STATE);
                                var realRunner = $$animation(element, event, animationDetails.options);
                                runner.setHost(realRunner);
                                notifyProgress(runner, event, "start", {});
                                realRunner.done(function (status) {
                                    close(!status);
                                    var animationDetails = activeAnimationsLookup.get(node);
                                    if (animationDetails && animationDetails.counter === counter) {
                                        clearElementAnimationState(node);
                                    }
                                    notifyProgress(runner, event, "close", {});
                                });
                            });
                            return runner;
                            function notifyProgress(runner, event, phase, data) {
                                runInNextPostDigestOrNow(function () {
                                    var callbacks = findCallbacks(parentNode, node, event);
                                    if (callbacks.length) {
                                        $$rAF(function () {
                                            forEach(callbacks, function (callback) {
                                                callback(element, phase, data);
                                            });
                                            cleanupEventListeners(phase, node);
                                        });
                                    } else {
                                        cleanupEventListeners(phase, node);
                                    }
                                });
                                runner.progress(event, phase, data);
                            }
                            function close(reject) {
                                clearGeneratedClasses(element, options);
                                applyAnimationClasses(element, options);
                                applyAnimationStyles(element, options);
                                options.domOperation();
                                runner.complete(!reject);
                            }
                        }
                        function closeChildAnimations(node) {
                            var children = node.querySelectorAll("[" + NG_ANIMATE_ATTR_NAME + "]");
                            forEach(children, function (child) {
                                var state = parseInt(child.getAttribute(NG_ANIMATE_ATTR_NAME), 10);
                                var animationDetails = activeAnimationsLookup.get(child);
                                if (animationDetails) {
                                    switch (state) {
                                        case RUNNING_STATE:
                                            animationDetails.runner.end();
                                        case PRE_DIGEST_STATE:
                                            activeAnimationsLookup.delete(child);
                                            break;
                                    }
                                }
                            });
                        }
                        function clearElementAnimationState(node) {
                            node.removeAttribute(NG_ANIMATE_ATTR_NAME);
                            activeAnimationsLookup.delete(node);
                        }
                        function areAnimationsAllowed(node, parentNode, event) {
                            var bodyNode = $document[0].body;
                            var rootNode = getDomNode($rootElement);
                            var bodyNodeDetected = node === bodyNode || node.nodeName === "HTML";
                            var rootNodeDetected = node === rootNode;
                            var parentAnimationDetected = false;
                            var elementDisabled = disabledElementsLookup.get(node);
                            var animateChildren;
                            var parentHost = jqLite.data(node, NG_ANIMATE_PIN_DATA);
                            if (parentHost) {
                                parentNode = getDomNode(parentHost);
                            }
                            while (parentNode) {
                                if (!rootNodeDetected) {
                                    rootNodeDetected = parentNode === rootNode;
                                }
                                if (parentNode.nodeType !== ELEMENT_NODE) {
                                    break;
                                }
                                var details = activeAnimationsLookup.get(parentNode) || {};
                                if (!parentAnimationDetected) {
                                    var parentNodeDisabled = disabledElementsLookup.get(parentNode);
                                    if (parentNodeDisabled === true && elementDisabled !== false) {
                                        elementDisabled = true;
                                        break;
                                    } else if (parentNodeDisabled === false) {
                                        elementDisabled = false;
                                    }
                                    parentAnimationDetected = details.structural;
                                }
                                if (isUndefined(animateChildren) || animateChildren === true) {
                                    var value = jqLite.data(parentNode, NG_ANIMATE_CHILDREN_DATA);
                                    if (isDefined(value)) {
                                        animateChildren = value;
                                    }
                                }
                                if (parentAnimationDetected && animateChildren === false) break;
                                if (!bodyNodeDetected) {
                                    bodyNodeDetected = parentNode === bodyNode;
                                }
                                if (bodyNodeDetected && rootNodeDetected) {
                                    break;
                                }
                                if (!rootNodeDetected) {
                                    parentHost = jqLite.data(parentNode, NG_ANIMATE_PIN_DATA);
                                    if (parentHost) {
                                        parentNode = getDomNode(parentHost);
                                        continue;
                                    }
                                }
                                parentNode = parentNode.parentNode;
                            }
                            var allowAnimation = (!parentAnimationDetected || animateChildren) && elementDisabled !== true;
                            return allowAnimation && rootNodeDetected && bodyNodeDetected;
                        }
                        function markElementAnimationState(node, state, details) {
                            details = details || {};
                            details.state = state;
                            node.setAttribute(NG_ANIMATE_ATTR_NAME, state);
                            var oldValue = activeAnimationsLookup.get(node);
                            var newValue = oldValue ? extend(oldValue, details) : details;
                            activeAnimationsLookup.set(node, newValue);
                        }
                    },
                ];
            },
        ];
        var $$AnimationProvider = [
            "$animateProvider",
            function ($animateProvider) {
                var NG_ANIMATE_REF_ATTR = "ng-animate-ref";
                var drivers = (this.drivers = []);
                var RUNNER_STORAGE_KEY = "$$animationRunner";
                function setRunner(element, runner) {
                    element.data(RUNNER_STORAGE_KEY, runner);
                }
                function removeRunner(element) {
                    element.removeData(RUNNER_STORAGE_KEY);
                }
                function getRunner(element) {
                    return element.data(RUNNER_STORAGE_KEY);
                }
                this.$get = [
                    "$$jqLite",
                    "$rootScope",
                    "$injector",
                    "$$AnimateRunner",
                    "$$Map",
                    "$$rAFScheduler",
                    function ($$jqLite, $rootScope, $injector, $$AnimateRunner, $$Map, $$rAFScheduler) {
                        var animationQueue = [];
                        var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);
                        function sortAnimations(animations) {
                            var tree = { children: [] };
                            var i,
                                lookup = new $$Map();
                            for (i = 0; i < animations.length; i++) {
                                var animation = animations[i];
                                lookup.set(animation.domNode, (animations[i] = { domNode: animation.domNode, fn: animation.fn, children: [] }));
                            }
                            for (i = 0; i < animations.length; i++) {
                                processNode(animations[i]);
                            }
                            return flatten(tree);
                            function processNode(entry) {
                                if (entry.processed) return entry;
                                entry.processed = true;
                                var elementNode = entry.domNode;
                                var parentNode = elementNode.parentNode;
                                lookup.set(elementNode, entry);
                                var parentEntry;
                                while (parentNode) {
                                    parentEntry = lookup.get(parentNode);
                                    if (parentEntry) {
                                        if (!parentEntry.processed) {
                                            parentEntry = processNode(parentEntry);
                                        }
                                        break;
                                    }
                                    parentNode = parentNode.parentNode;
                                }
                                (parentEntry || tree).children.push(entry);
                                return entry;
                            }
                            function flatten(tree) {
                                var result = [];
                                var queue = [];
                                var i;
                                for (i = 0; i < tree.children.length; i++) {
                                    queue.push(tree.children[i]);
                                }
                                var remainingLevelEntries = queue.length;
                                var nextLevelEntries = 0;
                                var row = [];
                                for (i = 0; i < queue.length; i++) {
                                    var entry = queue[i];
                                    if (remainingLevelEntries <= 0) {
                                        remainingLevelEntries = nextLevelEntries;
                                        nextLevelEntries = 0;
                                        result.push(row);
                                        row = [];
                                    }
                                    row.push(entry.fn);
                                    entry.children.forEach(function (childEntry) {
                                        nextLevelEntries++;
                                        queue.push(childEntry);
                                    });
                                    remainingLevelEntries--;
                                }
                                if (row.length) {
                                    result.push(row);
                                }
                                return result;
                            }
                        }
                        return function (element, event, options) {
                            options = prepareAnimationOptions(options);
                            var isStructural = ["enter", "move", "leave"].indexOf(event) >= 0;
                            var runner = new $$AnimateRunner({
                                end: function () {
                                    close();
                                },
                                cancel: function () {
                                    close(true);
                                },
                            });
                            if (!drivers.length) {
                                close();
                                return runner;
                            }
                            setRunner(element, runner);
                            var classes = mergeClasses(element.attr("class"), mergeClasses(options.addClass, options.removeClass));
                            var tempClasses = options.tempClasses;
                            if (tempClasses) {
                                classes += " " + tempClasses;
                                options.tempClasses = null;
                            }
                            var prepareClassName;
                            if (isStructural) {
                                prepareClassName = "ng-" + event + PREPARE_CLASS_SUFFIX;
                                $$jqLite.addClass(element, prepareClassName);
                            }
                            animationQueue.push({ element: element, classes: classes, event: event, structural: isStructural, options: options, beforeStart: beforeStart, close: close });
                            element.on("$destroy", handleDestroyedElement);
                            if (animationQueue.length > 1) return runner;
                            $rootScope.$$postDigest(function () {
                                var animations = [];
                                forEach(animationQueue, function (entry) {
                                    if (getRunner(entry.element)) {
                                        animations.push(entry);
                                    } else {
                                        entry.close();
                                    }
                                });
                                animationQueue.length = 0;
                                var groupedAnimations = groupAnimations(animations);
                                var toBeSortedAnimations = [];
                                forEach(groupedAnimations, function (animationEntry) {
                                    toBeSortedAnimations.push({
                                        domNode: getDomNode(animationEntry.from ? animationEntry.from.element : animationEntry.element),
                                        fn: function triggerAnimationStart() {
                                            animationEntry.beforeStart();
                                            var startAnimationFn,
                                                closeFn = animationEntry.close;
                                            var targetElement = animationEntry.anchors ? animationEntry.from.element || animationEntry.to.element : animationEntry.element;
                                            if (getRunner(targetElement)) {
                                                var operation = invokeFirstDriver(animationEntry);
                                                if (operation) {
                                                    startAnimationFn = operation.start;
                                                }
                                            }
                                            if (!startAnimationFn) {
                                                closeFn();
                                            } else {
                                                var animationRunner = startAnimationFn();
                                                animationRunner.done(function (status) {
                                                    closeFn(!status);
                                                });
                                                updateAnimationRunners(animationEntry, animationRunner);
                                            }
                                        },
                                    });
                                });
                                $$rAFScheduler(sortAnimations(toBeSortedAnimations));
                            });
                            return runner;
                            function getAnchorNodes(node) {
                                var SELECTOR = "[" + NG_ANIMATE_REF_ATTR + "]";
                                var items = node.hasAttribute(NG_ANIMATE_REF_ATTR) ? [node] : node.querySelectorAll(SELECTOR);
                                var anchors = [];
                                forEach(items, function (node) {
                                    var attr = node.getAttribute(NG_ANIMATE_REF_ATTR);
                                    if (attr && attr.length) {
                                        anchors.push(node);
                                    }
                                });
                                return anchors;
                            }
                            function groupAnimations(animations) {
                                var preparedAnimations = [];
                                var refLookup = {};
                                forEach(animations, function (animation, index) {
                                    var element = animation.element;
                                    var node = getDomNode(element);
                                    var event = animation.event;
                                    var enterOrMove = ["enter", "move"].indexOf(event) >= 0;
                                    var anchorNodes = animation.structural ? getAnchorNodes(node) : [];
                                    if (anchorNodes.length) {
                                        var direction = enterOrMove ? "to" : "from";
                                        forEach(anchorNodes, function (anchor) {
                                            var key = anchor.getAttribute(NG_ANIMATE_REF_ATTR);
                                            refLookup[key] = refLookup[key] || {};
                                            refLookup[key][direction] = { animationID: index, element: jqLite(anchor) };
                                        });
                                    } else {
                                        preparedAnimations.push(animation);
                                    }
                                });
                                var usedIndicesLookup = {};
                                var anchorGroups = {};
                                forEach(refLookup, function (operations, key) {
                                    var from = operations.from;
                                    var to = operations.to;
                                    if (!from || !to) {
                                        var index = from ? from.animationID : to.animationID;
                                        var indexKey = index.toString();
                                        if (!usedIndicesLookup[indexKey]) {
                                            usedIndicesLookup[indexKey] = true;
                                            preparedAnimations.push(animations[index]);
                                        }
                                        return;
                                    }
                                    var fromAnimation = animations[from.animationID];
                                    var toAnimation = animations[to.animationID];
                                    var lookupKey = from.animationID.toString();
                                    if (!anchorGroups[lookupKey]) {
                                        var group = (anchorGroups[lookupKey] = {
                                            structural: true,
                                            beforeStart: function () {
                                                fromAnimation.beforeStart();
                                                toAnimation.beforeStart();
                                            },
                                            close: function () {
                                                fromAnimation.close();
                                                toAnimation.close();
                                            },
                                            classes: cssClassesIntersection(fromAnimation.classes, toAnimation.classes),
                                            from: fromAnimation,
                                            to: toAnimation,
                                            anchors: [],
                                        });
                                        if (group.classes.length) {
                                            preparedAnimations.push(group);
                                        } else {
                                            preparedAnimations.push(fromAnimation);
                                            preparedAnimations.push(toAnimation);
                                        }
                                    }
                                    anchorGroups[lookupKey].anchors.push({ out: from.element, in: to.element });
                                });
                                return preparedAnimations;
                            }
                            function cssClassesIntersection(a, b) {
                                a = a.split(" ");
                                b = b.split(" ");
                                var matches = [];
                                for (var i = 0; i < a.length; i++) {
                                    var aa = a[i];
                                    if (aa.substring(0, 3) === "ng-") continue;
                                    for (var j = 0; j < b.length; j++) {
                                        if (aa === b[j]) {
                                            matches.push(aa);
                                            break;
                                        }
                                    }
                                }
                                return matches.join(" ");
                            }
                            function invokeFirstDriver(animationDetails) {
                                for (var i = drivers.length - 1; i >= 0; i--) {
                                    var driverName = drivers[i];
                                    var factory = $injector.get(driverName);
                                    var driver = factory(animationDetails);
                                    if (driver) {
                                        return driver;
                                    }
                                }
                            }
                            function beforeStart() {
                                element.addClass(NG_ANIMATE_CLASSNAME);
                                if (tempClasses) {
                                    $$jqLite.addClass(element, tempClasses);
                                }
                                if (prepareClassName) {
                                    $$jqLite.removeClass(element, prepareClassName);
                                    prepareClassName = null;
                                }
                            }
                            function updateAnimationRunners(animation, newRunner) {
                                if (animation.from && animation.to) {
                                    update(animation.from.element);
                                    update(animation.to.element);
                                } else {
                                    update(animation.element);
                                }
                                function update(element) {
                                    var runner = getRunner(element);
                                    if (runner) runner.setHost(newRunner);
                                }
                            }
                            function handleDestroyedElement() {
                                var runner = getRunner(element);
                                if (runner && (event !== "leave" || !options.$$domOperationFired)) {
                                    runner.end();
                                }
                            }
                            function close(rejected) {
                                element.off("$destroy", handleDestroyedElement);
                                removeRunner(element);
                                applyAnimationClasses(element, options);
                                applyAnimationStyles(element, options);
                                options.domOperation();
                                if (tempClasses) {
                                    $$jqLite.removeClass(element, tempClasses);
                                }
                                element.removeClass(NG_ANIMATE_CLASSNAME);
                                runner.complete(!rejected);
                            }
                        };
                    },
                ];
            },
        ];
        var ngAnimateSwapDirective = [
            "$animate",
            "$rootScope",
            function ($animate, $rootScope) {
                return {
                    restrict: "A",
                    transclude: "element",
                    terminal: true,
                    priority: 600,
                    link: function (scope, $element, attrs, ctrl, $transclude) {
                        var previousElement, previousScope;
                        scope.$watchCollection(attrs.ngAnimateSwap || attrs["for"], function (value) {
                            if (previousElement) {
                                $animate.leave(previousElement);
                            }
                            if (previousScope) {
                                previousScope.$destroy();
                                previousScope = null;
                            }
                            if (value || value === 0) {
                                previousScope = scope.$new();
                                $transclude(previousScope, function (element) {
                                    previousElement = element;
                                    $animate.enter(element, null, $element);
                                });
                            }
                        });
                    },
                };
            },
        ];
        var copy;
        var extend;
        var forEach;
        var isArray;
        var isDefined;
        var isElement;
        var isFunction;
        var isObject;
        var isString;
        var isUndefined;
        var jqLite;
        var noop;
        angular
            .module("ngAnimate", [], function initAngularHelpers() {
                noop = angular.noop;
                copy = angular.copy;
                extend = angular.extend;
                jqLite = angular.element;
                forEach = angular.forEach;
                isArray = angular.isArray;
                isString = angular.isString;
                isObject = angular.isObject;
                isUndefined = angular.isUndefined;
                isDefined = angular.isDefined;
                isFunction = angular.isFunction;
                isElement = angular.isElement;
            })
            .info({ angularVersion: "1.6.4" })
            .directive("ngAnimateSwap", ngAnimateSwapDirective)
            .directive("ngAnimateChildren", $$AnimateChildrenDirective)
            .factory("$$rAFScheduler", $$rAFSchedulerFactory)
            .provider("$$animateQueue", $$AnimateQueueProvider)
            .provider("$$animation", $$AnimationProvider)
            .provider("$animateCss", $AnimateCssProvider)
            .provider("$$animateCssDriver", $$AnimateCssDriverProvider)
            .provider("$$animateJs", $$AnimateJsProvider)
            .provider("$$animateJsDriver", $$AnimateJsDriverProvider);
    })(window, window.angular);
    var TweenMax_min = createCommonjsModule(function (module) {
        var _gsScope = "undefined" != "object" && module.exports && "undefined" != typeof commonjsGlobal ? commonjsGlobal : commonjsGlobal || window;
        (_gsScope._gsQueue || (_gsScope._gsQueue = [])).push(function () {
            "use strict";
            _gsScope._gsDefine(
                "TweenMax",
                ["core.Animation", "core.SimpleTimeline", "TweenLite"],
                function (a, b, c) {
                    var d = function (a) {
                        var b,
                            c = [],
                            d = a.length;
                        for (b = 0; b !== d; c.push(a[b++]));
                        return c;
                    },
                        e = function (a, b, c) {
                            var d,
                                e,
                                f = a.cycle;
                            for (d in f) (e = f[d]), (a[d] = "function" == typeof e ? e(c, b[c]) : e[c % e.length]);
                            delete a.cycle;
                        },
                        f = function (a, b, d) {
                            c.call(this, a, b, d),
                                (this._cycle = 0),
                                (this._yoyo = this.vars.yoyo === !0),
                                (this._repeat = this.vars.repeat || 0),
                                (this._repeatDelay = this.vars.repeatDelay || 0),
                                (this._dirty = !0),
                                (this.render = f.prototype.render);
                        },
                        g = 1e-10,
                        h = c._internals,
                        i = h.isSelector,
                        j = h.isArray,
                        k = (f.prototype = c.to({}, 0.1, {})),
                        l = [];
                    (f.version = "1.19.1"),
                        (k.constructor = f),
                        (k.kill()._gc = !1),
                        (f.killTweensOf = f.killDelayedCallsTo = c.killTweensOf),
                        (f.getTweensOf = c.getTweensOf),
                        (f.lagSmoothing = c.lagSmoothing),
                        (f.ticker = c.ticker),
                        (f.render = c.render),
                        (k.invalidate = function () {
                            return (this._yoyo = this.vars.yoyo === !0), (this._repeat = this.vars.repeat || 0), (this._repeatDelay = this.vars.repeatDelay || 0), this._uncache(!0), c.prototype.invalidate.call(this);
                        }),
                        (k.updateTo = function (a, b) {
                            var d,
                                e = this.ratio,
                                f = this.vars.immediateRender || a.immediateRender;
                            b && this._startTime < this._timeline._time && ((this._startTime = this._timeline._time), this._uncache(!1), this._gc ? this._enabled(!0, !1) : this._timeline.insert(this, this._startTime - this._delay));
                            for (d in a) this.vars[d] = a[d];
                            if (this._initted || f)
                                if (b) (this._initted = !1), f && this.render(0, !0, !0);
                                else if ((this._gc && this._enabled(!0, !1), this._notifyPluginsOfEnabled && this._firstPT && c._onPluginEvent("_onDisable", this), this._time / this._duration > 0.998)) {
                                    var g = this._totalTime;
                                    this.render(0, !0, !1), (this._initted = !1), this.render(g, !0, !1);
                                } else if (((this._initted = !1), this._init(), this._time > 0 || f)) for (var h, i = 1 / (1 - e), j = this._firstPT; j;) (h = j.s + j.c), (j.c *= i), (j.s = h - j.c), (j = j._next);
                            return this;
                        }),
                        (k.render = function (a, b, c) {
                            this._initted || (0 === this._duration && this.vars.repeat && this.invalidate());
                            var d,
                                e,
                                f,
                                i,
                                j,
                                k,
                                l,
                                m,
                                n = this._dirty ? this.totalDuration() : this._totalDuration,
                                o = this._time,
                                p = this._totalTime,
                                q = this._cycle,
                                r = this._duration,
                                s = this._rawPrevTime;
                            if (
                                (a >= n - 1e-7 && a >= 0
                                    ? ((this._totalTime = n),
                                        (this._cycle = this._repeat),
                                        this._yoyo && 0 !== (1 & this._cycle)
                                            ? ((this._time = 0), (this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0))
                                            : ((this._time = r), (this.ratio = this._ease._calcEnd ? this._ease.getRatio(1) : 1)),
                                        this._reversed || ((d = !0), (e = "onComplete"), (c = c || this._timeline.autoRemoveChildren)),
                                        0 === r &&
                                        (this._initted || !this.vars.lazy || c) &&
                                        (this._startTime === this._timeline._duration && (a = 0),
                                            (0 > s || (0 >= a && a >= -1e-7) || (s === g && "isPause" !== this.data)) && s !== a && ((c = !0), s > g && (e = "onReverseComplete")),
                                            (this._rawPrevTime = m = !b || a || s === a ? a : g)))
                                    : 1e-7 > a
                                        ? ((this._totalTime = this._time = this._cycle = 0),
                                            (this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0),
                                            (0 !== p || (0 === r && s > 0)) && ((e = "onReverseComplete"), (d = this._reversed)),
                                            0 > a && ((this._active = !1), 0 === r && (this._initted || !this.vars.lazy || c) && (s >= 0 && (c = !0), (this._rawPrevTime = m = !b || a || s === a ? a : g))),
                                            this._initted || (c = !0))
                                        : ((this._totalTime = this._time = a),
                                            0 !== this._repeat &&
                                            ((i = r + this._repeatDelay),
                                                (this._cycle = (this._totalTime / i) >> 0),
                                                0 !== this._cycle && this._cycle === this._totalTime / i && a >= p && this._cycle--,
                                                (this._time = this._totalTime - this._cycle * i),
                                                this._yoyo && 0 !== (1 & this._cycle) && (this._time = r - this._time),
                                                this._time > r ? (this._time = r) : this._time < 0 && (this._time = 0)),
                                            this._easeType
                                                ? ((j = this._time / r),
                                                    (k = this._easeType),
                                                    (l = this._easePower),
                                                    (1 === k || (3 === k && j >= 0.5)) && (j = 1 - j),
                                                    3 === k && (j *= 2),
                                                    1 === l ? (j *= j) : 2 === l ? (j *= j * j) : 3 === l ? (j *= j * j * j) : 4 === l && (j *= j * j * j * j),
                                                    1 === k ? (this.ratio = 1 - j) : 2 === k ? (this.ratio = j) : this._time / r < 0.5 ? (this.ratio = j / 2) : (this.ratio = 1 - j / 2))
                                                : (this.ratio = this._ease.getRatio(this._time / r))),
                                    o === this._time && !c && q === this._cycle)
                            )
                                return void (p !== this._totalTime && this._onUpdate && (b || this._callback("onUpdate")));
                            if (!this._initted) {
                                if ((this._init(), !this._initted || this._gc)) return;
                                if (!c && this._firstPT && ((this.vars.lazy !== !1 && this._duration) || (this.vars.lazy && !this._duration)))
                                    return (this._time = o), (this._totalTime = p), (this._rawPrevTime = s), (this._cycle = q), h.lazyTweens.push(this), void (this._lazy = [a, b]);
                                this._time && !d ? (this.ratio = this._ease.getRatio(this._time / r)) : d && this._ease._calcEnd && (this.ratio = this._ease.getRatio(0 === this._time ? 0 : 1));
                            }
                            for (
                                this._lazy !== !1 && (this._lazy = !1),
                                this._active || (!this._paused && this._time !== o && a >= 0 && (this._active = !0)),
                                0 === p &&
                                (2 === this._initted && a > 0 && this._init(),
                                    this._startAt && (a >= 0 ? this._startAt.render(a, b, c) : e || (e = "_dummyGS")),
                                    this.vars.onStart && (0 !== this._totalTime || 0 === r) && (b || this._callback("onStart"))),
                                f = this._firstPT;
                                f;

                            )
                                f.f ? f.t[f.p](f.c * this.ratio + f.s) : (f.t[f.p] = f.c * this.ratio + f.s), (f = f._next);
                            this._onUpdate && (0 > a && this._startAt && this._startTime && this._startAt.render(a, b, c), b || ((this._totalTime !== p || e) && this._callback("onUpdate"))),
                                this._cycle !== q && (b || this._gc || (this.vars.onRepeat && this._callback("onRepeat"))),
                                e &&
                                (!this._gc || c) &&
                                (0 > a && this._startAt && !this._onUpdate && this._startTime && this._startAt.render(a, b, c),
                                    d && (this._timeline.autoRemoveChildren && this._enabled(!1, !1), (this._active = !1)),
                                    !b && this.vars[e] && this._callback(e),
                                    0 === r && this._rawPrevTime === g && m !== g && (this._rawPrevTime = 0));
                        }),
                        (f.to = function (a, b, c) {
                            return new f(a, b, c);
                        }),
                        (f.from = function (a, b, c) {
                            return (c.runBackwards = !0), (c.immediateRender = 0 != c.immediateRender), new f(a, b, c);
                        }),
                        (f.fromTo = function (a, b, c, d) {
                            return (d.startAt = c), (d.immediateRender = 0 != d.immediateRender && 0 != c.immediateRender), new f(a, b, d);
                        }),
                        (f.staggerTo = f.allTo = function (a, b, g, h, k, m, n) {
                            h = h || 0;
                            var o,
                                p,
                                q,
                                r,
                                s = 0,
                                t = [],
                                u = function () {
                                    g.onComplete && g.onComplete.apply(g.onCompleteScope || this, arguments), k.apply(n || g.callbackScope || this, m || l);
                                },
                                v = g.cycle,
                                w = g.startAt && g.startAt.cycle;
                            for (j(a) || ("string" == typeof a && (a = c.selector(a) || a), i(a) && (a = d(a))), a = a || [], 0 > h && ((a = d(a)), a.reverse(), (h *= -1)), o = a.length - 1, q = 0; o >= q; q++) {
                                p = {};
                                for (r in g) p[r] = g[r];
                                if ((v && (e(p, a, q), null != p.duration && ((b = p.duration), delete p.duration)), w)) {
                                    w = p.startAt = {};
                                    for (r in g.startAt) w[r] = g.startAt[r];
                                    e(p.startAt, a, q);
                                }
                                (p.delay = s + (p.delay || 0)), q === o && k && (p.onComplete = u), (t[q] = new f(a[q], b, p)), (s += h);
                            }
                            return t;
                        }),
                        (f.staggerFrom = f.allFrom = function (a, b, c, d, e, g, h) {
                            return (c.runBackwards = !0), (c.immediateRender = 0 != c.immediateRender), f.staggerTo(a, b, c, d, e, g, h);
                        }),
                        (f.staggerFromTo = f.allFromTo = function (a, b, c, d, e, g, h, i) {
                            return (d.startAt = c), (d.immediateRender = 0 != d.immediateRender && 0 != c.immediateRender), f.staggerTo(a, b, d, e, g, h, i);
                        }),
                        (f.delayedCall = function (a, b, c, d, e) {
                            return new f(b, 0, { delay: a, onComplete: b, onCompleteParams: c, callbackScope: d, onReverseComplete: b, onReverseCompleteParams: c, immediateRender: !1, useFrames: e, overwrite: 0 });
                        }),
                        (f.set = function (a, b) {
                            return new f(a, 0, b);
                        }),
                        (f.isTweening = function (a) {
                            return c.getTweensOf(a, !0).length > 0;
                        });
                    var m = function (a, b) {
                        for (var d = [], e = 0, f = a._first; f;) f instanceof c ? (d[e++] = f) : (b && (d[e++] = f), (d = d.concat(m(f, b))), (e = d.length)), (f = f._next);
                        return d;
                    },
                        n = (f.getAllTweens = function (b) {
                            return m(a._rootTimeline, b).concat(m(a._rootFramesTimeline, b));
                        });
                    (f.killAll = function (a, c, d, e) {
                        null == c && (c = !0), null == d && (d = !0);
                        var f,
                            g,
                            h,
                            i = n(0 != e),
                            j = i.length,
                            k = c && d && e;
                        for (h = 0; j > h; h++) (g = i[h]), (k || g instanceof b || ((f = g.target === g.vars.onComplete) && d) || (c && !f)) && (a ? g.totalTime(g._reversed ? 0 : g.totalDuration()) : g._enabled(!1, !1));
                    }),
                        (f.killChildTweensOf = function (a, b) {
                            if (null != a) {
                                var e,
                                    g,
                                    k,
                                    l,
                                    m,
                                    n = h.tweenLookup;
                                if (("string" == typeof a && (a = c.selector(a) || a), i(a) && (a = d(a)), j(a))) for (l = a.length; --l > -1;) f.killChildTweensOf(a[l], b);
                                else {
                                    e = [];
                                    for (k in n) for (g = n[k].target.parentNode; g;) g === a && (e = e.concat(n[k].tweens)), (g = g.parentNode);
                                    for (m = e.length, l = 0; m > l; l++) b && e[l].totalTime(e[l].totalDuration()), e[l]._enabled(!1, !1);
                                }
                            }
                        });
                    var o = function (a, c, d, e) {
                        (c = c !== !1), (d = d !== !1), (e = e !== !1);
                        for (var f, g, h = n(e), i = c && d && e, j = h.length; --j > -1;) (g = h[j]), (i || g instanceof b || ((f = g.target === g.vars.onComplete) && d) || (c && !f)) && g.paused(a);
                    };
                    return (
                        (f.pauseAll = function (a, b, c) {
                            o(!0, a, b, c);
                        }),
                        (f.resumeAll = function (a, b, c) {
                            o(!1, a, b, c);
                        }),
                        (f.globalTimeScale = function (b) {
                            var d = a._rootTimeline,
                                e = c.ticker.time;
                            return arguments.length
                                ? ((b = b || g),
                                    (d._startTime = e - ((e - d._startTime) * d._timeScale) / b),
                                    (d = a._rootFramesTimeline),
                                    (e = c.ticker.frame),
                                    (d._startTime = e - ((e - d._startTime) * d._timeScale) / b),
                                    (d._timeScale = a._rootTimeline._timeScale = b),
                                    b)
                                : d._timeScale;
                        }),
                        (k.progress = function (a, b) {
                            return arguments.length ? this.totalTime(this.duration() * (this._yoyo && 0 !== (1 & this._cycle) ? 1 - a : a) + this._cycle * (this._duration + this._repeatDelay), b) : this._time / this.duration();
                        }),
                        (k.totalProgress = function (a, b) {
                            return arguments.length ? this.totalTime(this.totalDuration() * a, b) : this._totalTime / this.totalDuration();
                        }),
                        (k.time = function (a, b) {
                            return arguments.length
                                ? (this._dirty && this.totalDuration(),
                                    a > this._duration && (a = this._duration),
                                    this._yoyo && 0 !== (1 & this._cycle) ? (a = this._duration - a + this._cycle * (this._duration + this._repeatDelay)) : 0 !== this._repeat && (a += this._cycle * (this._duration + this._repeatDelay)),
                                    this.totalTime(a, b))
                                : this._time;
                        }),
                        (k.duration = function (b) {
                            return arguments.length ? a.prototype.duration.call(this, b) : this._duration;
                        }),
                        (k.totalDuration = function (a) {
                            return arguments.length
                                ? -1 === this._repeat
                                    ? this
                                    : this.duration((a - this._repeat * this._repeatDelay) / (this._repeat + 1))
                                : (this._dirty && ((this._totalDuration = -1 === this._repeat ? 999999999999 : this._duration * (this._repeat + 1) + this._repeatDelay * this._repeat), (this._dirty = !1)), this._totalDuration);
                        }),
                        (k.repeat = function (a) {
                            return arguments.length ? ((this._repeat = a), this._uncache(!0)) : this._repeat;
                        }),
                        (k.repeatDelay = function (a) {
                            return arguments.length ? ((this._repeatDelay = a), this._uncache(!0)) : this._repeatDelay;
                        }),
                        (k.yoyo = function (a) {
                            return arguments.length ? ((this._yoyo = a), this) : this._yoyo;
                        }),
                        f
                    );
                },
                !0
            ),
                _gsScope._gsDefine(
                    "TimelineLite",
                    ["core.Animation", "core.SimpleTimeline", "TweenLite"],
                    function (a, b, c) {
                        var d = function (a) {
                            b.call(this, a),
                                (this._labels = {}),
                                (this.autoRemoveChildren = this.vars.autoRemoveChildren === !0),
                                (this.smoothChildTiming = this.vars.smoothChildTiming === !0),
                                (this._sortChildren = !0),
                                (this._onUpdate = this.vars.onUpdate);
                            var c,
                                d,
                                e = this.vars;
                            for (d in e) (c = e[d]), i(c) && -1 !== c.join("").indexOf("{self}") && (e[d] = this._swapSelfInParams(c));
                            i(e.tweens) && this.add(e.tweens, 0, e.align, e.stagger);
                        },
                            e = 1e-10,
                            f = c._internals,
                            g = (d._internals = {}),
                            h = f.isSelector,
                            i = f.isArray,
                            j = f.lazyTweens,
                            k = f.lazyRender,
                            l = _gsScope._gsDefine.globals,
                            m = function (a) {
                                var b,
                                    c = {};
                                for (b in a) c[b] = a[b];
                                return c;
                            },
                            n = function (a, b, c) {
                                var d,
                                    e,
                                    f = a.cycle;
                                for (d in f) (e = f[d]), (a[d] = "function" == typeof e ? e(c, b[c]) : e[c % e.length]);
                                delete a.cycle;
                            },
                            o = (g.pauseCallback = function () { }),
                            p = function (a) {
                                var b,
                                    c = [],
                                    d = a.length;
                                for (b = 0; b !== d; c.push(a[b++]));
                                return c;
                            },
                            q = (d.prototype = new b());
                        return (
                            (d.version = "1.19.1"),
                            (q.constructor = d),
                            (q.kill()._gc = q._forcingPlayhead = q._hasPause = !1),
                            (q.to = function (a, b, d, e) {
                                var f = (d.repeat && l.TweenMax) || c;
                                return b ? this.add(new f(a, b, d), e) : this.set(a, d, e);
                            }),
                            (q.from = function (a, b, d, e) {
                                return this.add(((d.repeat && l.TweenMax) || c).from(a, b, d), e);
                            }),
                            (q.fromTo = function (a, b, d, e, f) {
                                var g = (e.repeat && l.TweenMax) || c;
                                return b ? this.add(g.fromTo(a, b, d, e), f) : this.set(a, e, f);
                            }),
                            (q.staggerTo = function (a, b, e, f, g, i, j, k) {
                                var l,
                                    o,
                                    q = new d({ onComplete: i, onCompleteParams: j, callbackScope: k, smoothChildTiming: this.smoothChildTiming }),
                                    r = e.cycle;
                                for ("string" == typeof a && (a = c.selector(a) || a), a = a || [], h(a) && (a = p(a)), f = f || 0, 0 > f && ((a = p(a)), a.reverse(), (f *= -1)), o = 0; o < a.length; o++)
                                    (l = m(e)), l.startAt && ((l.startAt = m(l.startAt)), l.startAt.cycle && n(l.startAt, a, o)), r && (n(l, a, o), null != l.duration && ((b = l.duration), delete l.duration)), q.to(a[o], b, l, o * f);
                                return this.add(q, g);
                            }),
                            (q.staggerFrom = function (a, b, c, d, e, f, g, h) {
                                return (c.immediateRender = 0 != c.immediateRender), (c.runBackwards = !0), this.staggerTo(a, b, c, d, e, f, g, h);
                            }),
                            (q.staggerFromTo = function (a, b, c, d, e, f, g, h, i) {
                                return (d.startAt = c), (d.immediateRender = 0 != d.immediateRender && 0 != c.immediateRender), this.staggerTo(a, b, d, e, f, g, h, i);
                            }),
                            (q.call = function (a, b, d, e) {
                                return this.add(c.delayedCall(0, a, b, d), e);
                            }),
                            (q.set = function (a, b, d) {
                                return (d = this._parseTimeOrLabel(d, 0, !0)), null == b.immediateRender && (b.immediateRender = d === this._time && !this._paused), this.add(new c(a, 0, b), d);
                            }),
                            (d.exportRoot = function (a, b) {
                                (a = a || {}), null == a.smoothChildTiming && (a.smoothChildTiming = !0);
                                var e,
                                    f,
                                    g = new d(a),
                                    h = g._timeline;
                                for (null == b && (b = !0), h._remove(g, !0), g._startTime = 0, g._rawPrevTime = g._time = g._totalTime = h._time, e = h._first; e;)
                                    (f = e._next), (b && e instanceof c && e.target === e.vars.onComplete) || g.add(e, e._startTime - e._delay), (e = f);
                                return h.add(g, 0), g;
                            }),
                            (q.add = function (e, f, g, h) {
                                var j, k, l, m, n, o;
                                if (("number" != typeof f && (f = this._parseTimeOrLabel(f, 0, !0, e)), !(e instanceof a))) {
                                    if (e instanceof Array || (e && e.push && i(e))) {
                                        for (g = g || "normal", h = h || 0, j = f, k = e.length, l = 0; k > l; l++)
                                            i((m = e[l])) && (m = new d({ tweens: m })),
                                                this.add(m, j),
                                                "string" != typeof m && "function" != typeof m && ("sequence" === g ? (j = m._startTime + m.totalDuration() / m._timeScale) : "start" === g && (m._startTime -= m.delay())),
                                                (j += h);
                                        return this._uncache(!0);
                                    }
                                    if ("string" == typeof e) return this.addLabel(e, f);
                                    if ("function" != typeof e) throw "Cannot add " + e + " into the timeline; it is not a tween, timeline, function, or string.";
                                    e = c.delayedCall(0, e);
                                }
                                if ((b.prototype.add.call(this, e, f), (this._gc || this._time === this._duration) && !this._paused && this._duration < this.duration()))
                                    for (n = this, o = n.rawTime() > e._startTime; n._timeline;) o && n._timeline.smoothChildTiming ? n.totalTime(n._totalTime, !0) : n._gc && n._enabled(!0, !1), (n = n._timeline);
                                return this;
                            }),
                            (q.remove = function (b) {
                                if (b instanceof a) {
                                    this._remove(b, !1);
                                    var c = (b._timeline = b.vars.useFrames ? a._rootFramesTimeline : a._rootTimeline);
                                    return (b._startTime = (b._paused ? b._pauseTime : c._time) - (b._reversed ? b.totalDuration() - b._totalTime : b._totalTime) / b._timeScale), this;
                                }
                                if (b instanceof Array || (b && b.push && i(b))) {
                                    for (var d = b.length; --d > -1;) this.remove(b[d]);
                                    return this;
                                }
                                return "string" == typeof b ? this.removeLabel(b) : this.kill(null, b);
                            }),
                            (q._remove = function (a, c) {
                                b.prototype._remove.call(this, a, c);
                                var d = this._last;
                                return d ? this._time > this.duration() && ((this._time = this._duration), (this._totalTime = this._totalDuration)) : (this._time = this._totalTime = this._duration = this._totalDuration = 0), this;
                            }),
                            (q.append = function (a, b) {
                                return this.add(a, this._parseTimeOrLabel(null, b, !0, a));
                            }),
                            (q.insert = q.insertMultiple = function (a, b, c, d) {
                                return this.add(a, b || 0, c, d);
                            }),
                            (q.appendMultiple = function (a, b, c, d) {
                                return this.add(a, this._parseTimeOrLabel(null, b, !0, a), c, d);
                            }),
                            (q.addLabel = function (a, b) {
                                return (this._labels[a] = this._parseTimeOrLabel(b)), this;
                            }),
                            (q.addPause = function (a, b, d, e) {
                                var f = c.delayedCall(0, o, d, e || this);
                                return (f.vars.onComplete = f.vars.onReverseComplete = b), (f.data = "isPause"), (this._hasPause = !0), this.add(f, a);
                            }),
                            (q.removeLabel = function (a) {
                                return delete this._labels[a], this;
                            }),
                            (q.getLabelTime = function (a) {
                                return null != this._labels[a] ? this._labels[a] : -1;
                            }),
                            (q._parseTimeOrLabel = function (b, c, d, e) {
                                var f;
                                if (e instanceof a && e.timeline === this) this.remove(e);
                                else if (e && (e instanceof Array || (e.push && i(e)))) for (f = e.length; --f > -1;) e[f] instanceof a && e[f].timeline === this && this.remove(e[f]);
                                if ("string" == typeof c) return this._parseTimeOrLabel(c, d && "number" == typeof b && null == this._labels[c] ? b - this.duration() : 0, d);
                                if (((c = c || 0), "string" != typeof b || (!isNaN(b) && null == this._labels[b]))) null == b && (b = this.duration());
                                else {
                                    if (((f = b.indexOf("=")), -1 === f)) return null == this._labels[b] ? (d ? (this._labels[b] = this.duration() + c) : c) : this._labels[b] + c;
                                    (c = parseInt(b.charAt(f - 1) + "1", 10) * Number(b.substr(f + 1))), (b = f > 1 ? this._parseTimeOrLabel(b.substr(0, f - 1), 0, d) : this.duration());
                                }
                                return Number(b) + c;
                            }),
                            (q.seek = function (a, b) {
                                return this.totalTime("number" == typeof a ? a : this._parseTimeOrLabel(a), b !== !1);
                            }),
                            (q.stop = function () {
                                return this.paused(!0);
                            }),
                            (q.gotoAndPlay = function (a, b) {
                                return this.play(a, b);
                            }),
                            (q.gotoAndStop = function (a, b) {
                                return this.pause(a, b);
                            }),
                            (q.render = function (a, b, c) {
                                this._gc && this._enabled(!0, !1);
                                var d,
                                    f,
                                    g,
                                    h,
                                    i,
                                    l,
                                    m,
                                    n = this._dirty ? this.totalDuration() : this._totalDuration,
                                    o = this._time,
                                    p = this._startTime,
                                    q = this._timeScale,
                                    r = this._paused;
                                if (a >= n - 1e-7 && a >= 0)
                                    (this._totalTime = this._time = n),
                                        this._reversed ||
                                        this._hasPausedChild() ||
                                        ((f = !0),
                                            (h = "onComplete"),
                                            (i = !!this._timeline.autoRemoveChildren),
                                            0 === this._duration &&
                                            ((0 >= a && a >= -1e-7) || this._rawPrevTime < 0 || this._rawPrevTime === e) &&
                                            this._rawPrevTime !== a &&
                                            this._first &&
                                            ((i = !0), this._rawPrevTime > e && (h = "onReverseComplete"))),
                                        (this._rawPrevTime = this._duration || !b || a || this._rawPrevTime === a ? a : e),
                                        (a = n + 1e-4);
                                else if (1e-7 > a)
                                    if (
                                        ((this._totalTime = this._time = 0),
                                            (0 !== o || (0 === this._duration && this._rawPrevTime !== e && (this._rawPrevTime > 0 || (0 > a && this._rawPrevTime >= 0)))) && ((h = "onReverseComplete"), (f = this._reversed)),
                                            0 > a)
                                    )
                                        (this._active = !1), this._timeline.autoRemoveChildren && this._reversed ? ((i = f = !0), (h = "onReverseComplete")) : this._rawPrevTime >= 0 && this._first && (i = !0), (this._rawPrevTime = a);
                                    else {
                                        if (((this._rawPrevTime = this._duration || !b || a || this._rawPrevTime === a ? a : e), 0 === a && f)) for (d = this._first; d && 0 === d._startTime;) d._duration || (f = !1), (d = d._next);
                                        (a = 0), this._initted || (i = !0);
                                    }
                                else {
                                    if (this._hasPause && !this._forcingPlayhead && !b) {
                                        if (a >= o) for (d = this._first; d && d._startTime <= a && !l;) d._duration || "isPause" !== d.data || d.ratio || (0 === d._startTime && 0 === this._rawPrevTime) || (l = d), (d = d._next);
                                        else for (d = this._last; d && d._startTime >= a && !l;) d._duration || ("isPause" === d.data && d._rawPrevTime > 0 && (l = d)), (d = d._prev);
                                        l && ((this._time = a = l._startTime), (this._totalTime = a + this._cycle * (this._totalDuration + this._repeatDelay)));
                                    }
                                    this._totalTime = this._time = this._rawPrevTime = a;
                                }
                                if ((this._time !== o && this._first) || c || i || l) {
                                    if (
                                        (this._initted || (this._initted = !0),
                                            this._active || (!this._paused && this._time !== o && a > 0 && (this._active = !0)),
                                            0 === o && this.vars.onStart && ((0 === this._time && this._duration) || b || this._callback("onStart")),
                                            (m = this._time),
                                            m >= o)
                                    )
                                        for (d = this._first; d && ((g = d._next), m === this._time && (!this._paused || r));)
                                            (d._active || (d._startTime <= m && !d._paused && !d._gc)) &&
                                                (l === d && this.pause(),
                                                    d._reversed ? d.render((d._dirty ? d.totalDuration() : d._totalDuration) - (a - d._startTime) * d._timeScale, b, c) : d.render((a - d._startTime) * d._timeScale, b, c)),
                                                (d = g);
                                    else
                                        for (d = this._last; d && ((g = d._prev), m === this._time && (!this._paused || r));) {
                                            if (d._active || (d._startTime <= o && !d._paused && !d._gc)) {
                                                if (l === d) {
                                                    for (l = d._prev; l && l.endTime() > this._time;) l.render(l._reversed ? l.totalDuration() - (a - l._startTime) * l._timeScale : (a - l._startTime) * l._timeScale, b, c), (l = l._prev);
                                                    (l = null), this.pause();
                                                }
                                                d._reversed ? d.render((d._dirty ? d.totalDuration() : d._totalDuration) - (a - d._startTime) * d._timeScale, b, c) : d.render((a - d._startTime) * d._timeScale, b, c);
                                            }
                                            d = g;
                                        }
                                    this._onUpdate && (b || (j.length && k(), this._callback("onUpdate"))),
                                        h &&
                                        (this._gc ||
                                            ((p === this._startTime || q !== this._timeScale) &&
                                                (0 === this._time || n >= this.totalDuration()) &&
                                                (f && (j.length && k(), this._timeline.autoRemoveChildren && this._enabled(!1, !1), (this._active = !1)), !b && this.vars[h] && this._callback(h))));
                                }
                            }),
                            (q._hasPausedChild = function () {
                                for (var a = this._first; a;) {
                                    if (a._paused || (a instanceof d && a._hasPausedChild())) return !0;
                                    a = a._next;
                                }
                                return !1;
                            }),
                            (q.getChildren = function (a, b, d, e) {
                                e = e || -9999999999;
                                for (var f = [], g = this._first, h = 0; g;)
                                    g._startTime < e || (g instanceof c ? b !== !1 && (f[h++] = g) : (d !== !1 && (f[h++] = g), a !== !1 && ((f = f.concat(g.getChildren(!0, b, d))), (h = f.length)))), (g = g._next);
                                return f;
                            }),
                            (q.getTweensOf = function (a, b) {
                                var d,
                                    e,
                                    f = this._gc,
                                    g = [],
                                    h = 0;
                                for (f && this._enabled(!0, !0), d = c.getTweensOf(a), e = d.length; --e > -1;) (d[e].timeline === this || (b && this._contains(d[e]))) && (g[h++] = d[e]);
                                return f && this._enabled(!1, !0), g;
                            }),
                            (q.recent = function () {
                                return this._recent;
                            }),
                            (q._contains = function (a) {
                                for (var b = a.timeline; b;) {
                                    if (b === this) return !0;
                                    b = b.timeline;
                                }
                                return !1;
                            }),
                            (q.shiftChildren = function (a, b, c) {
                                c = c || 0;
                                for (var d, e = this._first, f = this._labels; e;) e._startTime >= c && (e._startTime += a), (e = e._next);
                                if (b) for (d in f) f[d] >= c && (f[d] += a);
                                return this._uncache(!0);
                            }),
                            (q._kill = function (a, b) {
                                if (!a && !b) return this._enabled(!1, !1);
                                for (var c = b ? this.getTweensOf(b) : this.getChildren(!0, !0, !1), d = c.length, e = !1; --d > -1;) c[d]._kill(a, b) && (e = !0);
                                return e;
                            }),
                            (q.clear = function (a) {
                                var b = this.getChildren(!1, !0, !0),
                                    c = b.length;
                                for (this._time = this._totalTime = 0; --c > -1;) b[c]._enabled(!1, !1);
                                return a !== !1 && (this._labels = {}), this._uncache(!0);
                            }),
                            (q.invalidate = function () {
                                for (var b = this._first; b;) b.invalidate(), (b = b._next);
                                return a.prototype.invalidate.call(this);
                            }),
                            (q._enabled = function (a, c) {
                                if (a === this._gc) for (var d = this._first; d;) d._enabled(a, !0), (d = d._next);
                                return b.prototype._enabled.call(this, a, c);
                            }),
                            (q.totalTime = function (b, c, d) {
                                this._forcingPlayhead = !0;
                                var e = a.prototype.totalTime.apply(this, arguments);
                                return (this._forcingPlayhead = !1), e;
                            }),
                            (q.duration = function (a) {
                                return arguments.length ? (0 !== this.duration() && 0 !== a && this.timeScale(this._duration / a), this) : (this._dirty && this.totalDuration(), this._duration);
                            }),
                            (q.totalDuration = function (a) {
                                if (!arguments.length) {
                                    if (this._dirty) {
                                        for (var b, c, d = 0, e = this._last, f = 999999999999; e;)
                                            (b = e._prev),
                                                e._dirty && e.totalDuration(),
                                                e._startTime > f && this._sortChildren && !e._paused ? this.add(e, e._startTime - e._delay) : (f = e._startTime),
                                                e._startTime < 0 &&
                                                !e._paused &&
                                                ((d -= e._startTime), this._timeline.smoothChildTiming && (this._startTime += e._startTime / this._timeScale), this.shiftChildren(-e._startTime, !1, -9999999999), (f = 0)),
                                                (c = e._startTime + e._totalDuration / e._timeScale),
                                                c > d && (d = c),
                                                (e = b);
                                        (this._duration = this._totalDuration = d), (this._dirty = !1);
                                    }
                                    return this._totalDuration;
                                }
                                return a && this.totalDuration() ? this.timeScale(this._totalDuration / a) : this;
                            }),
                            (q.paused = function (b) {
                                if (!b) for (var c = this._first, d = this._time; c;) c._startTime === d && "isPause" === c.data && (c._rawPrevTime = 0), (c = c._next);
                                return a.prototype.paused.apply(this, arguments);
                            }),
                            (q.usesFrames = function () {
                                for (var b = this._timeline; b._timeline;) b = b._timeline;
                                return b === a._rootFramesTimeline;
                            }),
                            (q.rawTime = function (a) {
                                return a && (this._paused || (this._repeat && this.time() > 0 && this.totalProgress() < 1))
                                    ? this._totalTime % (this._duration + this._repeatDelay)
                                    : this._paused
                                        ? this._totalTime
                                        : (this._timeline.rawTime(a) - this._startTime) * this._timeScale;
                            }),
                            d
                        );
                    },
                    !0
                ),
                _gsScope._gsDefine(
                    "TimelineMax",
                    ["TimelineLite", "TweenLite", "easing.Ease"],
                    function (a, b, c) {
                        var d = function (b) {
                            a.call(this, b), (this._repeat = this.vars.repeat || 0), (this._repeatDelay = this.vars.repeatDelay || 0), (this._cycle = 0), (this._yoyo = this.vars.yoyo === !0), (this._dirty = !0);
                        },
                            e = 1e-10,
                            f = b._internals,
                            g = f.lazyTweens,
                            h = f.lazyRender,
                            i = _gsScope._gsDefine.globals,
                            j = new c(null, null, 1, 0),
                            k = (d.prototype = new a());
                        return (
                            (k.constructor = d),
                            (k.kill()._gc = !1),
                            (d.version = "1.19.1"),
                            (k.invalidate = function () {
                                return (this._yoyo = this.vars.yoyo === !0), (this._repeat = this.vars.repeat || 0), (this._repeatDelay = this.vars.repeatDelay || 0), this._uncache(!0), a.prototype.invalidate.call(this);
                            }),
                            (k.addCallback = function (a, c, d, e) {
                                return this.add(b.delayedCall(0, a, d, e), c);
                            }),
                            (k.removeCallback = function (a, b) {
                                if (a)
                                    if (null == b) this._kill(null, a);
                                    else for (var c = this.getTweensOf(a, !1), d = c.length, e = this._parseTimeOrLabel(b); --d > -1;) c[d]._startTime === e && c[d]._enabled(!1, !1);
                                return this;
                            }),
                            (k.removePause = function (b) {
                                return this.removeCallback(a._internals.pauseCallback, b);
                            }),
                            (k.tweenTo = function (a, c) {
                                c = c || {};
                                var d,
                                    e,
                                    f,
                                    g = { ease: j, useFrames: this.usesFrames(), immediateRender: !1 },
                                    h = (c.repeat && i.TweenMax) || b;
                                for (e in c) g[e] = c[e];
                                return (
                                    (g.time = this._parseTimeOrLabel(a)),
                                    (d = Math.abs(Number(g.time) - this._time) / this._timeScale || 0.001),
                                    (f = new h(this, d, g)),
                                    (g.onStart = function () {
                                        f.target.paused(!0),
                                            f.vars.time !== f.target.time() && d === f.duration() && f.duration(Math.abs(f.vars.time - f.target.time()) / f.target._timeScale),
                                            c.onStart && c.onStart.apply(c.onStartScope || c.callbackScope || f, c.onStartParams || []);
                                    }),
                                    f
                                );
                            }),
                            (k.tweenFromTo = function (a, b, c) {
                                (c = c || {}), (a = this._parseTimeOrLabel(a)), (c.startAt = { onComplete: this.seek, onCompleteParams: [a], callbackScope: this }), (c.immediateRender = c.immediateRender !== !1);
                                var d = this.tweenTo(b, c);
                                return d.duration(Math.abs(d.vars.time - a) / this._timeScale || 0.001);
                            }),
                            (k.render = function (a, b, c) {
                                this._gc && this._enabled(!0, !1);
                                var d,
                                    f,
                                    i,
                                    j,
                                    k,
                                    l,
                                    m,
                                    n,
                                    o = this._dirty ? this.totalDuration() : this._totalDuration,
                                    p = this._duration,
                                    q = this._time,
                                    r = this._totalTime,
                                    s = this._startTime,
                                    t = this._timeScale,
                                    u = this._rawPrevTime,
                                    v = this._paused,
                                    w = this._cycle;
                                if (a >= o - 1e-7 && a >= 0)
                                    this._locked || ((this._totalTime = o), (this._cycle = this._repeat)),
                                        this._reversed ||
                                        this._hasPausedChild() ||
                                        ((f = !0),
                                            (j = "onComplete"),
                                            (k = !!this._timeline.autoRemoveChildren),
                                            0 === this._duration && ((0 >= a && a >= -1e-7) || 0 > u || u === e) && u !== a && this._first && ((k = !0), u > e && (j = "onReverseComplete"))),
                                        (this._rawPrevTime = this._duration || !b || a || this._rawPrevTime === a ? a : e),
                                        this._yoyo && 0 !== (1 & this._cycle) ? (this._time = a = 0) : ((this._time = p), (a = p + 1e-4));
                                else if (1e-7 > a)
                                    if (
                                        (this._locked || (this._totalTime = this._cycle = 0),
                                            (this._time = 0),
                                            (0 !== q || (0 === p && u !== e && (u > 0 || (0 > a && u >= 0)) && !this._locked)) && ((j = "onReverseComplete"), (f = this._reversed)),
                                            0 > a)
                                    )
                                        (this._active = !1), this._timeline.autoRemoveChildren && this._reversed ? ((k = f = !0), (j = "onReverseComplete")) : u >= 0 && this._first && (k = !0), (this._rawPrevTime = a);
                                    else {
                                        if (((this._rawPrevTime = p || !b || a || this._rawPrevTime === a ? a : e), 0 === a && f)) for (d = this._first; d && 0 === d._startTime;) d._duration || (f = !1), (d = d._next);
                                        (a = 0), this._initted || (k = !0);
                                    }
                                else if (
                                    (0 === p && 0 > u && (k = !0),
                                        (this._time = this._rawPrevTime = a),
                                        this._locked ||
                                        ((this._totalTime = a),
                                            0 !== this._repeat &&
                                            ((l = p + this._repeatDelay),
                                                (this._cycle = (this._totalTime / l) >> 0),
                                                0 !== this._cycle && this._cycle === this._totalTime / l && a >= r && this._cycle--,
                                                (this._time = this._totalTime - this._cycle * l),
                                                this._yoyo && 0 !== (1 & this._cycle) && (this._time = p - this._time),
                                                this._time > p ? ((this._time = p), (a = p + 1e-4)) : this._time < 0 ? (this._time = a = 0) : (a = this._time))),
                                        this._hasPause && !this._forcingPlayhead && !b && p > a)
                                ) {
                                    if (((a = this._time), a >= q || (this._repeat && w !== this._cycle)))
                                        for (d = this._first; d && d._startTime <= a && !m;) d._duration || "isPause" !== d.data || d.ratio || (0 === d._startTime && 0 === this._rawPrevTime) || (m = d), (d = d._next);
                                    else for (d = this._last; d && d._startTime >= a && !m;) d._duration || ("isPause" === d.data && d._rawPrevTime > 0 && (m = d)), (d = d._prev);
                                    m && ((this._time = a = m._startTime), (this._totalTime = a + this._cycle * (this._totalDuration + this._repeatDelay)));
                                }
                                if (this._cycle !== w && !this._locked) {
                                    var x = this._yoyo && 0 !== (1 & w),
                                        y = x === (this._yoyo && 0 !== (1 & this._cycle)),
                                        z = this._totalTime,
                                        A = this._cycle,
                                        B = this._rawPrevTime,
                                        C = this._time;
                                    if (
                                        ((this._totalTime = w * p),
                                            this._cycle < w ? (x = !x) : (this._totalTime += p),
                                            (this._time = q),
                                            (this._rawPrevTime = 0 === p ? u - 1e-4 : u),
                                            (this._cycle = w),
                                            (this._locked = !0),
                                            (q = x ? 0 : p),
                                            this.render(q, b, 0 === p),
                                            b || this._gc || (this.vars.onRepeat && ((this._cycle = A), (this._locked = !1), this._callback("onRepeat"))),
                                            q !== this._time)
                                    )
                                        return;
                                    if ((y && ((this._cycle = w), (this._locked = !0), (q = x ? p + 1e-4 : -1e-4), this.render(q, !0, !1)), (this._locked = !1), this._paused && !v)) return;
                                    (this._time = C), (this._totalTime = z), (this._cycle = A), (this._rawPrevTime = B);
                                }
                                if (!((this._time !== q && this._first) || c || k || m)) return void (r !== this._totalTime && this._onUpdate && (b || this._callback("onUpdate")));
                                if (
                                    (this._initted || (this._initted = !0),
                                        this._active || (!this._paused && this._totalTime !== r && a > 0 && (this._active = !0)),
                                        0 === r && this.vars.onStart && ((0 === this._totalTime && this._totalDuration) || b || this._callback("onStart")),
                                        (n = this._time),
                                        n >= q)
                                )
                                    for (d = this._first; d && ((i = d._next), n === this._time && (!this._paused || v));)
                                        (d._active || (d._startTime <= this._time && !d._paused && !d._gc)) &&
                                            (m === d && this.pause(), d._reversed ? d.render((d._dirty ? d.totalDuration() : d._totalDuration) - (a - d._startTime) * d._timeScale, b, c) : d.render((a - d._startTime) * d._timeScale, b, c)),
                                            (d = i);
                                else
                                    for (d = this._last; d && ((i = d._prev), n === this._time && (!this._paused || v));) {
                                        if (d._active || (d._startTime <= q && !d._paused && !d._gc)) {
                                            if (m === d) {
                                                for (m = d._prev; m && m.endTime() > this._time;) m.render(m._reversed ? m.totalDuration() - (a - m._startTime) * m._timeScale : (a - m._startTime) * m._timeScale, b, c), (m = m._prev);
                                                (m = null), this.pause();
                                            }
                                            d._reversed ? d.render((d._dirty ? d.totalDuration() : d._totalDuration) - (a - d._startTime) * d._timeScale, b, c) : d.render((a - d._startTime) * d._timeScale, b, c);
                                        }
                                        d = i;
                                    }
                                this._onUpdate && (b || (g.length && h(), this._callback("onUpdate"))),
                                    j &&
                                    (this._locked ||
                                        this._gc ||
                                        ((s === this._startTime || t !== this._timeScale) &&
                                            (0 === this._time || o >= this.totalDuration()) &&
                                            (f && (g.length && h(), this._timeline.autoRemoveChildren && this._enabled(!1, !1), (this._active = !1)), !b && this.vars[j] && this._callback(j))));
                            }),
                            (k.getActive = function (a, b, c) {
                                null == a && (a = !0), null == b && (b = !0), null == c && (c = !1);
                                var d,
                                    e,
                                    f = [],
                                    g = this.getChildren(a, b, c),
                                    h = 0,
                                    i = g.length;
                                for (d = 0; i > d; d++) (e = g[d]), e.isActive() && (f[h++] = e);
                                return f;
                            }),
                            (k.getLabelAfter = function (a) {
                                a || (0 !== a && (a = this._time));
                                var b,
                                    c = this.getLabelsArray(),
                                    d = c.length;
                                for (b = 0; d > b; b++) if (c[b].time > a) return c[b].name;
                                return null;
                            }),
                            (k.getLabelBefore = function (a) {
                                null == a && (a = this._time);
                                for (var b = this.getLabelsArray(), c = b.length; --c > -1;) if (b[c].time < a) return b[c].name;
                                return null;
                            }),
                            (k.getLabelsArray = function () {
                                var a,
                                    b = [],
                                    c = 0;
                                for (a in this._labels) b[c++] = { time: this._labels[a], name: a };
                                return (
                                    b.sort(function (a, b) {
                                        return a.time - b.time;
                                    }),
                                    b
                                );
                            }),
                            (k.invalidate = function () {
                                return (this._locked = !1), a.prototype.invalidate.call(this);
                            }),
                            (k.progress = function (a, b) {
                                return arguments.length ? this.totalTime(this.duration() * (this._yoyo && 0 !== (1 & this._cycle) ? 1 - a : a) + this._cycle * (this._duration + this._repeatDelay), b) : this._time / this.duration();
                            }),
                            (k.totalProgress = function (a, b) {
                                return arguments.length ? this.totalTime(this.totalDuration() * a, b) : this._totalTime / this.totalDuration();
                            }),
                            (k.totalDuration = function (b) {
                                return arguments.length
                                    ? -1 !== this._repeat && b
                                        ? this.timeScale(this.totalDuration() / b)
                                        : this
                                    : (this._dirty && (a.prototype.totalDuration.call(this), (this._totalDuration = -1 === this._repeat ? 999999999999 : this._duration * (this._repeat + 1) + this._repeatDelay * this._repeat)),
                                        this._totalDuration);
                            }),
                            (k.time = function (a, b) {
                                return arguments.length
                                    ? (this._dirty && this.totalDuration(),
                                        a > this._duration && (a = this._duration),
                                        this._yoyo && 0 !== (1 & this._cycle) ? (a = this._duration - a + this._cycle * (this._duration + this._repeatDelay)) : 0 !== this._repeat && (a += this._cycle * (this._duration + this._repeatDelay)),
                                        this.totalTime(a, b))
                                    : this._time;
                            }),
                            (k.repeat = function (a) {
                                return arguments.length ? ((this._repeat = a), this._uncache(!0)) : this._repeat;
                            }),
                            (k.repeatDelay = function (a) {
                                return arguments.length ? ((this._repeatDelay = a), this._uncache(!0)) : this._repeatDelay;
                            }),
                            (k.yoyo = function (a) {
                                return arguments.length ? ((this._yoyo = a), this) : this._yoyo;
                            }),
                            (k.currentLabel = function (a) {
                                return arguments.length ? this.seek(a, !0) : this.getLabelBefore(this._time + 1e-8);
                            }),
                            d
                        );
                    },
                    !0
                ),
                (function () {
                    var a = 180 / Math.PI,
                        b = [],
                        c = [],
                        d = [],
                        e = {},
                        f = _gsScope._gsDefine.globals,
                        g = function (a, b, c, d) {
                            c === d && (c = d - (d - b) / 1e6), a === b && (b = a + (c - a) / 1e6), (this.a = a), (this.b = b), (this.c = c), (this.d = d), (this.da = d - a), (this.ca = c - a), (this.ba = b - a);
                        },
                        h = ",x,y,z,left,top,right,bottom,marginTop,marginLeft,marginRight,marginBottom,paddingLeft,paddingTop,paddingRight,paddingBottom,backgroundPosition,backgroundPosition_y,",
                        i = function (a, b, c, d) {
                            var e = { a: a },
                                f = {},
                                g = {},
                                h = { c: d },
                                i = (a + b) / 2,
                                j = (b + c) / 2,
                                k = (c + d) / 2,
                                l = (i + j) / 2,
                                m = (j + k) / 2,
                                n = (m - l) / 8;
                            return (e.b = i + (a - i) / 4), (f.b = l + n), (e.c = f.a = (e.b + f.b) / 2), (f.c = g.a = (l + m) / 2), (g.b = m - n), (h.b = k + (d - k) / 4), (g.c = h.a = (g.b + h.b) / 2), [e, f, g, h];
                        },
                        j = function (a, e, f, g, h) {
                            var j,
                                k,
                                l,
                                m,
                                n,
                                o,
                                p,
                                q,
                                r,
                                s,
                                t,
                                u,
                                v,
                                w = a.length - 1,
                                x = 0,
                                y = a[0].a;
                            for (j = 0; w > j; j++)
                                (n = a[x]),
                                    (k = n.a),
                                    (l = n.d),
                                    (m = a[x + 1].d),
                                    h
                                        ? ((t = b[j]),
                                            (u = c[j]),
                                            (v = ((u + t) * e * 0.25) / (g ? 0.5 : d[j] || 0.5)),
                                            (o = l - (l - k) * (g ? 0.5 * e : 0 !== t ? v / t : 0)),
                                            (p = l + (m - l) * (g ? 0.5 * e : 0 !== u ? v / u : 0)),
                                            (q = l - (o + (((p - o) * ((3 * t) / (t + u) + 0.5)) / 4 || 0))))
                                        : ((o = l - (l - k) * e * 0.5), (p = l + (m - l) * e * 0.5), (q = l - (o + p) / 2)),
                                    (o += q),
                                    (p += q),
                                    (n.c = r = o),
                                    0 !== j ? (n.b = y) : (n.b = y = n.a + 0.6 * (n.c - n.a)),
                                    (n.da = l - k),
                                    (n.ca = r - k),
                                    (n.ba = y - k),
                                    f ? ((s = i(k, y, r, l)), a.splice(x, 1, s[0], s[1], s[2], s[3]), (x += 4)) : x++,
                                    (y = p);
                            (n = a[x]), (n.b = y), (n.c = y + 0.4 * (n.d - y)), (n.da = n.d - n.a), (n.ca = n.c - n.a), (n.ba = y - n.a), f && ((s = i(n.a, y, n.c, n.d)), a.splice(x, 1, s[0], s[1], s[2], s[3]));
                        },
                        k = function (a, d, e, f) {
                            var h,
                                i,
                                j,
                                k,
                                l,
                                m,
                                n = [];
                            if (f) for (a = [f].concat(a), i = a.length; --i > -1;) "string" == typeof (m = a[i][d]) && "=" === m.charAt(1) && (a[i][d] = f[d] + Number(m.charAt(0) + m.substr(2)));
                            if (((h = a.length - 2), 0 > h)) return (n[0] = new g(a[0][d], 0, 0, a[-1 > h ? 0 : 1][d])), n;
                            for (i = 0; h > i; i++) (j = a[i][d]), (k = a[i + 1][d]), (n[i] = new g(j, 0, 0, k)), e && ((l = a[i + 2][d]), (b[i] = (b[i] || 0) + (k - j) * (k - j)), (c[i] = (c[i] || 0) + (l - k) * (l - k)));
                            return (n[i] = new g(a[i][d], 0, 0, a[i + 1][d])), n;
                        },
                        l = function (a, f, g, i, l, m) {
                            var n,
                                o,
                                p,
                                q,
                                r,
                                s,
                                t,
                                u,
                                v = {},
                                w = [],
                                x = m || a[0];
                            (l = "string" == typeof l ? "," + l + "," : h), null == f && (f = 1);
                            for (o in a[0]) w.push(o);
                            if (a.length > 1) {
                                for (u = a[a.length - 1], t = !0, n = w.length; --n > -1;)
                                    if (((o = w[n]), Math.abs(x[o] - u[o]) > 0.05)) {
                                        t = !1;
                                        break;
                                    }
                                t && ((a = a.concat()), m && a.unshift(m), a.push(a[1]), (m = a[a.length - 3]));
                            }
                            for (b.length = c.length = d.length = 0, n = w.length; --n > -1;) (o = w[n]), (e[o] = -1 !== l.indexOf("," + o + ",")), (v[o] = k(a, o, e[o], m));
                            for (n = b.length; --n > -1;) (b[n] = Math.sqrt(b[n])), (c[n] = Math.sqrt(c[n]));
                            if (!i) {
                                for (n = w.length; --n > -1;) if (e[o]) for (p = v[w[n]], s = p.length - 1, q = 0; s > q; q++) (r = p[q + 1].da / c[q] + p[q].da / b[q] || 0), (d[q] = (d[q] || 0) + r * r);
                                for (n = d.length; --n > -1;) d[n] = Math.sqrt(d[n]);
                            }
                            for (n = w.length, q = g ? 4 : 1; --n > -1;) (o = w[n]), (p = v[o]), j(p, f, g, i, e[o]), t && (p.splice(0, q), p.splice(p.length - q, q));
                            return v;
                        },
                        m = function (a, b, c) {
                            b = b || "soft";
                            var d,
                                e,
                                f,
                                h,
                                i,
                                j,
                                k,
                                l,
                                m,
                                n,
                                o,
                                p = {},
                                q = "cubic" === b ? 3 : 2,
                                r = "soft" === b,
                                s = [];
                            if ((r && c && (a = [c].concat(a)), null == a || a.length < q + 1)) throw "invalid Bezier data";
                            for (m in a[0]) s.push(m);
                            for (j = s.length; --j > -1;) {
                                for (m = s[j], p[m] = i = [], n = 0, l = a.length, k = 0; l > k; k++)
                                    (d = null == c ? a[k][m] : "string" == typeof (o = a[k][m]) && "=" === o.charAt(1) ? c[m] + Number(o.charAt(0) + o.substr(2)) : Number(o)),
                                        r && k > 1 && l - 1 > k && (i[n++] = (d + i[n - 2]) / 2),
                                        (i[n++] = d);
                                for (l = n - q + 1, n = 0, k = 0; l > k; k += q)
                                    (d = i[k]), (e = i[k + 1]), (f = i[k + 2]), (h = 2 === q ? 0 : i[k + 3]), (i[n++] = o = 3 === q ? new g(d, e, f, h) : new g(d, (2 * e + d) / 3, (2 * e + f) / 3, f));
                                i.length = n;
                            }
                            return p;
                        },
                        n = function (a, b, c) {
                            for (var d, e, f, g, h, i, j, k, l, m, n, o = 1 / c, p = a.length; --p > -1;)
                                for (m = a[p], f = m.a, g = m.d - f, h = m.c - f, i = m.b - f, d = e = 0, k = 1; c >= k; k++)
                                    (j = o * k), (l = 1 - j), (d = e - (e = (j * j * g + 3 * l * (j * h + l * i)) * j)), (n = p * c + k - 1), (b[n] = (b[n] || 0) + d * d);
                        },
                        o = function (a, b) {
                            b = b >> 0 || 6;
                            var c,
                                d,
                                e,
                                f,
                                g = [],
                                h = [],
                                i = 0,
                                j = 0,
                                k = b - 1,
                                l = [],
                                m = [];
                            for (c in a) n(a[c], g, b);
                            for (e = g.length, d = 0; e > d; d++) (i += Math.sqrt(g[d])), (f = d % b), (m[f] = i), f === k && ((j += i), (f = (d / b) >> 0), (l[f] = m), (h[f] = j), (i = 0), (m = []));
                            return { length: j, lengths: h, segments: l };
                        },
                        p = _gsScope._gsDefine.plugin({
                            propName: "bezier",
                            priority: -1,
                            version: "1.3.7",
                            API: 2,
                            global: !0,
                            init: function (a, b, c) {
                                (this._target = a), b instanceof Array && (b = { values: b }), (this._func = {}), (this._mod = {}), (this._props = []), (this._timeRes = null == b.timeResolution ? 6 : parseInt(b.timeResolution, 10));
                                var d,
                                    e,
                                    f,
                                    g,
                                    h,
                                    i = b.values || [],
                                    j = {},
                                    k = i[0],
                                    n = b.autoRotate || c.vars.orientToBezier;
                                this._autoRotate = n ? (n instanceof Array ? n : [["x", "y", "rotation", n === !0 ? 0 : Number(n) || 0]]) : null;
                                for (d in k) this._props.push(d);
                                for (f = this._props.length; --f > -1;)
                                    (d = this._props[f]),
                                        this._overwriteProps.push(d),
                                        (e = this._func[d] = "function" == typeof a[d]),
                                        (j[d] = e ? a[d.indexOf("set") || "function" != typeof a["get" + d.substr(3)] ? d : "get" + d.substr(3)]() : parseFloat(a[d])),
                                        h || (j[d] !== i[0][d] && (h = j));
                                if (
                                    ((this._beziers = "cubic" !== b.type && "quadratic" !== b.type && "soft" !== b.type ? l(i, isNaN(b.curviness) ? 1 : b.curviness, !1, "thruBasic" === b.type, b.correlate, h) : m(i, b.type, j)),
                                        (this._segCount = this._beziers[d].length),
                                        this._timeRes)
                                ) {
                                    var p = o(this._beziers, this._timeRes);
                                    (this._length = p.length),
                                        (this._lengths = p.lengths),
                                        (this._segments = p.segments),
                                        (this._l1 = this._li = this._s1 = this._si = 0),
                                        (this._l2 = this._lengths[0]),
                                        (this._curSeg = this._segments[0]),
                                        (this._s2 = this._curSeg[0]),
                                        (this._prec = 1 / this._curSeg.length);
                                }
                                if ((n = this._autoRotate))
                                    for (this._initialRotations = [], n[0] instanceof Array || (this._autoRotate = n = [n]), f = n.length; --f > -1;) {
                                        for (g = 0; 3 > g; g++) (d = n[f][g]), (this._func[d] = "function" == typeof a[d] ? a[d.indexOf("set") || "function" != typeof a["get" + d.substr(3)] ? d : "get" + d.substr(3)] : !1);
                                        (d = n[f][2]), (this._initialRotations[f] = (this._func[d] ? this._func[d].call(this._target) : this._target[d]) || 0), this._overwriteProps.push(d);
                                    }
                                return (this._startRatio = c.vars.runBackwards ? 1 : 0), !0;
                            },
                            set: function (b) {
                                var c,
                                    d,
                                    e,
                                    f,
                                    g,
                                    h,
                                    i,
                                    j,
                                    k,
                                    l,
                                    m = this._segCount,
                                    n = this._func,
                                    o = this._target,
                                    p = b !== this._startRatio;
                                if (this._timeRes) {
                                    if (((k = this._lengths), (l = this._curSeg), (b *= this._length), (e = this._li), b > this._l2 && m - 1 > e)) {
                                        for (j = m - 1; j > e && (this._l2 = k[++e]) <= b;);
                                        (this._l1 = k[e - 1]), (this._li = e), (this._curSeg = l = this._segments[e]), (this._s2 = l[(this._s1 = this._si = 0)]);
                                    } else if (b < this._l1 && e > 0) {
                                        for (; e > 0 && (this._l1 = k[--e]) >= b;);
                                        0 === e && b < this._l1 ? (this._l1 = 0) : e++, (this._l2 = k[e]), (this._li = e), (this._curSeg = l = this._segments[e]), (this._s1 = l[(this._si = l.length - 1) - 1] || 0), (this._s2 = l[this._si]);
                                    }
                                    if (((c = e), (b -= this._l1), (e = this._si), b > this._s2 && e < l.length - 1)) {
                                        for (j = l.length - 1; j > e && (this._s2 = l[++e]) <= b;);
                                        (this._s1 = l[e - 1]), (this._si = e);
                                    } else if (b < this._s1 && e > 0) {
                                        for (; e > 0 && (this._s1 = l[--e]) >= b;);
                                        0 === e && b < this._s1 ? (this._s1 = 0) : e++, (this._s2 = l[e]), (this._si = e);
                                    }
                                    h = (e + (b - this._s1) / (this._s2 - this._s1)) * this._prec || 0;
                                } else (c = 0 > b ? 0 : b >= 1 ? m - 1 : (m * b) >> 0), (h = (b - c * (1 / m)) * m);
                                for (d = 1 - h, e = this._props.length; --e > -1;)
                                    (f = this._props[e]), (g = this._beziers[f][c]), (i = (h * h * g.da + 3 * d * (h * g.ca + d * g.ba)) * h + g.a), this._mod[f] && (i = this._mod[f](i, o)), n[f] ? o[f](i) : (o[f] = i);
                                if (this._autoRotate) {
                                    var q,
                                        r,
                                        s,
                                        t,
                                        u,
                                        v,
                                        w,
                                        x = this._autoRotate;
                                    for (e = x.length; --e > -1;)
                                        (f = x[e][2]),
                                            (v = x[e][3] || 0),
                                            (w = x[e][4] === !0 ? 1 : a),
                                            (g = this._beziers[x[e][0]]),
                                            (q = this._beziers[x[e][1]]),
                                            g &&
                                            q &&
                                            ((g = g[c]),
                                                (q = q[c]),
                                                (r = g.a + (g.b - g.a) * h),
                                                (t = g.b + (g.c - g.b) * h),
                                                (r += (t - r) * h),
                                                (t += (g.c + (g.d - g.c) * h - t) * h),
                                                (s = q.a + (q.b - q.a) * h),
                                                (u = q.b + (q.c - q.b) * h),
                                                (s += (u - s) * h),
                                                (u += (q.c + (q.d - q.c) * h - u) * h),
                                                (i = p ? Math.atan2(u - s, t - r) * w + v : this._initialRotations[e]),
                                                this._mod[f] && (i = this._mod[f](i, o)),
                                                n[f] ? o[f](i) : (o[f] = i));
                                }
                            },
                        }),
                        q = p.prototype;
                    (p.bezierThrough = l),
                        (p.cubicToQuadratic = i),
                        (p._autoCSS = !0),
                        (p.quadraticToCubic = function (a, b, c) {
                            return new g(a, (2 * b + a) / 3, (2 * b + c) / 3, c);
                        }),
                        (p._cssRegister = function () {
                            var a = f.CSSPlugin;
                            if (a) {
                                var b = a._internals,
                                    c = b._parseToProxy,
                                    d = b._setPluginRatio,
                                    e = b.CSSPropTween;
                                b._registerComplexSpecialProp("bezier", {
                                    parser: function (a, b, f, g, h, i) {
                                        b instanceof Array && (b = { values: b }), (i = new p());
                                        var j,
                                            k,
                                            l,
                                            m = b.values,
                                            n = m.length - 1,
                                            o = [],
                                            q = {};
                                        if (0 > n) return h;
                                        for (j = 0; n >= j; j++) (l = c(a, m[j], g, h, i, n !== j)), (o[j] = l.end);
                                        for (k in b) q[k] = b[k];
                                        return (
                                            (q.values = o),
                                            (h = new e(a, "bezier", 0, 0, l.pt, 2)),
                                            (h.data = l),
                                            (h.plugin = i),
                                            (h.setRatio = d),
                                            0 === q.autoRotate && (q.autoRotate = !0),
                                            !q.autoRotate ||
                                            q.autoRotate instanceof Array ||
                                            ((j = q.autoRotate === !0 ? 0 : Number(q.autoRotate)), (q.autoRotate = null != l.end.left ? [["left", "top", "rotation", j, !1]] : null != l.end.x ? [["x", "y", "rotation", j, !1]] : !1)),
                                            q.autoRotate && (g._transform || g._enableTransforms(!1), (l.autoRotate = g._target._gsTransform), (l.proxy.rotation = l.autoRotate.rotation || 0), g._overwriteProps.push("rotation")),
                                            i._onInitTween(l.proxy, q, g._tween),
                                            h
                                        );
                                    },
                                });
                            }
                        }),
                        (q._mod = function (a) {
                            for (var b, c = this._overwriteProps, d = c.length; --d > -1;) (b = a[c[d]]), b && "function" == typeof b && (this._mod[c[d]] = b);
                        }),
                        (q._kill = function (a) {
                            var b,
                                c,
                                d = this._props;
                            for (b in this._beziers) if (b in a) for (delete this._beziers[b], delete this._func[b], c = d.length; --c > -1;) d[c] === b && d.splice(c, 1);
                            if ((d = this._autoRotate)) for (c = d.length; --c > -1;) a[d[c][2]] && d.splice(c, 1);
                            return this._super._kill.call(this, a);
                        });
                })(),
                _gsScope._gsDefine(
                    "plugins.CSSPlugin",
                    ["plugins.TweenPlugin", "TweenLite"],
                    function (a, b) {
                        var c,
                            d,
                            e,
                            f,
                            g = function () {
                                a.call(this, "css"), (this._overwriteProps.length = 0), (this.setRatio = g.prototype.setRatio);
                            },
                            h = _gsScope._gsDefine.globals,
                            i = {},
                            j = (g.prototype = new a("css"));
                        (j.constructor = g),
                            (g.version = "1.19.1"),
                            (g.API = 2),
                            (g.defaultTransformPerspective = 0),
                            (g.defaultSkewType = "compensated"),
                            (g.defaultSmoothOrigin = !0),
                            (j = "px"),
                            (g.suffixMap = { top: j, right: j, bottom: j, left: j, width: j, height: j, fontSize: j, padding: j, margin: j, perspective: j, lineHeight: "" });
                        var k,
                            l,
                            m,
                            n,
                            o,
                            p,
                            q,
                            r,
                            s = /(?:\-|\.|\b)(\d|\.|e\-)+/g,
                            t = /(?:\d|\-\d|\.\d|\-\.\d|\+=\d|\-=\d|\+=.\d|\-=\.\d)+/g,
                            u = /(?:\+=|\-=|\-|\b)[\d\-\.]+[a-zA-Z0-9]*(?:%|\b)/gi,
                            v = /(?![+-]?\d*\.?\d+|[+-]|e[+-]\d+)[^0-9]/g,
                            w = /(?:\d|\-|\+|=|#|\.)*/g,
                            x = /opacity *= *([^)]*)/i,
                            y = /opacity:([^;]*)/i,
                            z = /alpha\(opacity *=.+?\)/i,
                            A = /^(rgb|hsl)/,
                            B = /([A-Z])/g,
                            C = /-([a-z])/gi,
                            D = /(^(?:url\(\"|url\())|(?:(\"\))$|\)$)/gi,
                            E = function (a, b) {
                                return b.toUpperCase();
                            },
                            F = /(?:Left|Right|Width)/i,
                            G = /(M11|M12|M21|M22)=[\d\-\.e]+/gi,
                            H = /progid\:DXImageTransform\.Microsoft\.Matrix\(.+?\)/i,
                            I = /,(?=[^\)]*(?:\(|$))/gi,
                            J = /[\s,\(]/i,
                            K = Math.PI / 180,
                            L = 180 / Math.PI,
                            M = {},
                            N = { style: {} },
                            O = _gsScope.document || {
                                createElement: function () {
                                    return N;
                                },
                            },
                            P = function (a, b) {
                                return O.createElementNS ? O.createElementNS(b || "http://www.w3.org/1999/xhtml", a) : O.createElement(a);
                            },
                            Q = P("div"),
                            R = P("img"),
                            S = (g._internals = { _specialProps: i }),
                            T = (_gsScope.navigator || {}).userAgent || "",
                            U = (function () {
                                var a = T.indexOf("Android"),
                                    b = P("a");
                                return (
                                    (m = -1 !== T.indexOf("Safari") && -1 === T.indexOf("Chrome") && (-1 === a || parseFloat(T.substr(a + 8, 2)) > 3)),
                                    (o = m && parseFloat(T.substr(T.indexOf("Version/") + 8, 2)) < 6),
                                    (n = -1 !== T.indexOf("Firefox")),
                                    (/MSIE ([0-9]{1,}[\.0-9]{0,})/.exec(T) || /Trident\/.*rv:([0-9]{1,}[\.0-9]{0,})/.exec(T)) && (p = parseFloat(RegExp.$1)),
                                    b ? ((b.style.cssText = "top:1px;opacity:.55;"), /^0.55/.test(b.style.opacity)) : !1
                                );
                            })(),
                            V = function (a) {
                                return x.test("string" == typeof a ? a : (a.currentStyle ? a.currentStyle.filter : a.style.filter) || "") ? parseFloat(RegExp.$1) / 100 : 1;
                            },
                            W = function (a) {
                                _gsScope.console && console.log(a);
                            },
                            X = "",
                            Y = "",
                            Z = function (a, b) {
                                b = b || Q;
                                var c,
                                    d,
                                    e = b.style;
                                if (void 0 !== e[a]) return a;
                                for (a = a.charAt(0).toUpperCase() + a.substr(1), c = ["O", "Moz", "ms", "Ms", "Webkit"], d = 5; --d > -1 && void 0 === e[c[d] + a];);
                                return d >= 0 ? ((Y = 3 === d ? "ms" : c[d]), (X = "-" + Y.toLowerCase() + "-"), Y + a) : null;
                            },
                            $ = O.defaultView ? O.defaultView.getComputedStyle : function () { },
                            _ = (g.getStyle = function (a, b, c, d, e) {
                                var f;
                                return U || "opacity" !== b
                                    ? (!d && a.style[b] ? (f = a.style[b]) : (c = c || $(a)) ? (f = c[b] || c.getPropertyValue(b) || c.getPropertyValue(b.replace(B, "-$1").toLowerCase())) : a.currentStyle && (f = a.currentStyle[b]),
                                        null == e || (f && "none" !== f && "auto" !== f && "auto auto" !== f) ? f : e)
                                    : V(a);
                            }),
                            aa = (S.convertToPixels = function (a, c, d, e, f) {
                                if ("px" === e || !e) return d;
                                if ("auto" === e || !d) return 0;
                                var h,
                                    i,
                                    j,
                                    k = F.test(c),
                                    l = a,
                                    m = Q.style,
                                    n = 0 > d,
                                    o = 1 === d;
                                if ((n && (d = -d), o && (d *= 100), "%" === e && -1 !== c.indexOf("border"))) h = (d / 100) * (k ? a.clientWidth : a.clientHeight);
                                else {
                                    if (((m.cssText = "border:0 solid red;position:" + _(a, "position") + ";line-height:0;"), "%" !== e && l.appendChild && "v" !== e.charAt(0) && "rem" !== e))
                                        m[k ? "borderLeftWidth" : "borderTopWidth"] = d + e;
                                    else {
                                        if (((l = a.parentNode || O.body), (i = l._gsCache), (j = b.ticker.frame), i && k && i.time === j)) return (i.width * d) / 100;
                                        m[k ? "width" : "height"] = d + e;
                                    }
                                    l.appendChild(Q),
                                        (h = parseFloat(Q[k ? "offsetWidth" : "offsetHeight"])),
                                        l.removeChild(Q),
                                        k && "%" === e && g.cacheWidths !== !1 && ((i = l._gsCache = l._gsCache || {}), (i.time = j), (i.width = (h / d) * 100)),
                                        0 !== h || f || (h = aa(a, c, d, e, !0));
                                }
                                return o && (h /= 100), n ? -h : h;
                            }),
                            ba = (S.calculateOffset = function (a, b, c) {
                                if ("absolute" !== _(a, "position", c)) return 0;
                                var d = "left" === b ? "Left" : "Top",
                                    e = _(a, "margin" + d, c);
                                return a["offset" + d] - (aa(a, b, parseFloat(e), e.replace(w, "")) || 0);
                            }),
                            ca = function (a, b) {
                                var c,
                                    d,
                                    e,
                                    f = {};
                                if ((b = b || $(a, null)))
                                    if ((c = b.length)) for (; --c > -1;) (e = b[c]), (-1 === e.indexOf("-transform") || Da === e) && (f[e.replace(C, E)] = b.getPropertyValue(e));
                                    else for (c in b) (-1 === c.indexOf("Transform") || Ca === c) && (f[c] = b[c]);
                                else if ((b = a.currentStyle || a.style)) for (c in b) "string" == typeof c && void 0 === f[c] && (f[c.replace(C, E)] = b[c]);
                                return (
                                    U || (f.opacity = V(a)),
                                    (d = Ra(a, b, !1)),
                                    (f.rotation = d.rotation),
                                    (f.skewX = d.skewX),
                                    (f.scaleX = d.scaleX),
                                    (f.scaleY = d.scaleY),
                                    (f.x = d.x),
                                    (f.y = d.y),
                                    Fa && ((f.z = d.z), (f.rotationX = d.rotationX), (f.rotationY = d.rotationY), (f.scaleZ = d.scaleZ)),
                                    f.filters && delete f.filters,
                                    f
                                );
                            },
                            da = function (a, b, c, d, e) {
                                var f,
                                    g,
                                    h,
                                    i = {},
                                    j = a.style;
                                for (g in c)
                                    "cssText" !== g &&
                                        "length" !== g &&
                                        isNaN(g) &&
                                        (b[g] !== (f = c[g]) || (e && e[g])) &&
                                        -1 === g.indexOf("Origin") &&
                                        ("number" == typeof f || "string" == typeof f) &&
                                        ((i[g] = "auto" !== f || ("left" !== g && "top" !== g) ? (("" !== f && "auto" !== f && "none" !== f) || "string" != typeof b[g] || "" === b[g].replace(v, "") ? f : 0) : ba(a, g)),
                                            void 0 !== j[g] && (h = new sa(j, g, j[g], h)));
                                if (d) for (g in d) "className" !== g && (i[g] = d[g]);
                                return { difs: i, firstMPT: h };
                            },
                            ea = { width: ["Left", "Right"], height: ["Top", "Bottom"] },
                            fa = ["marginLeft", "marginRight", "marginTop", "marginBottom"],
                            ga = function (a, b, c) {
                                if ("svg" === (a.nodeName + "").toLowerCase()) return (c || $(a))[b] || 0;
                                if (a.getCTM && Oa(a)) return a.getBBox()[b] || 0;
                                var d = parseFloat("width" === b ? a.offsetWidth : a.offsetHeight),
                                    e = ea[b],
                                    f = e.length;
                                for (c = c || $(a, null); --f > -1;) (d -= parseFloat(_(a, "padding" + e[f], c, !0)) || 0), (d -= parseFloat(_(a, "border" + e[f] + "Width", c, !0)) || 0);
                                return d;
                            },
                            ha = function (a, b) {
                                if ("contain" === a || "auto" === a || "auto auto" === a) return a + " ";
                                (null == a || "" === a) && (a = "0 0");
                                var c,
                                    d = a.split(" "),
                                    e = -1 !== a.indexOf("left") ? "0%" : -1 !== a.indexOf("right") ? "100%" : d[0],
                                    f = -1 !== a.indexOf("top") ? "0%" : -1 !== a.indexOf("bottom") ? "100%" : d[1];
                                if (d.length > 3 && !b) {
                                    for (d = a.split(", ").join(",").split(","), a = [], c = 0; c < d.length; c++) a.push(ha(d[c]));
                                    return a.join(",");
                                }
                                return (
                                    null == f ? (f = "center" === e ? "50%" : "0") : "center" === f && (f = "50%"),
                                    ("center" === e || (isNaN(parseFloat(e)) && -1 === (e + "").indexOf("="))) && (e = "50%"),
                                    (a = e + " " + f + (d.length > 2 ? " " + d[2] : "")),
                                    b &&
                                    ((b.oxp = -1 !== e.indexOf("%")),
                                        (b.oyp = -1 !== f.indexOf("%")),
                                        (b.oxr = "=" === e.charAt(1)),
                                        (b.oyr = "=" === f.charAt(1)),
                                        (b.ox = parseFloat(e.replace(v, ""))),
                                        (b.oy = parseFloat(f.replace(v, ""))),
                                        (b.v = a)),
                                    b || a
                                );
                            },
                            ia = function (a, b) {
                                return "function" == typeof a && (a = a(r, q)), "string" == typeof a && "=" === a.charAt(1) ? parseInt(a.charAt(0) + "1", 10) * parseFloat(a.substr(2)) : parseFloat(a) - parseFloat(b) || 0;
                            },
                            ja = function (a, b) {
                                return "function" == typeof a && (a = a(r, q)), null == a ? b : "string" == typeof a && "=" === a.charAt(1) ? parseInt(a.charAt(0) + "1", 10) * parseFloat(a.substr(2)) + b : parseFloat(a) || 0;
                            },
                            ka = function (a, b, c, d) {
                                var e,
                                    f,
                                    g,
                                    h,
                                    i,
                                    j = 1e-6;
                                return (
                                    "function" == typeof a && (a = a(r, q)),
                                    null == a
                                        ? (h = b)
                                        : "number" == typeof a
                                            ? (h = a)
                                            : ((e = 360),
                                                (f = a.split("_")),
                                                (i = "=" === a.charAt(1)),
                                                (g = (i ? parseInt(a.charAt(0) + "1", 10) * parseFloat(f[0].substr(2)) : parseFloat(f[0])) * (-1 === a.indexOf("rad") ? 1 : L) - (i ? 0 : b)),
                                                f.length &&
                                                (d && (d[c] = b + g),
                                                    -1 !== a.indexOf("short") && ((g %= e), g !== g % (e / 2) && (g = 0 > g ? g + e : g - e)),
                                                    -1 !== a.indexOf("_cw") && 0 > g ? (g = ((g + 9999999999 * e) % e) - ((g / e) | 0) * e) : -1 !== a.indexOf("ccw") && g > 0 && (g = ((g - 9999999999 * e) % e) - ((g / e) | 0) * e)),
                                                (h = b + g)),
                                    j > h && h > -j && (h = 0),
                                    h
                                );
                            },
                            la = {
                                aqua: [0, 255, 255],
                                lime: [0, 255, 0],
                                silver: [192, 192, 192],
                                black: [0, 0, 0],
                                maroon: [128, 0, 0],
                                teal: [0, 128, 128],
                                blue: [0, 0, 255],
                                navy: [0, 0, 128],
                                white: [255, 255, 255],
                                fuchsia: [255, 0, 255],
                                olive: [128, 128, 0],
                                yellow: [255, 255, 0],
                                orange: [255, 165, 0],
                                gray: [128, 128, 128],
                                purple: [128, 0, 128],
                                green: [0, 128, 0],
                                red: [255, 0, 0],
                                pink: [255, 192, 203],
                                cyan: [0, 255, 255],
                                transparent: [255, 255, 255, 0],
                            },
                            ma = function (a, b, c) {
                                return (a = 0 > a ? a + 1 : a > 1 ? a - 1 : a), (255 * (1 > 6 * a ? b + (c - b) * a * 6 : 0.5 > a ? c : 2 > 3 * a ? b + (c - b) * (2 / 3 - a) * 6 : b) + 0.5) | 0;
                            },
                            na = (g.parseColor = function (a, b) {
                                var c, d, e, f, g, h, i, j, k, l, m;
                                if (a)
                                    if ("number" == typeof a) c = [a >> 16, (a >> 8) & 255, 255 & a];
                                    else {
                                        if (("," === a.charAt(a.length - 1) && (a = a.substr(0, a.length - 1)), la[a])) c = la[a];
                                        else if ("#" === a.charAt(0))
                                            4 === a.length && ((d = a.charAt(1)), (e = a.charAt(2)), (f = a.charAt(3)), (a = "#" + d + d + e + e + f + f)), (a = parseInt(a.substr(1), 16)), (c = [a >> 16, (a >> 8) & 255, 255 & a]);
                                        else if ("hsl" === a.substr(0, 3))
                                            if (((c = m = a.match(s)), b)) {
                                                if (-1 !== a.indexOf("=")) return a.match(t);
                                            } else
                                                (g = (Number(c[0]) % 360) / 360),
                                                    (h = Number(c[1]) / 100),
                                                    (i = Number(c[2]) / 100),
                                                    (e = 0.5 >= i ? i * (h + 1) : i + h - i * h),
                                                    (d = 2 * i - e),
                                                    c.length > 3 && (c[3] = Number(a[3])),
                                                    (c[0] = ma(g + 1 / 3, d, e)),
                                                    (c[1] = ma(g, d, e)),
                                                    (c[2] = ma(g - 1 / 3, d, e));
                                        else c = a.match(s) || la.transparent;
                                        (c[0] = Number(c[0])), (c[1] = Number(c[1])), (c[2] = Number(c[2])), c.length > 3 && (c[3] = Number(c[3]));
                                    }
                                else c = la.black;
                                return (
                                    b &&
                                    !m &&
                                    ((d = c[0] / 255),
                                        (e = c[1] / 255),
                                        (f = c[2] / 255),
                                        (j = Math.max(d, e, f)),
                                        (k = Math.min(d, e, f)),
                                        (i = (j + k) / 2),
                                        j === k ? (g = h = 0) : ((l = j - k), (h = i > 0.5 ? l / (2 - j - k) : l / (j + k)), (g = j === d ? (e - f) / l + (f > e ? 6 : 0) : j === e ? (f - d) / l + 2 : (d - e) / l + 4), (g *= 60)),
                                        (c[0] = (g + 0.5) | 0),
                                        (c[1] = (100 * h + 0.5) | 0),
                                        (c[2] = (100 * i + 0.5) | 0)),
                                    c
                                );
                            }),
                            oa = function (a, b) {
                                var c,
                                    d,
                                    e,
                                    f = a.match(pa) || [],
                                    g = 0,
                                    h = f.length ? "" : a;
                                for (c = 0; c < f.length; c++)
                                    (d = f[c]),
                                        (e = a.substr(g, a.indexOf(d, g) - g)),
                                        (g += e.length + d.length),
                                        (d = na(d, b)),
                                        3 === d.length && d.push(1),
                                        (h += e + (b ? "hsla(" + d[0] + "," + d[1] + "%," + d[2] + "%," + d[3] : "rgba(" + d.join(",")) + ")");
                                return h + a.substr(g);
                            },
                            pa = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3}){1,2}\\b";
                        for (j in la) pa += "|" + j + "\\b";
                        (pa = new RegExp(pa + ")", "gi")),
                            (g.colorStringFilter = function (a) {
                                var b,
                                    c = a[0] + a[1];
                                pa.test(c) && ((b = -1 !== c.indexOf("hsl(") || -1 !== c.indexOf("hsla(")), (a[0] = oa(a[0], b)), (a[1] = oa(a[1], b))), (pa.lastIndex = 0);
                            }),
                            b.defaultStringFilter || (b.defaultStringFilter = g.colorStringFilter);
                        var qa = function (a, b, c, d) {
                            if (null == a)
                                return function (a) {
                                    return a;
                                };
                            var e,
                                f = b ? (a.match(pa) || [""])[0] : "",
                                g = a.split(f).join("").match(u) || [],
                                h = a.substr(0, a.indexOf(g[0])),
                                i = ")" === a.charAt(a.length - 1) ? ")" : "",
                                j = -1 !== a.indexOf(" ") ? " " : ",",
                                k = g.length,
                                l = k > 0 ? g[0].replace(s, "") : "";
                            return k
                                ? (e = b
                                    ? function (a) {
                                        var b, m, n, o;
                                        if ("number" == typeof a) a += l;
                                        else if (d && I.test(a)) {
                                            for (o = a.replace(I, "|").split("|"), n = 0; n < o.length; n++) o[n] = e(o[n]);
                                            return o.join(",");
                                        }
                                        if (((b = (a.match(pa) || [f])[0]), (m = a.split(b).join("").match(u) || []), (n = m.length), k > n--)) for (; ++n < k;) m[n] = c ? m[((n - 1) / 2) | 0] : g[n];
                                        return h + m.join(j) + j + b + i + (-1 !== a.indexOf("inset") ? " inset" : "");
                                    }
                                    : function (a) {
                                        var b, f, m;
                                        if ("number" == typeof a) a += l;
                                        else if (d && I.test(a)) {
                                            for (f = a.replace(I, "|").split("|"), m = 0; m < f.length; m++) f[m] = e(f[m]);
                                            return f.join(",");
                                        }
                                        if (((b = a.match(u) || []), (m = b.length), k > m--)) for (; ++m < k;) b[m] = c ? b[((m - 1) / 2) | 0] : g[m];
                                        return h + b.join(j) + i;
                                    })
                                : function (a) {
                                    return a;
                                };
                        },
                            ra = function (a) {
                                return (
                                    (a = a.split(",")),
                                    function (b, c, d, e, f, g, h) {
                                        var i,
                                            j = (c + "").split(" ");
                                        for (h = {}, i = 0; 4 > i; i++) h[a[i]] = j[i] = j[i] || j[((i - 1) / 2) >> 0];
                                        return e.parse(b, h, f, g);
                                    }
                                );
                            },
                            sa =
                                ((S._setPluginRatio = function (a) {
                                    this.plugin.setRatio(a);
                                    for (var b, c, d, e, f, g = this.data, h = g.proxy, i = g.firstMPT, j = 1e-6; i;) (b = h[i.v]), i.r ? (b = Math.round(b)) : j > b && b > -j && (b = 0), (i.t[i.p] = b), (i = i._next);
                                    if ((g.autoRotate && (g.autoRotate.rotation = g.mod ? g.mod(h.rotation, this.t) : h.rotation), 1 === a || 0 === a))
                                        for (i = g.firstMPT, f = 1 === a ? "e" : "b"; i;) {
                                            if (((c = i.t), c.type)) {
                                                if (1 === c.type) {
                                                    for (e = c.xs0 + c.s + c.xs1, d = 1; d < c.l; d++) e += c["xn" + d] + c["xs" + (d + 1)];
                                                    c[f] = e;
                                                }
                                            } else c[f] = c.s + c.xs0;
                                            i = i._next;
                                        }
                                }),
                                    function (a, b, c, d, e) {
                                        (this.t = a), (this.p = b), (this.v = c), (this.r = e), d && ((d._prev = this), (this._next = d));
                                    }),
                            ta =
                                ((S._parseToProxy = function (a, b, c, d, e, f) {
                                    var g,
                                        h,
                                        i,
                                        j,
                                        k,
                                        l = d,
                                        m = {},
                                        n = {},
                                        o = c._transform,
                                        p = M;
                                    for (c._transform = null, M = b, d = k = c.parse(a, b, d, e), M = p, f && ((c._transform = o), l && ((l._prev = null), l._prev && (l._prev._next = null))); d && d !== l;) {
                                        if (d.type <= 1 && ((h = d.p), (n[h] = d.s + d.c), (m[h] = d.s), f || ((j = new sa(d, "s", h, j, d.r)), (d.c = 0)), 1 === d.type))
                                            for (g = d.l; --g > 0;) (i = "xn" + g), (h = d.p + "_" + i), (n[h] = d.data[i]), (m[h] = d[i]), f || (j = new sa(d, i, h, j, d.rxp[i]));
                                        d = d._next;
                                    }
                                    return { proxy: m, end: n, firstMPT: j, pt: k };
                                }),
                                    (S.CSSPropTween = function (a, b, d, e, g, h, i, j, k, l, m) {
                                        (this.t = a),
                                            (this.p = b),
                                            (this.s = d),
                                            (this.c = e),
                                            (this.n = i || b),
                                            a instanceof ta || f.push(this.n),
                                            (this.r = j),
                                            (this.type = h || 0),
                                            k && ((this.pr = k), (c = !0)),
                                            (this.b = void 0 === l ? d : l),
                                            (this.e = void 0 === m ? d + e : m),
                                            g && ((this._next = g), (g._prev = this));
                                    })),
                            ua = function (a, b, c, d, e, f) {
                                var g = new ta(a, b, c, d - c, e, -1, f);
                                return (g.b = c), (g.e = g.xs0 = d), g;
                            },
                            va = (g.parseComplex = function (a, b, c, d, e, f, h, i, j, l) {
                                (c = c || f || ""),
                                    "function" == typeof d && (d = d(r, q)),
                                    (h = new ta(a, b, 0, 0, h, l ? 2 : 1, null, !1, i, c, d)),
                                    (d += ""),
                                    e && pa.test(d + c) && ((d = [c, d]), g.colorStringFilter(d), (c = d[0]), (d = d[1]));
                                var m,
                                    n,
                                    o,
                                    p,
                                    u,
                                    v,
                                    w,
                                    x,
                                    y,
                                    z,
                                    A,
                                    B,
                                    C,
                                    D = c.split(", ").join(",").split(" "),
                                    E = d.split(", ").join(",").split(" "),
                                    F = D.length,
                                    G = k !== !1;
                                for (
                                    (-1 !== d.indexOf(",") || -1 !== c.indexOf(",")) && ((D = D.join(" ").replace(I, ", ").split(" ")), (E = E.join(" ").replace(I, ", ").split(" ")), (F = D.length)),
                                    F !== E.length && ((D = (f || "").split(" ")), (F = D.length)),
                                    h.plugin = j,
                                    h.setRatio = l,
                                    pa.lastIndex = 0,
                                    m = 0;
                                    F > m;
                                    m++
                                )
                                    if (((p = D[m]), (u = E[m]), (x = parseFloat(p)), x || 0 === x)) h.appendXtra("", x, ia(u, x), u.replace(t, ""), G && -1 !== u.indexOf("px"), !0);
                                    else if (e && pa.test(p))
                                        (B = u.indexOf(")") + 1),
                                            (B = ")" + (B ? u.substr(B) : "")),
                                            (C = -1 !== u.indexOf("hsl") && U),
                                            (p = na(p, C)),
                                            (u = na(u, C)),
                                            (y = p.length + u.length > 6),
                                            y && !U && 0 === u[3]
                                                ? ((h["xs" + h.l] += h.l ? " transparent" : "transparent"), (h.e = h.e.split(E[m]).join("transparent")))
                                                : (U || (y = !1),
                                                    C
                                                        ? h
                                                            .appendXtra(y ? "hsla(" : "hsl(", p[0], ia(u[0], p[0]), ",", !1, !0)
                                                            .appendXtra("", p[1], ia(u[1], p[1]), "%,", !1)
                                                            .appendXtra("", p[2], ia(u[2], p[2]), y ? "%," : "%" + B, !1)
                                                        : h
                                                            .appendXtra(y ? "rgba(" : "rgb(", p[0], u[0] - p[0], ",", !0, !0)
                                                            .appendXtra("", p[1], u[1] - p[1], ",", !0)
                                                            .appendXtra("", p[2], u[2] - p[2], y ? "," : B, !0),
                                                    y && ((p = p.length < 4 ? 1 : p[3]), h.appendXtra("", p, (u.length < 4 ? 1 : u[3]) - p, B, !1))),
                                            (pa.lastIndex = 0);
                                    else if ((v = p.match(s))) {
                                        if (((w = u.match(t)), !w || w.length !== v.length)) return h;
                                        for (o = 0, n = 0; n < v.length; n++)
                                            (A = v[n]), (z = p.indexOf(A, o)), h.appendXtra(p.substr(o, z - o), Number(A), ia(w[n], A), "", G && "px" === p.substr(z + A.length, 2), 0 === n), (o = z + A.length);
                                        h["xs" + h.l] += p.substr(o);
                                    } else h["xs" + h.l] += h.l || h["xs" + h.l] ? " " + u : u;
                                if (-1 !== d.indexOf("=") && h.data) {
                                    for (B = h.xs0 + h.data.s, m = 1; m < h.l; m++) B += h["xs" + m] + h.data["xn" + m];
                                    h.e = B + h["xs" + m];
                                }
                                return h.l || ((h.type = -1), (h.xs0 = h.e)), h.xfirst || h;
                            }),
                            wa = 9;
                        for (j = ta.prototype, j.l = j.pr = 0; --wa > 0;) (j["xn" + wa] = 0), (j["xs" + wa] = "");
                        (j.xs0 = ""),
                            (j._next = j._prev = j.xfirst = j.data = j.plugin = j.setRatio = j.rxp = null),
                            (j.appendXtra = function (a, b, c, d, e, f) {
                                var g = this,
                                    h = g.l;
                                return (
                                    (g["xs" + h] += f && (h || g["xs" + h]) ? " " + a : a || ""),
                                    c || 0 === h || g.plugin
                                        ? (g.l++,
                                            (g.type = g.setRatio ? 2 : 1),
                                            (g["xs" + g.l] = d || ""),
                                            h > 0
                                                ? ((g.data["xn" + h] = b + c), (g.rxp["xn" + h] = e), (g["xn" + h] = b), g.plugin || ((g.xfirst = new ta(g, "xn" + h, b, c, g.xfirst || g, 0, g.n, e, g.pr)), (g.xfirst.xs0 = 0)), g)
                                                : ((g.data = { s: b + c }), (g.rxp = {}), (g.s = b), (g.c = c), (g.r = e), g))
                                        : ((g["xs" + h] += b + (d || "")), g)
                                );
                            });
                        var xa = function (a, b) {
                            (b = b || {}),
                                (this.p = b.prefix ? Z(a) || a : a),
                                (i[a] = i[this.p] = this),
                                (this.format = b.formatter || qa(b.defaultValue, b.color, b.collapsible, b.multi)),
                                b.parser && (this.parse = b.parser),
                                (this.clrs = b.color),
                                (this.multi = b.multi),
                                (this.keyword = b.keyword),
                                (this.dflt = b.defaultValue),
                                (this.pr = b.priority || 0);
                        },
                            ya = (S._registerComplexSpecialProp = function (a, b, c) {
                                "object" != typeof b && (b = { parser: c });
                                var d,
                                    e,
                                    f = a.split(","),
                                    g = b.defaultValue;
                                for (c = c || [g], d = 0; d < f.length; d++) (b.prefix = 0 === d && b.prefix), (b.defaultValue = c[d] || g), (e = new xa(f[d], b));
                            }),
                            za = (S._registerPluginProp = function (a) {
                                if (!i[a]) {
                                    var b = a.charAt(0).toUpperCase() + a.substr(1) + "Plugin";
                                    ya(a, {
                                        parser: function (a, c, d, e, f, g, j) {
                                            var k = h.com.greensock.plugins[b];
                                            return k ? (k._cssRegister(), i[d].parse(a, c, d, e, f, g, j)) : (W("Error: " + b + " js file not loaded."), f);
                                        },
                                    });
                                }
                            });
                        (j = xa.prototype),
                            (j.parseComplex = function (a, b, c, d, e, f) {
                                var g,
                                    h,
                                    i,
                                    j,
                                    k,
                                    l,
                                    m = this.keyword;
                                if ((this.multi && (I.test(c) || I.test(b) ? ((h = b.replace(I, "|").split("|")), (i = c.replace(I, "|").split("|"))) : m && ((h = [b]), (i = [c]))), i)) {
                                    for (j = i.length > h.length ? i.length : h.length, g = 0; j > g; g++)
                                        (b = h[g] = h[g] || this.dflt), (c = i[g] = i[g] || this.dflt), m && ((k = b.indexOf(m)), (l = c.indexOf(m)), k !== l && (-1 === l ? (h[g] = h[g].split(m).join("")) : -1 === k && (h[g] += " " + m)));
                                    (b = h.join(", ")), (c = i.join(", "));
                                }
                                return va(a, this.p, b, c, this.clrs, this.dflt, d, this.pr, e, f);
                            }),
                            (j.parse = function (a, b, c, d, f, g, h) {
                                return this.parseComplex(a.style, this.format(_(a, this.p, e, !1, this.dflt)), this.format(b), f, g);
                            }),
                            (g.registerSpecialProp = function (a, b, c) {
                                ya(a, {
                                    parser: function (a, d, e, f, g, h, i) {
                                        var j = new ta(a, e, 0, 0, g, 2, e, !1, c);
                                        return (j.plugin = h), (j.setRatio = b(a, d, f._tween, e)), j;
                                    },
                                    priority: c,
                                });
                            }),
                            (g.useSVGTransformAttr = !0);
                        var Aa,
                            Ba = "scaleX,scaleY,scaleZ,x,y,z,skewX,skewY,rotation,rotationX,rotationY,perspective,xPercent,yPercent".split(","),
                            Ca = Z("transform"),
                            Da = X + "transform",
                            Ea = Z("transformOrigin"),
                            Fa = null !== Z("perspective"),
                            Ga = (S.Transform = function () {
                                (this.perspective = parseFloat(g.defaultTransformPerspective) || 0), (this.force3D = g.defaultForce3D !== !1 && Fa ? g.defaultForce3D || "auto" : !1);
                            }),
                            Ha = _gsScope.SVGElement,
                            Ia = function (a, b, c) {
                                var d,
                                    e = O.createElementNS("http://www.w3.org/2000/svg", a),
                                    f = /([a-z])([A-Z])/g;
                                for (d in c) e.setAttributeNS(null, d.replace(f, "$1-$2").toLowerCase(), c[d]);
                                return b.appendChild(e), e;
                            },
                            Ja = O.documentElement || {},
                            Ka = (function () {
                                var a,
                                    b,
                                    c,
                                    d = p || (/Android/i.test(T) && !_gsScope.chrome);
                                return (
                                    O.createElementNS &&
                                    !d &&
                                    ((a = Ia("svg", Ja)),
                                        (b = Ia("rect", a, { width: 100, height: 50, x: 100 })),
                                        (c = b.getBoundingClientRect().width),
                                        (b.style[Ea] = "50% 50%"),
                                        (b.style[Ca] = "scaleX(0.5)"),
                                        (d = c === b.getBoundingClientRect().width && !(n && Fa)),
                                        Ja.removeChild(a)),
                                    d
                                );
                            })(),
                            La = function (a, b, c, d, e, f) {
                                var h,
                                    i,
                                    j,
                                    k,
                                    l,
                                    m,
                                    n,
                                    o,
                                    p,
                                    q,
                                    r,
                                    s,
                                    t,
                                    u,
                                    v = a._gsTransform,
                                    w = Qa(a, !0);
                                v && ((t = v.xOrigin), (u = v.yOrigin)),
                                    (!d || (h = d.split(" ")).length < 2) &&
                                    ((n = a.getBBox()),
                                        0 === n.x &&
                                        0 === n.y &&
                                        n.width + n.height === 0 &&
                                        (n = {
                                            x: parseFloat(a.hasAttribute("x") ? a.getAttribute("x") : a.hasAttribute("cx") ? a.getAttribute("cx") : 0) || 0,
                                            y: parseFloat(a.hasAttribute("y") ? a.getAttribute("y") : a.hasAttribute("cy") ? a.getAttribute("cy") : 0) || 0,
                                            width: 0,
                                            height: 0,
                                        }),
                                        (b = ha(b).split(" ")),
                                        (h = [(-1 !== b[0].indexOf("%") ? (parseFloat(b[0]) / 100) * n.width : parseFloat(b[0])) + n.x, (-1 !== b[1].indexOf("%") ? (parseFloat(b[1]) / 100) * n.height : parseFloat(b[1])) + n.y])),
                                    (c.xOrigin = k = parseFloat(h[0])),
                                    (c.yOrigin = l = parseFloat(h[1])),
                                    d &&
                                    w !== Pa &&
                                    ((m = w[0]),
                                        (n = w[1]),
                                        (o = w[2]),
                                        (p = w[3]),
                                        (q = w[4]),
                                        (r = w[5]),
                                        (s = m * p - n * o),
                                        s && ((i = k * (p / s) + l * (-o / s) + (o * r - p * q) / s), (j = k * (-n / s) + l * (m / s) - (m * r - n * q) / s), (k = c.xOrigin = h[0] = i), (l = c.yOrigin = h[1] = j))),
                                    v &&
                                    (f && ((c.xOffset = v.xOffset), (c.yOffset = v.yOffset), (v = c)),
                                        e || (e !== !1 && g.defaultSmoothOrigin !== !1) ? ((i = k - t), (j = l - u), (v.xOffset += i * w[0] + j * w[2] - i), (v.yOffset += i * w[1] + j * w[3] - j)) : (v.xOffset = v.yOffset = 0)),
                                    f || a.setAttribute("data-svg-origin", h.join(" "));
                            },
                            Ma = function (a) {
                                var b,
                                    c = P("svg", this.ownerSVGElement.getAttribute("xmlns") || "http://www.w3.org/2000/svg"),
                                    d = this.parentNode,
                                    e = this.nextSibling,
                                    f = this.style.cssText;
                                if ((Ja.appendChild(c), c.appendChild(this), (this.style.display = "block"), a))
                                    try {
                                        (b = this.getBBox()), (this._originalGetBBox = this.getBBox), (this.getBBox = Ma);
                                    } catch (g) { }
                                else this._originalGetBBox && (b = this._originalGetBBox());
                                return e ? d.insertBefore(this, e) : d.appendChild(this), Ja.removeChild(c), (this.style.cssText = f), b;
                            },
                            Na = function (a) {
                                try {
                                    return a.getBBox();
                                } catch (b) {
                                    return Ma.call(a, !0);
                                }
                            },
                            Oa = function (a) {
                                return !(!(Ha && a.getCTM && Na(a)) || (a.parentNode && !a.ownerSVGElement));
                            },
                            Pa = [1, 0, 0, 1, 0, 0],
                            Qa = function (a, b) {
                                var c,
                                    d,
                                    e,
                                    f,
                                    g,
                                    h,
                                    i = a._gsTransform || new Ga(),
                                    j = 1e5,
                                    k = a.style;
                                if (
                                    (Ca
                                        ? (d = _(a, Da, null, !0))
                                        : a.currentStyle &&
                                        ((d = a.currentStyle.filter.match(G)), (d = d && 4 === d.length ? [d[0].substr(4), Number(d[2].substr(4)), Number(d[1].substr(4)), d[3].substr(4), i.x || 0, i.y || 0].join(",") : "")),
                                        (c = !d || "none" === d || "matrix(1, 0, 0, 1, 0, 0)" === d),
                                        c &&
                                        Ca &&
                                        ((h = "none" === $(a).display) || !a.parentNode) &&
                                        (h && ((f = k.display), (k.display = "block")),
                                            a.parentNode || ((g = 1), Ja.appendChild(a)),
                                            (d = _(a, Da, null, !0)),
                                            (c = !d || "none" === d || "matrix(1, 0, 0, 1, 0, 0)" === d),
                                            f ? (k.display = f) : h && Va(k, "display"),
                                            g && Ja.removeChild(a)),
                                        (i.svg || (a.getCTM && Oa(a))) &&
                                        (c && -1 !== (k[Ca] + "").indexOf("matrix") && ((d = k[Ca]), (c = 0)),
                                            (e = a.getAttribute("transform")),
                                            c && e && (-1 !== e.indexOf("matrix") ? ((d = e), (c = 0)) : -1 !== e.indexOf("translate") && ((d = "matrix(1,0,0,1," + e.match(/(?:\-|\b)[\d\-\.e]+\b/gi).join(",") + ")"), (c = 0)))),
                                        c)
                                )
                                    return Pa;
                                for (e = (d || "").match(s) || [], wa = e.length; --wa > -1;) (f = Number(e[wa])), (e[wa] = (g = f - (f |= 0)) ? ((g * j + (0 > g ? -0.5 : 0.5)) | 0) / j + f : f);
                                return b && e.length > 6 ? [e[0], e[1], e[4], e[5], e[12], e[13]] : e;
                            },
                            Ra = (S.getTransform = function (a, c, d, e) {
                                if (a._gsTransform && d && !e) return a._gsTransform;
                                var f,
                                    h,
                                    i,
                                    j,
                                    k,
                                    l,
                                    m = d ? a._gsTransform || new Ga() : new Ga(),
                                    n = m.scaleX < 0,
                                    o = 2e-5,
                                    p = 1e5,
                                    q = Fa ? parseFloat(_(a, Ea, c, !1, "0 0 0").split(" ")[2]) || m.zOrigin || 0 : 0,
                                    r = parseFloat(g.defaultTransformPerspective) || 0;
                                if (((m.svg = !(!a.getCTM || !Oa(a))), m.svg && (La(a, _(a, Ea, c, !1, "50% 50%") + "", m, a.getAttribute("data-svg-origin")), (Aa = g.useSVGTransformAttr || Ka)), (f = Qa(a)), f !== Pa)) {
                                    if (16 === f.length) {
                                        var s,
                                            t,
                                            u,
                                            v,
                                            w,
                                            x = f[0],
                                            y = f[1],
                                            z = f[2],
                                            A = f[3],
                                            B = f[4],
                                            C = f[5],
                                            D = f[6],
                                            E = f[7],
                                            F = f[8],
                                            G = f[9],
                                            H = f[10],
                                            I = f[12],
                                            J = f[13],
                                            K = f[14],
                                            M = f[11],
                                            N = Math.atan2(D, H);
                                        m.zOrigin && ((K = -m.zOrigin), (I = F * K - f[12]), (J = G * K - f[13]), (K = H * K + m.zOrigin - f[14])),
                                            (m.rotationX = N * L),
                                            N &&
                                            ((v = Math.cos(-N)),
                                                (w = Math.sin(-N)),
                                                (s = B * v + F * w),
                                                (t = C * v + G * w),
                                                (u = D * v + H * w),
                                                (F = B * -w + F * v),
                                                (G = C * -w + G * v),
                                                (H = D * -w + H * v),
                                                (M = E * -w + M * v),
                                                (B = s),
                                                (C = t),
                                                (D = u)),
                                            (N = Math.atan2(-z, H)),
                                            (m.rotationY = N * L),
                                            N &&
                                            ((v = Math.cos(-N)),
                                                (w = Math.sin(-N)),
                                                (s = x * v - F * w),
                                                (t = y * v - G * w),
                                                (u = z * v - H * w),
                                                (G = y * w + G * v),
                                                (H = z * w + H * v),
                                                (M = A * w + M * v),
                                                (x = s),
                                                (y = t),
                                                (z = u)),
                                            (N = Math.atan2(y, x)),
                                            (m.rotation = N * L),
                                            N && ((v = Math.cos(-N)), (w = Math.sin(-N)), (x = x * v + B * w), (t = y * v + C * w), (C = y * -w + C * v), (D = z * -w + D * v), (y = t)),
                                            m.rotationX && Math.abs(m.rotationX) + Math.abs(m.rotation) > 359.9 && ((m.rotationX = m.rotation = 0), (m.rotationY = 180 - m.rotationY)),
                                            (m.scaleX = ((Math.sqrt(x * x + y * y) * p + 0.5) | 0) / p),
                                            (m.scaleY = ((Math.sqrt(C * C + G * G) * p + 0.5) | 0) / p),
                                            (m.scaleZ = ((Math.sqrt(D * D + H * H) * p + 0.5) | 0) / p),
                                            m.rotationX || m.rotationY
                                                ? (m.skewX = 0)
                                                : ((m.skewX = B || C ? Math.atan2(B, C) * L + m.rotation : m.skewX || 0),
                                                    Math.abs(m.skewX) > 90 &&
                                                    Math.abs(m.skewX) < 270 &&
                                                    (n ? ((m.scaleX *= -1), (m.skewX += m.rotation <= 0 ? 180 : -180), (m.rotation += m.rotation <= 0 ? 180 : -180)) : ((m.scaleY *= -1), (m.skewX += m.skewX <= 0 ? 180 : -180)))),
                                            (m.perspective = M ? 1 / (0 > M ? -M : M) : 0),
                                            (m.x = I),
                                            (m.y = J),
                                            (m.z = K),
                                            m.svg && ((m.x -= m.xOrigin - (m.xOrigin * x - m.yOrigin * B)), (m.y -= m.yOrigin - (m.yOrigin * y - m.xOrigin * C)));
                                    } else if (!Fa || e || !f.length || m.x !== f[4] || m.y !== f[5] || (!m.rotationX && !m.rotationY)) {
                                        var O = f.length >= 6,
                                            P = O ? f[0] : 1,
                                            Q = f[1] || 0,
                                            R = f[2] || 0,
                                            S = O ? f[3] : 1;
                                        (m.x = f[4] || 0),
                                            (m.y = f[5] || 0),
                                            (i = Math.sqrt(P * P + Q * Q)),
                                            (j = Math.sqrt(S * S + R * R)),
                                            (k = P || Q ? Math.atan2(Q, P) * L : m.rotation || 0),
                                            (l = R || S ? Math.atan2(R, S) * L + k : m.skewX || 0),
                                            Math.abs(l) > 90 && Math.abs(l) < 270 && (n ? ((i *= -1), (l += 0 >= k ? 180 : -180), (k += 0 >= k ? 180 : -180)) : ((j *= -1), (l += 0 >= l ? 180 : -180))),
                                            (m.scaleX = i),
                                            (m.scaleY = j),
                                            (m.rotation = k),
                                            (m.skewX = l),
                                            Fa && ((m.rotationX = m.rotationY = m.z = 0), (m.perspective = r), (m.scaleZ = 1)),
                                            m.svg && ((m.x -= m.xOrigin - (m.xOrigin * P + m.yOrigin * R)), (m.y -= m.yOrigin - (m.xOrigin * Q + m.yOrigin * S)));
                                    }
                                    m.zOrigin = q;
                                    for (h in m) m[h] < o && m[h] > -o && (m[h] = 0);
                                }
                                return (
                                    d &&
                                    ((a._gsTransform = m),
                                        m.svg &&
                                        (Aa && a.style[Ca]
                                            ? b.delayedCall(0.001, function () {
                                                Va(a.style, Ca);
                                            })
                                            : !Aa &&
                                            a.getAttribute("transform") &&
                                            b.delayedCall(0.001, function () {
                                                a.removeAttribute("transform");
                                            }))),
                                    m
                                );
                            }),
                            Sa = function (a) {
                                var b,
                                    c,
                                    d = this.data,
                                    e = -d.rotation * K,
                                    f = e + d.skewX * K,
                                    g = 1e5,
                                    h = ((Math.cos(e) * d.scaleX * g) | 0) / g,
                                    i = ((Math.sin(e) * d.scaleX * g) | 0) / g,
                                    j = ((Math.sin(f) * -d.scaleY * g) | 0) / g,
                                    k = ((Math.cos(f) * d.scaleY * g) | 0) / g,
                                    l = this.t.style,
                                    m = this.t.currentStyle;
                                if (m) {
                                    (c = i), (i = -j), (j = -c), (b = m.filter), (l.filter = "");
                                    var n,
                                        o,
                                        q = this.t.offsetWidth,
                                        r = this.t.offsetHeight,
                                        s = "absolute" !== m.position,
                                        t = "progid:DXImageTransform.Microsoft.Matrix(M11=" + h + ", M12=" + i + ", M21=" + j + ", M22=" + k,
                                        u = d.x + (q * d.xPercent) / 100,
                                        v = d.y + (r * d.yPercent) / 100;
                                    if (
                                        (null != d.ox && ((n = (d.oxp ? q * d.ox * 0.01 : d.ox) - q / 2), (o = (d.oyp ? r * d.oy * 0.01 : d.oy) - r / 2), (u += n - (n * h + o * i)), (v += o - (n * j + o * k))),
                                            s ? ((n = q / 2), (o = r / 2), (t += ", Dx=" + (n - (n * h + o * i) + u) + ", Dy=" + (o - (n * j + o * k) + v) + ")")) : (t += ", sizingMethod='auto expand')"),
                                            -1 !== b.indexOf("DXImageTransform.Microsoft.Matrix(") ? (l.filter = b.replace(H, t)) : (l.filter = t + " " + b),
                                            (0 === a || 1 === a) &&
                                            1 === h &&
                                            0 === i &&
                                            0 === j &&
                                            1 === k &&
                                            ((s && -1 === t.indexOf("Dx=0, Dy=0")) || (x.test(b) && 100 !== parseFloat(RegExp.$1)) || (-1 === b.indexOf(b.indexOf("Alpha")) && l.removeAttribute("filter"))),
                                            !s)
                                    ) {
                                        var y,
                                            z,
                                            A,
                                            B = 8 > p ? 1 : -1;
                                        for (
                                            n = d.ieOffsetX || 0,
                                            o = d.ieOffsetY || 0,
                                            d.ieOffsetX = Math.round((q - ((0 > h ? -h : h) * q + (0 > i ? -i : i) * r)) / 2 + u),
                                            d.ieOffsetY = Math.round((r - ((0 > k ? -k : k) * r + (0 > j ? -j : j) * q)) / 2 + v),
                                            wa = 0;
                                            4 > wa;
                                            wa++
                                        )
                                            (z = fa[wa]),
                                                (y = m[z]),
                                                (c = -1 !== y.indexOf("px") ? parseFloat(y) : aa(this.t, z, parseFloat(y), y.replace(w, "")) || 0),
                                                (A = c !== d[z] ? (2 > wa ? -d.ieOffsetX : -d.ieOffsetY) : 2 > wa ? n - d.ieOffsetX : o - d.ieOffsetY),
                                                (l[z] = (d[z] = Math.round(c - A * (0 === wa || 2 === wa ? 1 : B))) + "px");
                                    }
                                }
                            },
                            Ta = (S.set3DTransformRatio = S.setTransformRatio = function (a) {
                                var b,
                                    c,
                                    d,
                                    e,
                                    f,
                                    g,
                                    h,
                                    i,
                                    j,
                                    k,
                                    l,
                                    m,
                                    o,
                                    p,
                                    q,
                                    r,
                                    s,
                                    t,
                                    u,
                                    v,
                                    w,
                                    x,
                                    y,
                                    z = this.data,
                                    A = this.t.style,
                                    B = z.rotation,
                                    C = z.rotationX,
                                    D = z.rotationY,
                                    E = z.scaleX,
                                    F = z.scaleY,
                                    G = z.scaleZ,
                                    H = z.x,
                                    I = z.y,
                                    J = z.z,
                                    L = z.svg,
                                    M = z.perspective,
                                    N = z.force3D,
                                    O = z.skewY,
                                    P = z.skewX;
                                if (
                                    (O && ((P += O), (B += O)),
                                        ((((1 === a || 0 === a) && "auto" === N && (this.tween._totalTime === this.tween._totalDuration || !this.tween._totalTime)) || !N) && !J && !M && !D && !C && 1 === G) || (Aa && L) || !Fa)
                                )
                                    return void (B || P || L
                                        ? ((B *= K),
                                            (x = P * K),
                                            (y = 1e5),
                                            (c = Math.cos(B) * E),
                                            (f = Math.sin(B) * E),
                                            (d = Math.sin(B - x) * -F),
                                            (g = Math.cos(B - x) * F),
                                            x && "simple" === z.skewType && ((b = Math.tan(x - O * K)), (b = Math.sqrt(1 + b * b)), (d *= b), (g *= b), O && ((b = Math.tan(O * K)), (b = Math.sqrt(1 + b * b)), (c *= b), (f *= b))),
                                            L &&
                                            ((H += z.xOrigin - (z.xOrigin * c + z.yOrigin * d) + z.xOffset),
                                                (I += z.yOrigin - (z.xOrigin * f + z.yOrigin * g) + z.yOffset),
                                                Aa && (z.xPercent || z.yPercent) && ((q = this.t.getBBox()), (H += 0.01 * z.xPercent * q.width), (I += 0.01 * z.yPercent * q.height)),
                                                (q = 1e-6),
                                                q > H && H > -q && (H = 0),
                                                q > I && I > -q && (I = 0)),
                                            (u = ((c * y) | 0) / y + "," + ((f * y) | 0) / y + "," + ((d * y) | 0) / y + "," + ((g * y) | 0) / y + "," + H + "," + I + ")"),
                                            L && Aa ? this.t.setAttribute("transform", "matrix(" + u) : (A[Ca] = (z.xPercent || z.yPercent ? "translate(" + z.xPercent + "%," + z.yPercent + "%) matrix(" : "matrix(") + u))
                                        : (A[Ca] = (z.xPercent || z.yPercent ? "translate(" + z.xPercent + "%," + z.yPercent + "%) matrix(" : "matrix(") + E + ",0,0," + F + "," + H + "," + I + ")"));
                                if ((n && ((q = 1e-4), q > E && E > -q && (E = G = 2e-5), q > F && F > -q && (F = G = 2e-5), !M || z.z || z.rotationX || z.rotationY || (M = 0)), B || P))
                                    (B *= K),
                                        (r = c = Math.cos(B)),
                                        (s = f = Math.sin(B)),
                                        P &&
                                        ((B -= P * K),
                                            (r = Math.cos(B)),
                                            (s = Math.sin(B)),
                                            "simple" === z.skewType && ((b = Math.tan((P - O) * K)), (b = Math.sqrt(1 + b * b)), (r *= b), (s *= b), z.skewY && ((b = Math.tan(O * K)), (b = Math.sqrt(1 + b * b)), (c *= b), (f *= b)))),
                                        (d = -s),
                                        (g = r);
                                else {
                                    if (!(D || C || 1 !== G || M || L))
                                        return void (A[Ca] =
                                            (z.xPercent || z.yPercent ? "translate(" + z.xPercent + "%," + z.yPercent + "%) translate3d(" : "translate3d(") +
                                            H +
                                            "px," +
                                            I +
                                            "px," +
                                            J +
                                            "px)" +
                                            (1 !== E || 1 !== F ? " scale(" + E + "," + F + ")" : ""));
                                    (c = g = 1), (d = f = 0);
                                }
                                (k = 1),
                                    (e = h = i = j = l = m = 0),
                                    (o = M ? -1 / M : 0),
                                    (p = z.zOrigin),
                                    (q = 1e-6),
                                    (v = ","),
                                    (w = "0"),
                                    (B = D * K),
                                    B && ((r = Math.cos(B)), (s = Math.sin(B)), (i = -s), (l = o * -s), (e = c * s), (h = f * s), (k = r), (o *= r), (c *= r), (f *= r)),
                                    (B = C * K),
                                    B && ((r = Math.cos(B)), (s = Math.sin(B)), (b = d * r + e * s), (t = g * r + h * s), (j = k * s), (m = o * s), (e = d * -s + e * r), (h = g * -s + h * r), (k *= r), (o *= r), (d = b), (g = t)),
                                    1 !== G && ((e *= G), (h *= G), (k *= G), (o *= G)),
                                    1 !== F && ((d *= F), (g *= F), (j *= F), (m *= F)),
                                    1 !== E && ((c *= E), (f *= E), (i *= E), (l *= E)),
                                    (p || L) &&
                                    (p && ((H += e * -p), (I += h * -p), (J += k * -p + p)),
                                        L && ((H += z.xOrigin - (z.xOrigin * c + z.yOrigin * d) + z.xOffset), (I += z.yOrigin - (z.xOrigin * f + z.yOrigin * g) + z.yOffset)),
                                        q > H && H > -q && (H = w),
                                        q > I && I > -q && (I = w),
                                        q > J && J > -q && (J = 0)),
                                    (u = z.xPercent || z.yPercent ? "translate(" + z.xPercent + "%," + z.yPercent + "%) matrix3d(" : "matrix3d("),
                                    (u += (q > c && c > -q ? w : c) + v + (q > f && f > -q ? w : f) + v + (q > i && i > -q ? w : i)),
                                    (u += v + (q > l && l > -q ? w : l) + v + (q > d && d > -q ? w : d) + v + (q > g && g > -q ? w : g)),
                                    C || D || 1 !== G
                                        ? ((u += v + (q > j && j > -q ? w : j) + v + (q > m && m > -q ? w : m) + v + (q > e && e > -q ? w : e)),
                                            (u += v + (q > h && h > -q ? w : h) + v + (q > k && k > -q ? w : k) + v + (q > o && o > -q ? w : o) + v))
                                        : (u += ",0,0,0,0,1,0,"),
                                    (u += H + v + I + v + J + v + (M ? 1 + -J / M : 1) + ")"),
                                    (A[Ca] = u);
                            });
                        (j = Ga.prototype),
                            (j.x = j.y = j.z = j.skewX = j.skewY = j.rotation = j.rotationX = j.rotationY = j.zOrigin = j.xPercent = j.yPercent = j.xOffset = j.yOffset = 0),
                            (j.scaleX = j.scaleY = j.scaleZ = 1),
                            ya(
                                "transform,scale,scaleX,scaleY,scaleZ,x,y,z,rotation,rotationX,rotationY,rotationZ,skewX,skewY,shortRotation,shortRotationX,shortRotationY,shortRotationZ,transformOrigin,svgOrigin,transformPerspective,directionalRotation,parseTransform,force3D,skewType,xPercent,yPercent,smoothOrigin",
                                {
                                    parser: function (a, b, c, d, f, h, i) {
                                        if (d._lastParsedTransform === i) return f;
                                        d._lastParsedTransform = i;
                                        var j,
                                            k = i.scale && "function" == typeof i.scale ? i.scale : 0;
                                        "function" == typeof i[c] && ((j = i[c]), (i[c] = b)), k && (i.scale = k(r, a));
                                        var l,
                                            m,
                                            n,
                                            o,
                                            p,
                                            s,
                                            t,
                                            u,
                                            v,
                                            w = a._gsTransform,
                                            x = a.style,
                                            y = 1e-6,
                                            z = Ba.length,
                                            A = i,
                                            B = {},
                                            C = "transformOrigin",
                                            D = Ra(a, e, !0, A.parseTransform),
                                            E = A.transform && ("function" == typeof A.transform ? A.transform(r, q) : A.transform);
                                        if (((d._transform = D), E && "string" == typeof E && Ca))
                                            (m = Q.style),
                                                (m[Ca] = E),
                                                (m.display = "block"),
                                                (m.position = "absolute"),
                                                O.body.appendChild(Q),
                                                (l = Ra(Q, null, !1)),
                                                D.svg &&
                                                ((s = D.xOrigin),
                                                    (t = D.yOrigin),
                                                    (l.x -= D.xOffset),
                                                    (l.y -= D.yOffset),
                                                    (A.transformOrigin || A.svgOrigin) &&
                                                    ((E = {}), La(a, ha(A.transformOrigin), E, A.svgOrigin, A.smoothOrigin, !0), (s = E.xOrigin), (t = E.yOrigin), (l.x -= E.xOffset - D.xOffset), (l.y -= E.yOffset - D.yOffset)),
                                                    (s || t) && ((u = Qa(Q, !0)), (l.x -= s - (s * u[0] + t * u[2])), (l.y -= t - (s * u[1] + t * u[3])))),
                                                O.body.removeChild(Q),
                                                l.perspective || (l.perspective = D.perspective),
                                                null != A.xPercent && (l.xPercent = ja(A.xPercent, D.xPercent)),
                                                null != A.yPercent && (l.yPercent = ja(A.yPercent, D.yPercent));
                                        else if ("object" == typeof A) {
                                            if (
                                                ((l = {
                                                    scaleX: ja(null != A.scaleX ? A.scaleX : A.scale, D.scaleX),
                                                    scaleY: ja(null != A.scaleY ? A.scaleY : A.scale, D.scaleY),
                                                    scaleZ: ja(A.scaleZ, D.scaleZ),
                                                    x: ja(A.x, D.x),
                                                    y: ja(A.y, D.y),
                                                    z: ja(A.z, D.z),
                                                    xPercent: ja(A.xPercent, D.xPercent),
                                                    yPercent: ja(A.yPercent, D.yPercent),
                                                    perspective: ja(A.transformPerspective, D.perspective),
                                                }),
                                                    (p = A.directionalRotation),
                                                    null != p)
                                            )
                                                if ("object" == typeof p) for (m in p) A[m] = p[m];
                                                else A.rotation = p;
                                            "string" == typeof A.x && -1 !== A.x.indexOf("%") && ((l.x = 0), (l.xPercent = ja(A.x, D.xPercent))),
                                                "string" == typeof A.y && -1 !== A.y.indexOf("%") && ((l.y = 0), (l.yPercent = ja(A.y, D.yPercent))),
                                                (l.rotation = ka("rotation" in A ? A.rotation : "shortRotation" in A ? A.shortRotation + "_short" : "rotationZ" in A ? A.rotationZ : D.rotation, D.rotation, "rotation", B)),
                                                Fa &&
                                                ((l.rotationX = ka("rotationX" in A ? A.rotationX : "shortRotationX" in A ? A.shortRotationX + "_short" : D.rotationX || 0, D.rotationX, "rotationX", B)),
                                                    (l.rotationY = ka("rotationY" in A ? A.rotationY : "shortRotationY" in A ? A.shortRotationY + "_short" : D.rotationY || 0, D.rotationY, "rotationY", B))),
                                                (l.skewX = ka(A.skewX, D.skewX)),
                                                (l.skewY = ka(A.skewY, D.skewY));
                                        }
                                        for (
                                            Fa && null != A.force3D && ((D.force3D = A.force3D), (o = !0)),
                                            D.skewType = A.skewType || D.skewType || g.defaultSkewType,
                                            n = D.force3D || D.z || D.rotationX || D.rotationY || l.z || l.rotationX || l.rotationY || l.perspective,
                                            n || null == A.scale || (l.scaleZ = 1);
                                            --z > -1;

                                        )
                                            (v = Ba[z]),
                                                (E = l[v] - D[v]),
                                                (E > y || -y > E || null != A[v] || null != M[v]) && ((o = !0), (f = new ta(D, v, D[v], E, f)), v in B && (f.e = B[v]), (f.xs0 = 0), (f.plugin = h), d._overwriteProps.push(f.n));
                                        return (
                                            (E = A.transformOrigin),
                                            D.svg &&
                                            (E || A.svgOrigin) &&
                                            ((s = D.xOffset),
                                                (t = D.yOffset),
                                                La(a, ha(E), l, A.svgOrigin, A.smoothOrigin),
                                                (f = ua(D, "xOrigin", (w ? D : l).xOrigin, l.xOrigin, f, C)),
                                                (f = ua(D, "yOrigin", (w ? D : l).yOrigin, l.yOrigin, f, C)),
                                                (s !== D.xOffset || t !== D.yOffset) && ((f = ua(D, "xOffset", w ? s : D.xOffset, D.xOffset, f, C)), (f = ua(D, "yOffset", w ? t : D.yOffset, D.yOffset, f, C))),
                                                (E = "0px 0px")),
                                            (E || (Fa && n && D.zOrigin)) &&
                                            (Ca
                                                ? ((o = !0),
                                                    (v = Ea),
                                                    (E = (E || _(a, v, e, !1, "50% 50%")) + ""),
                                                    (f = new ta(x, v, 0, 0, f, -1, C)),
                                                    (f.b = x[v]),
                                                    (f.plugin = h),
                                                    Fa
                                                        ? ((m = D.zOrigin),
                                                            (E = E.split(" ")),
                                                            (D.zOrigin = (E.length > 2 && (0 === m || "0px" !== E[2]) ? parseFloat(E[2]) : m) || 0),
                                                            (f.xs0 = f.e = E[0] + " " + (E[1] || "50%") + " 0px"),
                                                            (f = new ta(D, "zOrigin", 0, 0, f, -1, f.n)),
                                                            (f.b = m),
                                                            (f.xs0 = f.e = D.zOrigin))
                                                        : (f.xs0 = f.e = E))
                                                : ha(E + "", D)),
                                            o && (d._transformType = (D.svg && Aa) || (!n && 3 !== this._transformType) ? 2 : 3),
                                            j && (i[c] = j),
                                            k && (i.scale = k),
                                            f
                                        );
                                    },
                                    prefix: !0,
                                }
                            ),
                            ya("boxShadow", { defaultValue: "0px 0px 0px 0px #999", prefix: !0, color: !0, multi: !0, keyword: "inset" }),
                            ya("borderRadius", {
                                defaultValue: "0px",
                                parser: function (a, b, c, f, g, h) {
                                    b = this.format(b);
                                    var i,
                                        j,
                                        k,
                                        l,
                                        m,
                                        n,
                                        o,
                                        p,
                                        q,
                                        r,
                                        s,
                                        t,
                                        u,
                                        v,
                                        w,
                                        x,
                                        y = ["borderTopLeftRadius", "borderTopRightRadius", "borderBottomRightRadius", "borderBottomLeftRadius"],
                                        z = a.style;
                                    for (q = parseFloat(a.offsetWidth), r = parseFloat(a.offsetHeight), i = b.split(" "), j = 0; j < y.length; j++)
                                        this.p.indexOf("border") && (y[j] = Z(y[j])),
                                            (m = l = _(a, y[j], e, !1, "0px")),
                                            -1 !== m.indexOf(" ") && ((l = m.split(" ")), (m = l[0]), (l = l[1])),
                                            (n = k = i[j]),
                                            (o = parseFloat(m)),
                                            (t = m.substr((o + "").length)),
                                            (u = "=" === n.charAt(1)),
                                            u
                                                ? ((p = parseInt(n.charAt(0) + "1", 10)), (n = n.substr(2)), (p *= parseFloat(n)), (s = n.substr((p + "").length - (0 > p ? 1 : 0)) || ""))
                                                : ((p = parseFloat(n)), (s = n.substr((p + "").length))),
                                            "" === s && (s = d[c] || t),
                                            s !== t &&
                                            ((v = aa(a, "borderLeft", o, t)),
                                                (w = aa(a, "borderTop", o, t)),
                                                "%" === s
                                                    ? ((m = (v / q) * 100 + "%"), (l = (w / r) * 100 + "%"))
                                                    : "em" === s
                                                        ? ((x = aa(a, "borderLeft", 1, "em")), (m = v / x + "em"), (l = w / x + "em"))
                                                        : ((m = v + "px"), (l = w + "px")),
                                                u && ((n = parseFloat(m) + p + s), (k = parseFloat(l) + p + s))),
                                            (g = va(z, y[j], m + " " + l, n + " " + k, !1, "0px", g));
                                    return g;
                                },
                                prefix: !0,
                                formatter: qa("0px 0px 0px 0px", !1, !0),
                            }),
                            ya("borderBottomLeftRadius,borderBottomRightRadius,borderTopLeftRadius,borderTopRightRadius", {
                                defaultValue: "0px",
                                parser: function (a, b, c, d, f, g) {
                                    return va(a.style, c, this.format(_(a, c, e, !1, "0px 0px")), this.format(b), !1, "0px", f);
                                },
                                prefix: !0,
                                formatter: qa("0px 0px", !1, !0),
                            }),
                            ya("backgroundPosition", {
                                defaultValue: "0 0",
                                parser: function (a, b, c, d, f, g) {
                                    var h,
                                        i,
                                        j,
                                        k,
                                        l,
                                        m,
                                        n = "background-position",
                                        o = e || $(a, null),
                                        q = this.format(
                                            (o ? (p ? o.getPropertyValue(n + "-x") + " " + o.getPropertyValue(n + "-y") : o.getPropertyValue(n)) : a.currentStyle.backgroundPositionX + " " + a.currentStyle.backgroundPositionY) || "0 0"
                                        ),
                                        r = this.format(b);
                                    if ((-1 !== q.indexOf("%")) != (-1 !== r.indexOf("%")) && r.split(",").length < 2 && ((m = _(a, "backgroundImage").replace(D, "")), m && "none" !== m)) {
                                        for (h = q.split(" "), i = r.split(" "), R.setAttribute("src", m), j = 2; --j > -1;)
                                            (q = h[j]),
                                                (k = -1 !== q.indexOf("%")),
                                                k !== (-1 !== i[j].indexOf("%")) && ((l = 0 === j ? a.offsetWidth - R.width : a.offsetHeight - R.height), (h[j] = k ? (parseFloat(q) / 100) * l + "px" : (parseFloat(q) / l) * 100 + "%"));
                                        q = h.join(" ");
                                    }
                                    return this.parseComplex(a.style, q, r, f, g);
                                },
                                formatter: ha,
                            }),
                            ya("backgroundSize", {
                                defaultValue: "0 0",
                                formatter: function (a) {
                                    return (a += ""), ha(-1 === a.indexOf(" ") ? a + " " + a : a);
                                },
                            }),
                            ya("perspective", { defaultValue: "0px", prefix: !0 }),
                            ya("perspectiveOrigin", { defaultValue: "50% 50%", prefix: !0 }),
                            ya("transformStyle", { prefix: !0 }),
                            ya("backfaceVisibility", { prefix: !0 }),
                            ya("userSelect", { prefix: !0 }),
                            ya("margin", { parser: ra("marginTop,marginRight,marginBottom,marginLeft") }),
                            ya("padding", { parser: ra("paddingTop,paddingRight,paddingBottom,paddingLeft") }),
                            ya("clip", {
                                defaultValue: "rect(0px,0px,0px,0px)",
                                parser: function (a, b, c, d, f, g) {
                                    var h, i, j;
                                    return (
                                        9 > p
                                            ? ((i = a.currentStyle), (j = 8 > p ? " " : ","), (h = "rect(" + i.clipTop + j + i.clipRight + j + i.clipBottom + j + i.clipLeft + ")"), (b = this.format(b).split(",").join(j)))
                                            : ((h = this.format(_(a, this.p, e, !1, this.dflt))), (b = this.format(b))),
                                        this.parseComplex(a.style, h, b, f, g)
                                    );
                                },
                            }),
                            ya("textShadow", { defaultValue: "0px 0px 0px #999", color: !0, multi: !0 }),
                            ya("autoRound,strictUnits", {
                                parser: function (a, b, c, d, e) {
                                    return e;
                                },
                            }),
                            ya("border", {
                                defaultValue: "0px solid #000",
                                parser: function (a, b, c, d, f, g) {
                                    var h = _(a, "borderTopWidth", e, !1, "0px"),
                                        i = this.format(b).split(" "),
                                        j = i[0].replace(w, "");
                                    return (
                                        "px" !== j && (h = parseFloat(h) / aa(a, "borderTopWidth", 1, j) + j),
                                        this.parseComplex(a.style, this.format(h + " " + _(a, "borderTopStyle", e, !1, "solid") + " " + _(a, "borderTopColor", e, !1, "#000")), i.join(" "), f, g)
                                    );
                                },
                                color: !0,
                                formatter: function (a) {
                                    var b = a.split(" ");
                                    return b[0] + " " + (b[1] || "solid") + " " + (a.match(pa) || ["#000"])[0];
                                },
                            }),
                            ya("borderWidth", { parser: ra("borderTopWidth,borderRightWidth,borderBottomWidth,borderLeftWidth") }),
                            ya("float,cssFloat,styleFloat", {
                                parser: function (a, b, c, d, e, f) {
                                    var g = a.style,
                                        h = "cssFloat" in g ? "cssFloat" : "styleFloat";
                                    return new ta(g, h, 0, 0, e, -1, c, !1, 0, g[h], b);
                                },
                            });
                        var Ua = function (a) {
                            var b,
                                c = this.t,
                                d = c.filter || _(this.data, "filter") || "",
                                e = (this.s + this.c * a) | 0;
                            100 === e && (-1 === d.indexOf("atrix(") && -1 === d.indexOf("radient(") && -1 === d.indexOf("oader(") ? (c.removeAttribute("filter"), (b = !_(this.data, "filter"))) : ((c.filter = d.replace(z, "")), (b = !0))),
                                b ||
                                (this.xn1 && (c.filter = d = d || "alpha(opacity=" + e + ")"),
                                    -1 === d.indexOf("pacity") ? (0 === e && this.xn1) || (c.filter = d + " alpha(opacity=" + e + ")") : (c.filter = d.replace(x, "opacity=" + e)));
                        };
                        ya("opacity,alpha,autoAlpha", {
                            defaultValue: "1",
                            parser: function (a, b, c, d, f, g) {
                                var h = parseFloat(_(a, "opacity", e, !1, "1")),
                                    i = a.style,
                                    j = "autoAlpha" === c;
                                return (
                                    "string" == typeof b && "=" === b.charAt(1) && (b = ("-" === b.charAt(0) ? -1 : 1) * parseFloat(b.substr(2)) + h),
                                    j && 1 === h && "hidden" === _(a, "visibility", e) && 0 !== b && (h = 0),
                                    U
                                        ? (f = new ta(i, "opacity", h, b - h, f))
                                        : ((f = new ta(i, "opacity", 100 * h, 100 * (b - h), f)),
                                            (f.xn1 = j ? 1 : 0),
                                            (i.zoom = 1),
                                            (f.type = 2),
                                            (f.b = "alpha(opacity=" + f.s + ")"),
                                            (f.e = "alpha(opacity=" + (f.s + f.c) + ")"),
                                            (f.data = a),
                                            (f.plugin = g),
                                            (f.setRatio = Ua)),
                                    j && ((f = new ta(i, "visibility", 0, 0, f, -1, null, !1, 0, 0 !== h ? "inherit" : "hidden", 0 === b ? "hidden" : "inherit")), (f.xs0 = "inherit"), d._overwriteProps.push(f.n), d._overwriteProps.push(c)),
                                    f
                                );
                            },
                        });
                        var Va = function (a, b) {
                            b && (a.removeProperty ? (("ms" === b.substr(0, 2) || "webkit" === b.substr(0, 6)) && (b = "-" + b), a.removeProperty(b.replace(B, "-$1").toLowerCase())) : a.removeAttribute(b));
                        },
                            Wa = function (a) {
                                if (((this.t._gsClassPT = this), 1 === a || 0 === a)) {
                                    this.t.setAttribute("class", 0 === a ? this.b : this.e);
                                    for (var b = this.data, c = this.t.style; b;) b.v ? (c[b.p] = b.v) : Va(c, b.p), (b = b._next);
                                    1 === a && this.t._gsClassPT === this && (this.t._gsClassPT = null);
                                } else this.t.getAttribute("class") !== this.e && this.t.setAttribute("class", this.e);
                            };
                        ya("className", {
                            parser: function (a, b, d, f, g, h, i) {
                                var j,
                                    k,
                                    l,
                                    m,
                                    n,
                                    o = a.getAttribute("class") || "",
                                    p = a.style.cssText;
                                if (((g = f._classNamePT = new ta(a, d, 0, 0, g, 2)), (g.setRatio = Wa), (g.pr = -11), (c = !0), (g.b = o), (k = ca(a, e)), (l = a._gsClassPT))) {
                                    for (m = {}, n = l.data; n;) (m[n.p] = 1), (n = n._next);
                                    l.setRatio(1);
                                }
                                return (
                                    (a._gsClassPT = g),
                                    (g.e = "=" !== b.charAt(1) ? b : o.replace(new RegExp("(?:\\s|^)" + b.substr(2) + "(?![\\w-])"), "") + ("+" === b.charAt(0) ? " " + b.substr(2) : "")),
                                    a.setAttribute("class", g.e),
                                    (j = da(a, k, ca(a), i, m)),
                                    a.setAttribute("class", o),
                                    (g.data = j.firstMPT),
                                    (a.style.cssText = p),
                                    (g = g.xfirst = f.parse(a, j.difs, g, h))
                                );
                            },
                        });
                        var Xa = function (a) {
                            if ((1 === a || 0 === a) && this.data._totalTime === this.data._totalDuration && "isFromStart" !== this.data.data) {
                                var b,
                                    c,
                                    d,
                                    e,
                                    f,
                                    g = this.t.style,
                                    h = i.transform.parse;
                                if ("all" === this.e) (g.cssText = ""), (e = !0);
                                else for (b = this.e.split(" ").join("").split(","), d = b.length; --d > -1;) (c = b[d]), i[c] && (i[c].parse === h ? (e = !0) : (c = "transformOrigin" === c ? Ea : i[c].p)), Va(g, c);
                                e && (Va(g, Ca), (f = this.t._gsTransform), f && (f.svg && (this.t.removeAttribute("data-svg-origin"), this.t.removeAttribute("transform")), delete this.t._gsTransform));
                            }
                        };
                        for (
                            ya("clearProps", {
                                parser: function (a, b, d, e, f) {
                                    return (f = new ta(a, d, 0, 0, f, 2)), (f.setRatio = Xa), (f.e = b), (f.pr = -10), (f.data = e._tween), (c = !0), f;
                                },
                            }),
                            j = "bezier,throwProps,physicsProps,physics2D".split(","),
                            wa = j.length;
                            wa--;

                        )
                            za(j[wa]);
                        (j = g.prototype),
                            (j._firstPT = j._lastParsedTransform = j._transform = null),
                            (j._onInitTween = function (a, b, h, j) {
                                if (!a.nodeType) return !1;
                                (this._target = q = a), (this._tween = h), (this._vars = b), (r = j), (k = b.autoRound), (c = !1), (d = b.suffixMap || g.suffixMap), (e = $(a, "")), (f = this._overwriteProps);
                                var n,
                                    p,
                                    s,
                                    t,
                                    u,
                                    v,
                                    w,
                                    x,
                                    z,
                                    A = a.style;
                                if (
                                    (l && "" === A.zIndex && ((n = _(a, "zIndex", e)), ("auto" === n || "" === n) && this._addLazySet(A, "zIndex", 0)),
                                        "string" == typeof b && ((t = A.cssText), (n = ca(a, e)), (A.cssText = t + ";" + b), (n = da(a, n, ca(a)).difs), !U && y.test(b) && (n.opacity = parseFloat(RegExp.$1)), (b = n), (A.cssText = t)),
                                        b.className ? (this._firstPT = p = i.className.parse(a, b.className, "className", this, null, null, b)) : (this._firstPT = p = this.parse(a, b, null)),
                                        this._transformType)
                                ) {
                                    for (
                                        z = 3 === this._transformType,
                                        Ca
                                            ? m &&
                                            ((l = !0),
                                                "" === A.zIndex && ((w = _(a, "zIndex", e)), ("auto" === w || "" === w) && this._addLazySet(A, "zIndex", 0)),
                                                o && this._addLazySet(A, "WebkitBackfaceVisibility", this._vars.WebkitBackfaceVisibility || (z ? "visible" : "hidden")))
                                            : (A.zoom = 1),
                                        s = p;
                                        s && s._next;

                                    )
                                        s = s._next;
                                    (x = new ta(a, "transform", 0, 0, null, 2)), this._linkCSSP(x, null, s), (x.setRatio = Ca ? Ta : Sa), (x.data = this._transform || Ra(a, e, !0)), (x.tween = h), (x.pr = -1), f.pop();
                                }
                                if (c) {
                                    for (; p;) {
                                        for (v = p._next, s = t; s && s.pr > p.pr;) s = s._next;
                                        (p._prev = s ? s._prev : u) ? (p._prev._next = p) : (t = p), (p._next = s) ? (s._prev = p) : (u = p), (p = v);
                                    }
                                    this._firstPT = t;
                                }
                                return !0;
                            }),
                            (j.parse = function (a, b, c, f) {
                                var g,
                                    h,
                                    j,
                                    l,
                                    m,
                                    n,
                                    o,
                                    p,
                                    s,
                                    t,
                                    u = a.style;
                                for (g in b)
                                    (n = b[g]),
                                        "function" == typeof n && (n = n(r, q)),
                                        (h = i[g]),
                                        h
                                            ? (c = h.parse(a, n, g, this, c, f, b))
                                            : ((m = _(a, g, e) + ""),
                                                (s = "string" == typeof n),
                                                "color" === g || "fill" === g || "stroke" === g || -1 !== g.indexOf("Color") || (s && A.test(n))
                                                    ? (s || ((n = na(n)), (n = (n.length > 3 ? "rgba(" : "rgb(") + n.join(",") + ")")), (c = va(u, g, m, n, !0, "transparent", c, 0, f)))
                                                    : s && J.test(n)
                                                        ? (c = va(u, g, m, n, !0, null, c, 0, f))
                                                        : ((j = parseFloat(m)),
                                                            (o = j || 0 === j ? m.substr((j + "").length) : ""),
                                                            ("" === m || "auto" === m) &&
                                                            ("width" === g || "height" === g ? ((j = ga(a, g, e)), (o = "px")) : "left" === g || "top" === g ? ((j = ba(a, g, e)), (o = "px")) : ((j = "opacity" !== g ? 0 : 1), (o = ""))),
                                                            (t = s && "=" === n.charAt(1)),
                                                            t ? ((l = parseInt(n.charAt(0) + "1", 10)), (n = n.substr(2)), (l *= parseFloat(n)), (p = n.replace(w, ""))) : ((l = parseFloat(n)), (p = s ? n.replace(w, "") : "")),
                                                            "" === p && (p = g in d ? d[g] : o),
                                                            (n = l || 0 === l ? (t ? l + j : l) + p : b[g]),
                                                            o !== p &&
                                                            "" !== p &&
                                                            (l || 0 === l) &&
                                                            j &&
                                                            ((j = aa(a, g, j, o)),
                                                                "%" === p
                                                                    ? ((j /= aa(a, g, 100, "%") / 100), b.strictUnits !== !0 && (m = j + "%"))
                                                                    : "em" === p || "rem" === p || "vw" === p || "vh" === p
                                                                        ? (j /= aa(a, g, 1, p))
                                                                        : "px" !== p && ((l = aa(a, g, l, p)), (p = "px")),
                                                                t && (l || 0 === l) && (n = l + j + p)),
                                                            t && (l += j),
                                                            (!j && 0 !== j) || (!l && 0 !== l)
                                                                ? void 0 !== u[g] && (n || (n + "" != "NaN" && null != n))
                                                                    ? ((c = new ta(u, g, l || j || 0, 0, c, -1, g, !1, 0, m, n)), (c.xs0 = "none" !== n || ("display" !== g && -1 === g.indexOf("Style")) ? n : m))
                                                                    : W("invalid " + g + " tween value: " + b[g])
                                                                : ((c = new ta(u, g, j, l - j, c, 0, g, k !== !1 && ("px" === p || "zIndex" === g), 0, m, n)), (c.xs0 = p)))),
                                        f && c && !c.plugin && (c.plugin = f);
                                return c;
                            }),
                            (j.setRatio = function (a) {
                                var b,
                                    c,
                                    d,
                                    e = this._firstPT,
                                    f = 1e-6;
                                if (1 !== a || (this._tween._time !== this._tween._duration && 0 !== this._tween._time))
                                    if (a || (this._tween._time !== this._tween._duration && 0 !== this._tween._time) || this._tween._rawPrevTime === -1e-6)
                                        for (; e;) {
                                            if (((b = e.c * a + e.s), e.r ? (b = Math.round(b)) : f > b && b > -f && (b = 0), e.type))
                                                if (1 === e.type)
                                                    if (((d = e.l), 2 === d)) e.t[e.p] = e.xs0 + b + e.xs1 + e.xn1 + e.xs2;
                                                    else if (3 === d) e.t[e.p] = e.xs0 + b + e.xs1 + e.xn1 + e.xs2 + e.xn2 + e.xs3;
                                                    else if (4 === d) e.t[e.p] = e.xs0 + b + e.xs1 + e.xn1 + e.xs2 + e.xn2 + e.xs3 + e.xn3 + e.xs4;
                                                    else if (5 === d) e.t[e.p] = e.xs0 + b + e.xs1 + e.xn1 + e.xs2 + e.xn2 + e.xs3 + e.xn3 + e.xs4 + e.xn4 + e.xs5;
                                                    else {
                                                        for (c = e.xs0 + b + e.xs1, d = 1; d < e.l; d++) c += e["xn" + d] + e["xs" + (d + 1)];
                                                        e.t[e.p] = c;
                                                    }
                                                else -1 === e.type ? (e.t[e.p] = e.xs0) : e.setRatio && e.setRatio(a);
                                            else e.t[e.p] = b + e.xs0;
                                            e = e._next;
                                        }
                                    else for (; e;) 2 !== e.type ? (e.t[e.p] = e.b) : e.setRatio(a), (e = e._next);
                                else
                                    for (; e;) {
                                        if (2 !== e.type)
                                            if (e.r && -1 !== e.type)
                                                if (((b = Math.round(e.s + e.c)), e.type)) {
                                                    if (1 === e.type) {
                                                        for (d = e.l, c = e.xs0 + b + e.xs1, d = 1; d < e.l; d++) c += e["xn" + d] + e["xs" + (d + 1)];
                                                        e.t[e.p] = c;
                                                    }
                                                } else e.t[e.p] = b + e.xs0;
                                            else e.t[e.p] = e.e;
                                        else e.setRatio(a);
                                        e = e._next;
                                    }
                            }),
                            (j._enableTransforms = function (a) {
                                (this._transform = this._transform || Ra(this._target, e, !0)), (this._transformType = (this._transform.svg && Aa) || (!a && 3 !== this._transformType) ? 2 : 3);
                            });
                        var Ya = function (a) {
                            (this.t[this.p] = this.e), this.data._linkCSSP(this, this._next, null, !0);
                        };
                        (j._addLazySet = function (a, b, c) {
                            var d = (this._firstPT = new ta(a, b, 0, 0, this._firstPT, 2));
                            (d.e = c), (d.setRatio = Ya), (d.data = this);
                        }),
                            (j._linkCSSP = function (a, b, c, d) {
                                return (
                                    a &&
                                    (b && (b._prev = a),
                                        a._next && (a._next._prev = a._prev),
                                        a._prev ? (a._prev._next = a._next) : this._firstPT === a && ((this._firstPT = a._next), (d = !0)),
                                        c ? (c._next = a) : d || null !== this._firstPT || (this._firstPT = a),
                                        (a._next = b),
                                        (a._prev = c)),
                                    a
                                );
                            }),
                            (j._mod = function (a) {
                                for (var b = this._firstPT; b;) "function" == typeof a[b.p] && a[b.p] === Math.round && (b.r = 1), (b = b._next);
                            }),
                            (j._kill = function (b) {
                                var c,
                                    d,
                                    e,
                                    f = b;
                                if (b.autoAlpha || b.alpha) {
                                    f = {};
                                    for (d in b) f[d] = b[d];
                                    (f.opacity = 1), f.autoAlpha && (f.visibility = 1);
                                }
                                for (
                                    b.className &&
                                    (c = this._classNamePT) &&
                                    ((e = c.xfirst),
                                        e && e._prev ? this._linkCSSP(e._prev, c._next, e._prev._prev) : e === this._firstPT && (this._firstPT = c._next),
                                        c._next && this._linkCSSP(c._next, c._next._next, e._prev),
                                        (this._classNamePT = null)),
                                    c = this._firstPT;
                                    c;

                                )
                                    c.plugin && c.plugin !== d && c.plugin._kill && (c.plugin._kill(b), (d = c.plugin)), (c = c._next);
                                return a.prototype._kill.call(this, f);
                            });
                        var Za = function (a, b, c) {
                            var d, e, f, g;
                            if (a.slice) for (e = a.length; --e > -1;) Za(a[e], b, c);
                            else for (d = a.childNodes, e = d.length; --e > -1;) (f = d[e]), (g = f.type), f.style && (b.push(ca(f)), c && c.push(f)), (1 !== g && 9 !== g && 11 !== g) || !f.childNodes.length || Za(f, b, c);
                        };
                        return (
                            (g.cascadeTo = function (a, c, d) {
                                var e,
                                    f,
                                    g,
                                    h,
                                    i = b.to(a, c, d),
                                    j = [i],
                                    k = [],
                                    l = [],
                                    m = [],
                                    n = b._internals.reservedProps;
                                for (a = i._targets || i.target, Za(a, k, m), i.render(c, !0, !0), Za(a, l), i.render(0, !0, !0), i._enabled(!0), e = m.length; --e > -1;)
                                    if (((f = da(m[e], k[e], l[e])), f.firstMPT)) {
                                        f = f.difs;
                                        for (g in d) n[g] && (f[g] = d[g]);
                                        h = {};
                                        for (g in f) h[g] = k[e][g];
                                        j.push(b.fromTo(m[e], c, h, f));
                                    }
                                return j;
                            }),
                            a.activate([g]),
                            g
                        );
                    },
                    !0
                ),
                (function () {
                    var a = _gsScope._gsDefine.plugin({
                        propName: "roundProps",
                        version: "1.6.0",
                        priority: -1,
                        API: 2,
                        init: function (a, b, c) {
                            return (this._tween = c), !0;
                        },
                    }),
                        b = function (a) {
                            for (; a;) a.f || a.blob || (a.m = Math.round), (a = a._next);
                        },
                        c = a.prototype;
                    (c._onInitAllProps = function () {
                        for (var a, c, d, e = this._tween, f = e.vars.roundProps.join ? e.vars.roundProps : e.vars.roundProps.split(","), g = f.length, h = {}, i = e._propLookup.roundProps; --g > -1;) h[f[g]] = Math.round;
                        for (g = f.length; --g > -1;)
                            for (a = f[g], c = e._firstPT; c;)
                                (d = c._next),
                                    c.pg
                                        ? c.t._mod(h)
                                        : c.n === a &&
                                        (2 === c.f && c.t
                                            ? b(c.t._firstPT)
                                            : (this._add(c.t, a, c.s, c.c), d && (d._prev = c._prev), c._prev ? (c._prev._next = d) : e._firstPT === c && (e._firstPT = d), (c._next = c._prev = null), (e._propLookup[a] = i))),
                                    (c = d);
                        return !1;
                    }),
                        (c._add = function (a, b, c, d) {
                            this._addTween(a, b, c, c + d, b, Math.round), this._overwriteProps.push(b);
                        });
                })(),
                (function () {
                    _gsScope._gsDefine.plugin({
                        propName: "attr",
                        API: 2,
                        version: "0.6.0",
                        init: function (a, b, c, d) {
                            var e, f;
                            if ("function" != typeof a.setAttribute) return !1;
                            for (e in b) (f = b[e]), "function" == typeof f && (f = f(d, a)), this._addTween(a, "setAttribute", a.getAttribute(e) + "", f + "", e, !1, e), this._overwriteProps.push(e);
                            return !0;
                        },
                    });
                })(),
                (_gsScope._gsDefine.plugin({
                    propName: "directionalRotation",
                    version: "0.3.0",
                    API: 2,
                    init: function (a, b, c, d) {
                        "object" != typeof b && (b = { rotation: b }), (this.finals = {});
                        var e,
                            f,
                            g,
                            h,
                            i,
                            j,
                            k = b.useRadians === !0 ? 2 * Math.PI : 360,
                            l = 1e-6;
                        for (e in b)
                            "useRadians" !== e &&
                                ((h = b[e]),
                                    "function" == typeof h && (h = h(d, a)),
                                    (j = (h + "").split("_")),
                                    (f = j[0]),
                                    (g = parseFloat("function" != typeof a[e] ? a[e] : a[e.indexOf("set") || "function" != typeof a["get" + e.substr(3)] ? e : "get" + e.substr(3)]())),
                                    (h = this.finals[e] = "string" == typeof f && "=" === f.charAt(1) ? g + parseInt(f.charAt(0) + "1", 10) * Number(f.substr(2)) : Number(f) || 0),
                                    (i = h - g),
                                    j.length &&
                                    ((f = j.join("_")),
                                        -1 !== f.indexOf("short") && ((i %= k), i !== i % (k / 2) && (i = 0 > i ? i + k : i - k)),
                                        -1 !== f.indexOf("_cw") && 0 > i ? (i = ((i + 9999999999 * k) % k) - ((i / k) | 0) * k) : -1 !== f.indexOf("ccw") && i > 0 && (i = ((i - 9999999999 * k) % k) - ((i / k) | 0) * k)),
                                    (i > l || -l > i) && (this._addTween(a, e, g, g + i, e), this._overwriteProps.push(e)));
                        return !0;
                    },
                    set: function (a) {
                        var b;
                        if (1 !== a) this._super.setRatio.call(this, a);
                        else for (b = this._firstPT; b;) b.f ? b.t[b.p](this.finals[b.p]) : (b.t[b.p] = this.finals[b.p]), (b = b._next);
                    },
                })._autoCSS = !0),
                _gsScope._gsDefine(
                    "easing.Back",
                    ["easing.Ease"],
                    function (a) {
                        var b,
                            c,
                            d,
                            e = _gsScope.GreenSockGlobals || _gsScope,
                            f = e.com.greensock,
                            g = 2 * Math.PI,
                            h = Math.PI / 2,
                            i = f._class,
                            j = function (b, c) {
                                var d = i("easing." + b, function () { }, !0),
                                    e = (d.prototype = new a());
                                return (e.constructor = d), (e.getRatio = c), d;
                            },
                            k = a.register || function () { },
                            l = function (a, b, c, d, e) {
                                var f = i("easing." + a, { easeOut: new b(), easeIn: new c(), easeInOut: new d() }, !0);
                                return k(f, a), f;
                            },
                            m = function (a, b, c) {
                                (this.t = a), (this.v = b), c && ((this.next = c), (c.prev = this), (this.c = c.v - b), (this.gap = c.t - a));
                            },
                            n = function (b, c) {
                                var d = i(
                                    "easing." + b,
                                    function (a) {
                                        (this._p1 = a || 0 === a ? a : 1.70158), (this._p2 = 1.525 * this._p1);
                                    },
                                    !0
                                ),
                                    e = (d.prototype = new a());
                                return (
                                    (e.constructor = d),
                                    (e.getRatio = c),
                                    (e.config = function (a) {
                                        return new d(a);
                                    }),
                                    d
                                );
                            },
                            o = l(
                                "Back",
                                n("BackOut", function (a) {
                                    return (a -= 1) * a * ((this._p1 + 1) * a + this._p1) + 1;
                                }),
                                n("BackIn", function (a) {
                                    return a * a * ((this._p1 + 1) * a - this._p1);
                                }),
                                n("BackInOut", function (a) {
                                    return (a *= 2) < 1 ? 0.5 * a * a * ((this._p2 + 1) * a - this._p2) : 0.5 * ((a -= 2) * a * ((this._p2 + 1) * a + this._p2) + 2);
                                })
                            ),
                            p = i(
                                "easing.SlowMo",
                                function (a, b, c) {
                                    (b = b || 0 === b ? b : 0.7), null == a ? (a = 0.7) : a > 1 && (a = 1), (this._p = 1 !== a ? b : 0), (this._p1 = (1 - a) / 2), (this._p2 = a), (this._p3 = this._p1 + this._p2), (this._calcEnd = c === !0);
                                },
                                !0
                            ),
                            q = (p.prototype = new a());
                        return (
                            (q.constructor = p),
                            (q.getRatio = function (a) {
                                var b = a + (0.5 - a) * this._p;
                                return a < this._p1
                                    ? this._calcEnd
                                        ? 1 - (a = 1 - a / this._p1) * a
                                        : b - (a = 1 - a / this._p1) * a * a * a * b
                                    : a > this._p3
                                        ? this._calcEnd
                                            ? 1 - (a = (a - this._p3) / this._p1) * a
                                            : b + (a - b) * (a = (a - this._p3) / this._p1) * a * a * a
                                        : this._calcEnd
                                            ? 1
                                            : b;
                            }),
                            (p.ease = new p(0.7, 0.7)),
                            (q.config = p.config = function (a, b, c) {
                                return new p(a, b, c);
                            }),
                            (b = i(
                                "easing.SteppedEase",
                                function (a) {
                                    (a = a || 1), (this._p1 = 1 / a), (this._p2 = a + 1);
                                },
                                !0
                            )),
                            (q = b.prototype = new a()),
                            (q.constructor = b),
                            (q.getRatio = function (a) {
                                return 0 > a ? (a = 0) : a >= 1 && (a = 0.999999999), ((this._p2 * a) >> 0) * this._p1;
                            }),
                            (q.config = b.config = function (a) {
                                return new b(a);
                            }),
                            (c = i(
                                "easing.RoughEase",
                                function (b) {
                                    b = b || {};
                                    for (
                                        var c,
                                        d,
                                        e,
                                        f,
                                        g,
                                        h,
                                        i = b.taper || "none",
                                        j = [],
                                        k = 0,
                                        l = 0 | (b.points || 20),
                                        n = l,
                                        o = b.randomize !== !1,
                                        p = b.clamp === !0,
                                        q = b.template instanceof a ? b.template : null,
                                        r = "number" == typeof b.strength ? 0.4 * b.strength : 0.4;
                                        --n > -1;

                                    )
                                        (c = o ? Math.random() : (1 / l) * n),
                                            (d = q ? q.getRatio(c) : c),
                                            "none" === i ? (e = r) : "out" === i ? ((f = 1 - c), (e = f * f * r)) : "in" === i ? (e = c * c * r) : 0.5 > c ? ((f = 2 * c), (e = f * f * 0.5 * r)) : ((f = 2 * (1 - c)), (e = f * f * 0.5 * r)),
                                            o ? (d += Math.random() * e - 0.5 * e) : n % 2 ? (d += 0.5 * e) : (d -= 0.5 * e),
                                            p && (d > 1 ? (d = 1) : 0 > d && (d = 0)),
                                            (j[k++] = { x: c, y: d });
                                    for (
                                        j.sort(function (a, b) {
                                            return a.x - b.x;
                                        }),
                                        h = new m(1, 1, null),
                                        n = l;
                                        --n > -1;

                                    )
                                        (g = j[n]), (h = new m(g.x, g.y, h));
                                    this._prev = new m(0, 0, 0 !== h.t ? h : h.next);
                                },
                                !0
                            )),
                            (q = c.prototype = new a()),
                            (q.constructor = c),
                            (q.getRatio = function (a) {
                                var b = this._prev;
                                if (a > b.t) {
                                    for (; b.next && a >= b.t;) b = b.next;
                                    b = b.prev;
                                } else for (; b.prev && a <= b.t;) b = b.prev;
                                return (this._prev = b), b.v + ((a - b.t) / b.gap) * b.c;
                            }),
                            (q.config = function (a) {
                                return new c(a);
                            }),
                            (c.ease = new c()),
                            l(
                                "Bounce",
                                j("BounceOut", function (a) {
                                    return 1 / 2.75 > a ? 7.5625 * a * a : 2 / 2.75 > a ? 7.5625 * (a -= 1.5 / 2.75) * a + 0.75 : 2.5 / 2.75 > a ? 7.5625 * (a -= 2.25 / 2.75) * a + 0.9375 : 7.5625 * (a -= 2.625 / 2.75) * a + 0.984375;
                                }),
                                j("BounceIn", function (a) {
                                    return (a = 1 - a) < 1 / 2.75
                                        ? 1 - 7.5625 * a * a
                                        : 2 / 2.75 > a
                                            ? 1 - (7.5625 * (a -= 1.5 / 2.75) * a + 0.75)
                                            : 2.5 / 2.75 > a
                                                ? 1 - (7.5625 * (a -= 2.25 / 2.75) * a + 0.9375)
                                                : 1 - (7.5625 * (a -= 2.625 / 2.75) * a + 0.984375);
                                }),
                                j("BounceInOut", function (a) {
                                    var b = 0.5 > a;
                                    return (
                                        (a = b ? 1 - 2 * a : 2 * a - 1),
                                        (a = 1 / 2.75 > a ? 7.5625 * a * a : 2 / 2.75 > a ? 7.5625 * (a -= 1.5 / 2.75) * a + 0.75 : 2.5 / 2.75 > a ? 7.5625 * (a -= 2.25 / 2.75) * a + 0.9375 : 7.5625 * (a -= 2.625 / 2.75) * a + 0.984375),
                                        b ? 0.5 * (1 - a) : 0.5 * a + 0.5
                                    );
                                })
                            ),
                            l(
                                "Circ",
                                j("CircOut", function (a) {
                                    return Math.sqrt(1 - (a -= 1) * a);
                                }),
                                j("CircIn", function (a) {
                                    return -(Math.sqrt(1 - a * a) - 1);
                                }),
                                j("CircInOut", function (a) {
                                    return (a *= 2) < 1 ? -0.5 * (Math.sqrt(1 - a * a) - 1) : 0.5 * (Math.sqrt(1 - (a -= 2) * a) + 1);
                                })
                            ),
                            (d = function (b, c, d) {
                                var e = i(
                                    "easing." + b,
                                    function (a, b) {
                                        (this._p1 = a >= 1 ? a : 1), (this._p2 = (b || d) / (1 > a ? a : 1)), (this._p3 = (this._p2 / g) * (Math.asin(1 / this._p1) || 0)), (this._p2 = g / this._p2);
                                    },
                                    !0
                                ),
                                    f = (e.prototype = new a());
                                return (
                                    (f.constructor = e),
                                    (f.getRatio = c),
                                    (f.config = function (a, b) {
                                        return new e(a, b);
                                    }),
                                    e
                                );
                            }),
                            l(
                                "Elastic",
                                d(
                                    "ElasticOut",
                                    function (a) {
                                        return this._p1 * Math.pow(2, -10 * a) * Math.sin((a - this._p3) * this._p2) + 1;
                                    },
                                    0.3
                                ),
                                d(
                                    "ElasticIn",
                                    function (a) {
                                        return -(this._p1 * Math.pow(2, 10 * (a -= 1)) * Math.sin((a - this._p3) * this._p2));
                                    },
                                    0.3
                                ),
                                d(
                                    "ElasticInOut",
                                    function (a) {
                                        return (a *= 2) < 1 ? -0.5 * (this._p1 * Math.pow(2, 10 * (a -= 1)) * Math.sin((a - this._p3) * this._p2)) : this._p1 * Math.pow(2, -10 * (a -= 1)) * Math.sin((a - this._p3) * this._p2) * 0.5 + 1;
                                    },
                                    0.45
                                )
                            ),
                            l(
                                "Expo",
                                j("ExpoOut", function (a) {
                                    return 1 - Math.pow(2, -10 * a);
                                }),
                                j("ExpoIn", function (a) {
                                    return Math.pow(2, 10 * (a - 1)) - 0.001;
                                }),
                                j("ExpoInOut", function (a) {
                                    return (a *= 2) < 1 ? 0.5 * Math.pow(2, 10 * (a - 1)) : 0.5 * (2 - Math.pow(2, -10 * (a - 1)));
                                })
                            ),
                            l(
                                "Sine",
                                j("SineOut", function (a) {
                                    return Math.sin(a * h);
                                }),
                                j("SineIn", function (a) {
                                    return -Math.cos(a * h) + 1;
                                }),
                                j("SineInOut", function (a) {
                                    return -0.5 * (Math.cos(Math.PI * a) - 1);
                                })
                            ),
                            i(
                                "easing.EaseLookup",
                                {
                                    find: function (b) {
                                        return a.map[b];
                                    },
                                },
                                !0
                            ),
                            k(e.SlowMo, "SlowMo", "ease,"),
                            k(c, "RoughEase", "ease,"),
                            k(b, "SteppedEase", "ease,"),
                            o
                        );
                    },
                    !0
                );
        }),
            _gsScope._gsDefine && _gsScope._gsQueue.pop()(),
            (function (a, b) {
                "use strict";
                var c = {},
                    d = a.document,
                    e = (a.GreenSockGlobals = a.GreenSockGlobals || a);
                if (!e.TweenLite) {
                    var f,
                        g,
                        h,
                        i,
                        j,
                        k = function (a) {
                            var b,
                                c = a.split("."),
                                d = e;
                            for (b = 0; b < c.length; b++) d[c[b]] = d = d[c[b]] || {};
                            return d;
                        },
                        l = k("com.greensock"),
                        m = 1e-10,
                        n = function (a) {
                            var b,
                                c = [],
                                d = a.length;
                            for (b = 0; b !== d; c.push(a[b++]));
                            return c;
                        },
                        o = function () { },
                        p = (function () {
                            var a = Object.prototype.toString,
                                b = a.call([]);
                            return function (c) {
                                return null != c && (c instanceof Array || ("object" == typeof c && !!c.push && a.call(c) === b));
                            };
                        })(),
                        q = {},
                        r = function (d, f, g, h) {
                            (this.sc = q[d] ? q[d].sc : []), (q[d] = this), (this.gsClass = null), (this.func = g);
                            var i = [];
                            (this.check = function (j) {
                                for (var l, m, n, o, p, s = f.length, t = s; --s > -1;) (l = q[f[s]] || new r(f[s], [])).gsClass ? ((i[s] = l.gsClass), t--) : j && l.sc.push(this);
                                if (0 === t && g) {
                                    if (((m = ("com.greensock." + d).split(".")), (n = m.pop()), (o = k(m.join("."))[n] = this.gsClass = g.apply(g, i)), h))
                                        if (((e[n] = c[n] = o), (p = "undefined" != "object" && module.exports), !p && "function" == typeof undefined && undefined.amd))
                                            undefined((a.GreenSockAMDPath ? a.GreenSockAMDPath + "/" : "") + d.split(".").pop(), [], function () {
                                                return o;
                                            });
                                        else if (p)
                                            if (d === b) {
                                                module.exports = c[b] = o;
                                                for (s in c) o[s] = c[s];
                                            } else c[b] && (c[b][n] = o);
                                    for (s = 0; s < this.sc.length; s++) this.sc[s].check();
                                }
                            }),
                                this.check(!0);
                        },
                        s = (a._gsDefine = function (a, b, c, d) {
                            return new r(a, b, c, d);
                        }),
                        t = (l._class = function (a, b, c) {
                            return (
                                (b = b || function () { }),
                                s(
                                    a,
                                    [],
                                    function () {
                                        return b;
                                    },
                                    c
                                ),
                                b
                            );
                        });
                    s.globals = e;
                    var u = [0, 0, 1, 1],
                        v = t(
                            "easing.Ease",
                            function (a, b, c, d) {
                                (this._func = a), (this._type = c || 0), (this._power = d || 0), (this._params = b ? u.concat(b) : u);
                            },
                            !0
                        ),
                        w = (v.map = {}),
                        x = (v.register = function (a, b, c, d) {
                            for (var e, f, g, h, i = b.split(","), j = i.length, k = (c || "easeIn,easeOut,easeInOut").split(","); --j > -1;)
                                for (f = i[j], e = d ? t("easing." + f, null, !0) : l.easing[f] || {}, g = k.length; --g > -1;) (h = k[g]), (w[f + "." + h] = w[h + f] = e[h] = a.getRatio ? a : a[h] || new a());
                        });
                    for (
                        h = v.prototype,
                        h._calcEnd = !1,
                        h.getRatio = function (a) {
                            if (this._func) return (this._params[0] = a), this._func.apply(null, this._params);
                            var b = this._type,
                                c = this._power,
                                d = 1 === b ? 1 - a : 2 === b ? a : 0.5 > a ? 2 * a : 2 * (1 - a);
                            return 1 === c ? (d *= d) : 2 === c ? (d *= d * d) : 3 === c ? (d *= d * d * d) : 4 === c && (d *= d * d * d * d), 1 === b ? 1 - d : 2 === b ? d : 0.5 > a ? d / 2 : 1 - d / 2;
                        },
                        f = ["Linear", "Quad", "Cubic", "Quart", "Quint,Strong"],
                        g = f.length;
                        --g > -1;

                    )
                        (h = f[g] + ",Power" + g), x(new v(null, null, 1, g), h, "easeOut", !0), x(new v(null, null, 2, g), h, "easeIn" + (0 === g ? ",easeNone" : "")), x(new v(null, null, 3, g), h, "easeInOut");
                    (w.linear = l.easing.Linear.easeIn), (w.swing = l.easing.Quad.easeInOut);
                    var y = t("events.EventDispatcher", function (a) {
                        (this._listeners = {}), (this._eventTarget = a || this);
                    });
                    (h = y.prototype),
                        (h.addEventListener = function (a, b, c, d, e) {
                            e = e || 0;
                            var f,
                                g,
                                h = this._listeners[a],
                                k = 0;
                            for (this !== i || j || i.wake(), null == h && (this._listeners[a] = h = []), g = h.length; --g > -1;) (f = h[g]), f.c === b && f.s === c ? h.splice(g, 1) : 0 === k && f.pr < e && (k = g + 1);
                            h.splice(k, 0, { c: b, s: c, up: d, pr: e });
                        }),
                        (h.removeEventListener = function (a, b) {
                            var c,
                                d = this._listeners[a];
                            if (d) for (c = d.length; --c > -1;) if (d[c].c === b) return void d.splice(c, 1);
                        }),
                        (h.dispatchEvent = function (a) {
                            var b,
                                c,
                                d,
                                e = this._listeners[a];
                            if (e) for (b = e.length, b > 1 && (e = e.slice(0)), c = this._eventTarget; --b > -1;) (d = e[b]), d && (d.up ? d.c.call(d.s || c, { type: a, target: c }) : d.c.call(d.s || c));
                        });
                    var z = a.requestAnimationFrame,
                        A = a.cancelAnimationFrame,
                        B =
                            Date.now ||
                            function () {
                                return new Date().getTime();
                            },
                        C = B();
                    for (f = ["ms", "moz", "webkit", "o"], g = f.length; --g > -1 && !z;) (z = a[f[g] + "RequestAnimationFrame"]), (A = a[f[g] + "CancelAnimationFrame"] || a[f[g] + "CancelRequestAnimationFrame"]);
                    t("Ticker", function (a, b) {
                        var c,
                            e,
                            f,
                            g,
                            h,
                            k = this,
                            l = B(),
                            n = b !== !1 && z ? "auto" : !1,
                            p = 500,
                            q = 33,
                            r = "tick",
                            s = function (a) {
                                var b,
                                    d,
                                    i = B() - C;
                                i > p && (l += i - q),
                                    (C += i),
                                    (k.time = (C - l) / 1e3),
                                    (b = k.time - h),
                                    (!c || b > 0 || a === !0) && (k.frame++, (h += b + (b >= g ? 0.004 : g - b)), (d = !0)),
                                    a !== !0 && (f = e(s)),
                                    d && k.dispatchEvent(r);
                            };
                        y.call(k),
                            (k.time = k.frame = 0),
                            (k.tick = function () {
                                s(!0);
                            }),
                            (k.lagSmoothing = function (a, b) {
                                (p = a || 1 / m), (q = Math.min(b, p, 0));
                            }),
                            (k.sleep = function () {
                                null != f && (n && A ? A(f) : clearTimeout(f), (e = o), (f = null), k === i && (j = !1));
                            }),
                            (k.wake = function (a) {
                                null !== f ? k.sleep() : a ? (l += -C + (C = B())) : k.frame > 10 && (C = B() - p + 5),
                                    (e =
                                        0 === c
                                            ? o
                                            : n && z
                                                ? z
                                                : function (a) {
                                                    return setTimeout(a, (1e3 * (h - k.time) + 1) | 0);
                                                }),
                                    k === i && (j = !0),
                                    s(2);
                            }),
                            (k.fps = function (a) {
                                return arguments.length ? ((c = a), (g = 1 / (c || 60)), (h = this.time + g), void k.wake()) : c;
                            }),
                            (k.useRAF = function (a) {
                                return arguments.length ? (k.sleep(), (n = a), void k.fps(c)) : n;
                            }),
                            k.fps(a),
                            setTimeout(function () {
                                "auto" === n && k.frame < 5 && "hidden" !== d.visibilityState && k.useRAF(!1);
                            }, 1500);
                    }),
                        (h = l.Ticker.prototype = new l.events.EventDispatcher()),
                        (h.constructor = l.Ticker);
                    var D = t("core.Animation", function (a, b) {
                        if (
                            ((this.vars = b = b || {}),
                                (this._duration = this._totalDuration = a || 0),
                                (this._delay = Number(b.delay) || 0),
                                (this._timeScale = 1),
                                (this._active = b.immediateRender === !0),
                                (this.data = b.data),
                                (this._reversed = b.reversed === !0),
                                W)
                        ) {
                            j || i.wake();
                            var c = this.vars.useFrames ? V : W;
                            c.add(this, c._time), this.vars.paused && this.paused(!0);
                        }
                    });
                    (i = D.ticker = new l.Ticker()),
                        (h = D.prototype),
                        (h._dirty = h._gc = h._initted = h._paused = !1),
                        (h._totalTime = h._time = 0),
                        (h._rawPrevTime = -1),
                        (h._next = h._last = h._onUpdate = h._timeline = h.timeline = null),
                        (h._paused = !1);
                    var E = function () {
                        j && B() - C > 2e3 && i.wake(), setTimeout(E, 2e3);
                    };
                    E(),
                        (h.play = function (a, b) {
                            return null != a && this.seek(a, b), this.reversed(!1).paused(!1);
                        }),
                        (h.pause = function (a, b) {
                            return null != a && this.seek(a, b), this.paused(!0);
                        }),
                        (h.resume = function (a, b) {
                            return null != a && this.seek(a, b), this.paused(!1);
                        }),
                        (h.seek = function (a, b) {
                            return this.totalTime(Number(a), b !== !1);
                        }),
                        (h.restart = function (a, b) {
                            return this.reversed(!1)
                                .paused(!1)
                                .totalTime(a ? -this._delay : 0, b !== !1, !0);
                        }),
                        (h.reverse = function (a, b) {
                            return null != a && this.seek(a || this.totalDuration(), b), this.reversed(!0).paused(!1);
                        }),
                        (h.render = function (a, b, c) { }),
                        (h.invalidate = function () {
                            return (this._time = this._totalTime = 0), (this._initted = this._gc = !1), (this._rawPrevTime = -1), (this._gc || !this.timeline) && this._enabled(!0), this;
                        }),
                        (h.isActive = function () {
                            var a,
                                b = this._timeline,
                                c = this._startTime;
                            return !b || (!this._gc && !this._paused && b.isActive() && (a = b.rawTime(!0)) >= c && a < c + this.totalDuration() / this._timeScale);
                        }),
                        (h._enabled = function (a, b) {
                            return (
                                j || i.wake(),
                                (this._gc = !a),
                                (this._active = this.isActive()),
                                b !== !0 && (a && !this.timeline ? this._timeline.add(this, this._startTime - this._delay) : !a && this.timeline && this._timeline._remove(this, !0)),
                                !1
                            );
                        }),
                        (h._kill = function (a, b) {
                            return this._enabled(!1, !1);
                        }),
                        (h.kill = function (a, b) {
                            return this._kill(a, b), this;
                        }),
                        (h._uncache = function (a) {
                            for (var b = a ? this : this.timeline; b;) (b._dirty = !0), (b = b.timeline);
                            return this;
                        }),
                        (h._swapSelfInParams = function (a) {
                            for (var b = a.length, c = a.concat(); --b > -1;) "{self}" === a[b] && (c[b] = this);
                            return c;
                        }),
                        (h._callback = function (a) {
                            var b = this.vars,
                                c = b[a],
                                d = b[a + "Params"],
                                e = b[a + "Scope"] || b.callbackScope || this,
                                f = d ? d.length : 0;
                            switch (f) {
                                case 0:
                                    c.call(e);
                                    break;
                                case 1:
                                    c.call(e, d[0]);
                                    break;
                                case 2:
                                    c.call(e, d[0], d[1]);
                                    break;
                                default:
                                    c.apply(e, d);
                            }
                        }),
                        (h.eventCallback = function (a, b, c, d) {
                            if ("on" === (a || "").substr(0, 2)) {
                                var e = this.vars;
                                if (1 === arguments.length) return e[a];
                                null == b ? delete e[a] : ((e[a] = b), (e[a + "Params"] = p(c) && -1 !== c.join("").indexOf("{self}") ? this._swapSelfInParams(c) : c), (e[a + "Scope"] = d)), "onUpdate" === a && (this._onUpdate = b);
                            }
                            return this;
                        }),
                        (h.delay = function (a) {
                            return arguments.length ? (this._timeline.smoothChildTiming && this.startTime(this._startTime + a - this._delay), (this._delay = a), this) : this._delay;
                        }),
                        (h.duration = function (a) {
                            return arguments.length
                                ? ((this._duration = this._totalDuration = a),
                                    this._uncache(!0),
                                    this._timeline.smoothChildTiming && this._time > 0 && this._time < this._duration && 0 !== a && this.totalTime(this._totalTime * (a / this._duration), !0),
                                    this)
                                : ((this._dirty = !1), this._duration);
                        }),
                        (h.totalDuration = function (a) {
                            return (this._dirty = !1), arguments.length ? this.duration(a) : this._totalDuration;
                        }),
                        (h.time = function (a, b) {
                            return arguments.length ? (this._dirty && this.totalDuration(), this.totalTime(a > this._duration ? this._duration : a, b)) : this._time;
                        }),
                        (h.totalTime = function (a, b, c) {
                            if ((j || i.wake(), !arguments.length)) return this._totalTime;
                            if (this._timeline) {
                                if ((0 > a && !c && (a += this.totalDuration()), this._timeline.smoothChildTiming)) {
                                    this._dirty && this.totalDuration();
                                    var d = this._totalDuration,
                                        e = this._timeline;
                                    if ((a > d && !c && (a = d), (this._startTime = (this._paused ? this._pauseTime : e._time) - (this._reversed ? d - a : a) / this._timeScale), e._dirty || this._uncache(!1), e._timeline))
                                        for (; e._timeline;) e._timeline._time !== (e._startTime + e._totalTime) / e._timeScale && e.totalTime(e._totalTime, !0), (e = e._timeline);
                                }
                                this._gc && this._enabled(!0, !1), (this._totalTime !== a || 0 === this._duration) && (J.length && Y(), this.render(a, b, !1), J.length && Y());
                            }
                            return this;
                        }),
                        (h.progress = h.totalProgress = function (a, b) {
                            var c = this.duration();
                            return arguments.length ? this.totalTime(c * a, b) : c ? this._time / c : this.ratio;
                        }),
                        (h.startTime = function (a) {
                            return arguments.length ? (a !== this._startTime && ((this._startTime = a), this.timeline && this.timeline._sortChildren && this.timeline.add(this, a - this._delay)), this) : this._startTime;
                        }),
                        (h.endTime = function (a) {
                            return this._startTime + (0 != a ? this.totalDuration() : this.duration()) / this._timeScale;
                        }),
                        (h.timeScale = function (a) {
                            if (!arguments.length) return this._timeScale;
                            if (((a = a || m), this._timeline && this._timeline.smoothChildTiming)) {
                                var b = this._pauseTime,
                                    c = b || 0 === b ? b : this._timeline.totalTime();
                                this._startTime = c - ((c - this._startTime) * this._timeScale) / a;
                            }
                            return (this._timeScale = a), this._uncache(!1);
                        }),
                        (h.reversed = function (a) {
                            return arguments.length
                                ? (a != this._reversed && ((this._reversed = a), this.totalTime(this._timeline && !this._timeline.smoothChildTiming ? this.totalDuration() - this._totalTime : this._totalTime, !0)), this)
                                : this._reversed;
                        }),
                        (h.paused = function (a) {
                            if (!arguments.length) return this._paused;
                            var b,
                                c,
                                d = this._timeline;
                            return (
                                a != this._paused &&
                                d &&
                                (j || a || i.wake(),
                                    (b = d.rawTime()),
                                    (c = b - this._pauseTime),
                                    !a && d.smoothChildTiming && ((this._startTime += c), this._uncache(!1)),
                                    (this._pauseTime = a ? b : null),
                                    (this._paused = a),
                                    (this._active = this.isActive()),
                                    !a && 0 !== c && this._initted && this.duration() && ((b = d.smoothChildTiming ? this._totalTime : (b - this._startTime) / this._timeScale), this.render(b, b === this._totalTime, !0))),
                                this._gc && !a && this._enabled(!0, !1),
                                this
                            );
                        });
                    var F = t("core.SimpleTimeline", function (a) {
                        D.call(this, 0, a), (this.autoRemoveChildren = this.smoothChildTiming = !0);
                    });
                    (h = F.prototype = new D()),
                        (h.constructor = F),
                        (h.kill()._gc = !1),
                        (h._first = h._last = h._recent = null),
                        (h._sortChildren = !1),
                        (h.add = h.insert = function (a, b, c, d) {
                            var e, f;
                            if (
                                ((a._startTime = Number(b || 0) + a._delay),
                                    a._paused && this !== a._timeline && (a._pauseTime = a._startTime + (this.rawTime() - a._startTime) / a._timeScale),
                                    a.timeline && a.timeline._remove(a, !0),
                                    (a.timeline = a._timeline = this),
                                    a._gc && a._enabled(!0, !0),
                                    (e = this._last),
                                    this._sortChildren)
                            )
                                for (f = a._startTime; e && e._startTime > f;) e = e._prev;
                            return (
                                e ? ((a._next = e._next), (e._next = a)) : ((a._next = this._first), (this._first = a)),
                                a._next ? (a._next._prev = a) : (this._last = a),
                                (a._prev = e),
                                (this._recent = a),
                                this._timeline && this._uncache(!0),
                                this
                            );
                        }),
                        (h._remove = function (a, b) {
                            return (
                                a.timeline === this &&
                                (b || a._enabled(!1, !0),
                                    a._prev ? (a._prev._next = a._next) : this._first === a && (this._first = a._next),
                                    a._next ? (a._next._prev = a._prev) : this._last === a && (this._last = a._prev),
                                    (a._next = a._prev = a.timeline = null),
                                    a === this._recent && (this._recent = this._last),
                                    this._timeline && this._uncache(!0)),
                                this
                            );
                        }),
                        (h.render = function (a, b, c) {
                            var d,
                                e = this._first;
                            for (this._totalTime = this._time = this._rawPrevTime = a; e;)
                                (d = e._next),
                                    (e._active || (a >= e._startTime && !e._paused)) &&
                                    (e._reversed ? e.render((e._dirty ? e.totalDuration() : e._totalDuration) - (a - e._startTime) * e._timeScale, b, c) : e.render((a - e._startTime) * e._timeScale, b, c)),
                                    (e = d);
                        }),
                        (h.rawTime = function () {
                            return j || i.wake(), this._totalTime;
                        });
                    var G = t(
                        "TweenLite",
                        function (b, c, d) {
                            if ((D.call(this, c, d), (this.render = G.prototype.render), null == b)) throw "Cannot tween a null target.";
                            this.target = b = "string" != typeof b ? b : G.selector(b) || b;
                            var e,
                                f,
                                g,
                                h = b.jquery || (b.length && b !== a && b[0] && (b[0] === a || (b[0].nodeType && b[0].style && !b.nodeType))),
                                i = this.vars.overwrite;
                            if (((this._overwrite = i = null == i ? U[G.defaultOverwrite] : "number" == typeof i ? i >> 0 : U[i]), (h || b instanceof Array || (b.push && p(b))) && "number" != typeof b[0]))
                                for (this._targets = g = n(b), this._propLookup = [], this._siblings = [], e = 0; e < g.length; e++)
                                    (f = g[e]),
                                        f
                                            ? "string" != typeof f
                                                ? f.length && f !== a && f[0] && (f[0] === a || (f[0].nodeType && f[0].style && !f.nodeType))
                                                    ? (g.splice(e--, 1), (this._targets = g = g.concat(n(f))))
                                                    : ((this._siblings[e] = Z(f, this, !1)), 1 === i && this._siblings[e].length > 1 && _(f, this, null, 1, this._siblings[e]))
                                                : ((f = g[e--] = G.selector(f)), "string" == typeof f && g.splice(e + 1, 1))
                                            : g.splice(e--, 1);
                            else (this._propLookup = {}), (this._siblings = Z(b, this, !1)), 1 === i && this._siblings.length > 1 && _(b, this, null, 1, this._siblings);
                            (this.vars.immediateRender || (0 === c && 0 === this._delay && this.vars.immediateRender !== !1)) && ((this._time = -m), this.render(Math.min(0, -this._delay)));
                        },
                        !0
                    ),
                        H = function (b) {
                            return b && b.length && b !== a && b[0] && (b[0] === a || (b[0].nodeType && b[0].style && !b.nodeType));
                        },
                        I = function (a, b) {
                            var c,
                                d = {};
                            for (c in a)
                                T[c] ||
                                    (c in b && "transform" !== c && "x" !== c && "y" !== c && "width" !== c && "height" !== c && "className" !== c && "border" !== c) ||
                                    !(!Q[c] || (Q[c] && Q[c]._autoCSS)) ||
                                    ((d[c] = a[c]), delete a[c]);
                            a.css = d;
                        };
                    (h = G.prototype = new D()),
                        (h.constructor = G),
                        (h.kill()._gc = !1),
                        (h.ratio = 0),
                        (h._firstPT = h._targets = h._overwrittenProps = h._startAt = null),
                        (h._notifyPluginsOfEnabled = h._lazy = !1),
                        (G.version = "1.19.1"),
                        (G.defaultEase = h._ease = new v(null, null, 1, 1)),
                        (G.defaultOverwrite = "auto"),
                        (G.ticker = i),
                        (G.autoSleep = 120),
                        (G.lagSmoothing = function (a, b) {
                            i.lagSmoothing(a, b);
                        }),
                        (G.selector =
                            a.$ ||
                            a.jQuery ||
                            function (b) {
                                var c = a.$ || a.jQuery;
                                return c ? ((G.selector = c), c(b)) : "undefined" == typeof d ? b : d.querySelectorAll ? d.querySelectorAll(b) : d.getElementById("#" === b.charAt(0) ? b.substr(1) : b);
                            });
                    var J = [],
                        K = {},
                        L = /(?:(-|-=|\+=)?\d*\.?\d*(?:e[\-+]?\d+)?)[0-9]/gi,
                        M = function (a) {
                            for (var b, c = this._firstPT, d = 1e-6; c;)
                                (b = c.blob ? (1 === a ? this.end : a ? this.join("") : this.start) : c.c * a + c.s),
                                    c.m ? (b = c.m(b, this._target || c.t)) : d > b && b > -d && !c.blob && (b = 0),
                                    c.f ? (c.fp ? c.t[c.p](c.fp, b) : c.t[c.p](b)) : (c.t[c.p] = b),
                                    (c = c._next);
                        },
                        N = function (a, b, c, d) {
                            var e,
                                f,
                                g,
                                h,
                                i,
                                j,
                                k,
                                l = [],
                                m = 0,
                                n = "",
                                o = 0;
                            for (
                                l.start = a,
                                l.end = b,
                                a = l[0] = a + "",
                                b = l[1] = b + "",
                                c && (c(l), (a = l[0]), (b = l[1])),
                                l.length = 0,
                                e = a.match(L) || [],
                                f = b.match(L) || [],
                                d && ((d._next = null), (d.blob = 1), (l._firstPT = l._applyPT = d)),
                                i = f.length,
                                h = 0;
                                i > h;
                                h++
                            )
                                (k = f[h]),
                                    (j = b.substr(m, b.indexOf(k, m) - m)),
                                    (n += j || !h ? j : ","),
                                    (m += j.length),
                                    o ? (o = (o + 1) % 5) : "rgba(" === j.substr(-5) && (o = 1),
                                    k === e[h] || e.length <= h
                                        ? (n += k)
                                        : (n && (l.push(n), (n = "")),
                                            (g = parseFloat(e[h])),
                                            l.push(g),
                                            (l._firstPT = {
                                                _next: l._firstPT,
                                                t: l,
                                                p: l.length - 1,
                                                s: g,
                                                c: ("=" === k.charAt(1) ? parseInt(k.charAt(0) + "1", 10) * parseFloat(k.substr(2)) : parseFloat(k) - g) || 0,
                                                f: 0,
                                                m: o && 4 > o ? Math.round : 0,
                                            })),
                                    (m += k.length);
                            return (n += b.substr(m)), n && l.push(n), (l.setRatio = M), l;
                        },
                        O = function (a, b, c, d, e, f, g, h, i) {
                            "function" == typeof d && (d = d(i || 0, a));
                            var j,
                                k = typeof a[b],
                                l = "function" !== k ? "" : b.indexOf("set") || "function" != typeof a["get" + b.substr(3)] ? b : "get" + b.substr(3),
                                m = "get" !== c ? c : l ? (g ? a[l](g) : a[l]()) : a[b],
                                n = "string" == typeof d && "=" === d.charAt(1),
                                o = {
                                    t: a,
                                    p: b,
                                    s: m,
                                    f: "function" === k,
                                    pg: 0,
                                    n: e || b,
                                    m: f ? ("function" == typeof f ? f : Math.round) : 0,
                                    pr: 0,
                                    c: n ? parseInt(d.charAt(0) + "1", 10) * parseFloat(d.substr(2)) : parseFloat(d) - m || 0,
                                };
                            return (
                                ("number" != typeof m || ("number" != typeof d && !n)) &&
                                (g || isNaN(m) || (!n && isNaN(d)) || "boolean" == typeof m || "boolean" == typeof d
                                    ? ((o.fp = g), (j = N(m, n ? o.s + o.c : d, h || G.defaultStringFilter, o)), (o = { t: j, p: "setRatio", s: 0, c: 1, f: 2, pg: 0, n: e || b, pr: 0, m: 0 }))
                                    : ((o.s = parseFloat(m)), n || (o.c = parseFloat(d) - o.s || 0))),
                                o.c ? ((o._next = this._firstPT) && (o._next._prev = o), (this._firstPT = o), o) : void 0
                            );
                        },
                        P = (G._internals = { isArray: p, isSelector: H, lazyTweens: J, blobDif: N }),
                        Q = (G._plugins = {}),
                        R = (P.tweenLookup = {}),
                        S = 0,
                        T = (P.reservedProps = {
                            ease: 1,
                            delay: 1,
                            overwrite: 1,
                            onComplete: 1,
                            onCompleteParams: 1,
                            onCompleteScope: 1,
                            useFrames: 1,
                            runBackwards: 1,
                            startAt: 1,
                            onUpdate: 1,
                            onUpdateParams: 1,
                            onUpdateScope: 1,
                            onStart: 1,
                            onStartParams: 1,
                            onStartScope: 1,
                            onReverseComplete: 1,
                            onReverseCompleteParams: 1,
                            onReverseCompleteScope: 1,
                            onRepeat: 1,
                            onRepeatParams: 1,
                            onRepeatScope: 1,
                            easeParams: 1,
                            yoyo: 1,
                            immediateRender: 1,
                            repeat: 1,
                            repeatDelay: 1,
                            data: 1,
                            paused: 1,
                            reversed: 1,
                            autoCSS: 1,
                            lazy: 1,
                            onOverwrite: 1,
                            callbackScope: 1,
                            stringFilter: 1,
                            id: 1,
                        }),
                        U = { none: 0, all: 1, auto: 2, concurrent: 3, allOnStart: 4, preexisting: 5, true: 1, false: 0 },
                        V = (D._rootFramesTimeline = new F()),
                        W = (D._rootTimeline = new F()),
                        X = 30,
                        Y = (P.lazyRender = function () {
                            var a,
                                b = J.length;
                            for (K = {}; --b > -1;) (a = J[b]), a && a._lazy !== !1 && (a.render(a._lazy[0], a._lazy[1], !0), (a._lazy = !1));
                            J.length = 0;
                        });
                    (W._startTime = i.time),
                        (V._startTime = i.frame),
                        (W._active = V._active = !0),
                        setTimeout(Y, 1),
                        (D._updateRoot = G.render = function () {
                            var a, b, c;
                            if ((J.length && Y(), W.render((i.time - W._startTime) * W._timeScale, !1, !1), V.render((i.frame - V._startTime) * V._timeScale, !1, !1), J.length && Y(), i.frame >= X)) {
                                X = i.frame + (parseInt(G.autoSleep, 10) || 120);
                                for (c in R) {
                                    for (b = R[c].tweens, a = b.length; --a > -1;) b[a]._gc && b.splice(a, 1);
                                    0 === b.length && delete R[c];
                                }
                                if (((c = W._first), (!c || c._paused) && G.autoSleep && !V._first && 1 === i._listeners.tick.length)) {
                                    for (; c && c._paused;) c = c._next;
                                    c || i.sleep();
                                }
                            }
                        }),
                        i.addEventListener("tick", D._updateRoot);
                    var Z = function (a, b, c) {
                        var d,
                            e,
                            f = a._gsTweenID;
                        if ((R[f || (a._gsTweenID = f = "t" + S++)] || (R[f] = { target: a, tweens: [] }), b && ((d = R[f].tweens), (d[(e = d.length)] = b), c))) for (; --e > -1;) d[e] === b && d.splice(e, 1);
                        return R[f].tweens;
                    },
                        $ = function (a, b, c, d) {
                            var e,
                                f,
                                g = a.vars.onOverwrite;
                            return g && (e = g(a, b, c, d)), (g = G.onOverwrite), g && (f = g(a, b, c, d)), e !== !1 && f !== !1;
                        },
                        _ = function (a, b, c, d, e) {
                            var f, g, h, i;
                            if (1 === d || d >= 4) {
                                for (i = e.length, f = 0; i > f; f++)
                                    if ((h = e[f]) !== b) h._gc || (h._kill(null, a, b) && (g = !0));
                                    else if (5 === d) break;
                                return g;
                            }
                            var j,
                                k = b._startTime + m,
                                l = [],
                                n = 0,
                                o = 0 === b._duration;
                            for (f = e.length; --f > -1;)
                                (h = e[f]) === b ||
                                    h._gc ||
                                    h._paused ||
                                    (h._timeline !== b._timeline
                                        ? ((j = j || aa(b, 0, o)), 0 === aa(h, j, o) && (l[n++] = h))
                                        : h._startTime <= k && h._startTime + h.totalDuration() / h._timeScale > k && (((o || !h._initted) && k - h._startTime <= 2e-10) || (l[n++] = h)));
                            for (f = n; --f > -1;)
                                if (((h = l[f]), 2 === d && h._kill(c, a, b) && (g = !0), 2 !== d || (!h._firstPT && h._initted))) {
                                    if (2 !== d && !$(h, b)) continue;
                                    h._enabled(!1, !1) && (g = !0);
                                }
                            return g;
                        },
                        aa = function (a, b, c) {
                            for (var d = a._timeline, e = d._timeScale, f = a._startTime; d._timeline;) {
                                if (((f += d._startTime), (e *= d._timeScale), d._paused)) return -100;
                                d = d._timeline;
                            }
                            return (f /= e), f > b ? f - b : (c && f === b) || (!a._initted && 2 * m > f - b) ? m : (f += a.totalDuration() / a._timeScale / e) > b + m ? 0 : f - b - m;
                        };
                    (h._init = function () {
                        var a,
                            b,
                            c,
                            d,
                            e,
                            f,
                            g = this.vars,
                            h = this._overwrittenProps,
                            i = this._duration,
                            j = !!g.immediateRender,
                            k = g.ease;
                        if (g.startAt) {
                            this._startAt && (this._startAt.render(-1, !0), this._startAt.kill()), (e = {});
                            for (d in g.startAt) e[d] = g.startAt[d];
                            if (((e.overwrite = !1), (e.immediateRender = !0), (e.lazy = j && g.lazy !== !1), (e.startAt = e.delay = null), (this._startAt = G.to(this.target, 0, e)), j))
                                if (this._time > 0) this._startAt = null;
                                else if (0 !== i) return;
                        } else if (g.runBackwards && 0 !== i)
                            if (this._startAt) this._startAt.render(-1, !0), this._startAt.kill(), (this._startAt = null);
                            else {
                                0 !== this._time && (j = !1), (c = {});
                                for (d in g) (T[d] && "autoCSS" !== d) || (c[d] = g[d]);
                                if (((c.overwrite = 0), (c.data = "isFromStart"), (c.lazy = j && g.lazy !== !1), (c.immediateRender = j), (this._startAt = G.to(this.target, 0, c)), j)) {
                                    if (0 === this._time) return;
                                } else this._startAt._init(), this._startAt._enabled(!1), this.vars.immediateRender && (this._startAt = null);
                            }
                        if (
                            ((this._ease = k = k ? (k instanceof v ? k : "function" == typeof k ? new v(k, g.easeParams) : w[k] || G.defaultEase) : G.defaultEase),
                                g.easeParams instanceof Array && k.config && (this._ease = k.config.apply(k, g.easeParams)),
                                (this._easeType = this._ease._type),
                                (this._easePower = this._ease._power),
                                (this._firstPT = null),
                                this._targets)
                        )
                            for (f = this._targets.length, a = 0; f > a; a++) this._initProps(this._targets[a], (this._propLookup[a] = {}), this._siblings[a], h ? h[a] : null, a) && (b = !0);
                        else b = this._initProps(this.target, this._propLookup, this._siblings, h, 0);
                        if ((b && G._onPluginEvent("_onInitAllProps", this), h && (this._firstPT || ("function" != typeof this.target && this._enabled(!1, !1))), g.runBackwards))
                            for (c = this._firstPT; c;) (c.s += c.c), (c.c = -c.c), (c = c._next);
                        (this._onUpdate = g.onUpdate), (this._initted = !0);
                    }),
                        (h._initProps = function (b, c, d, e, f) {
                            var g, h, i, j, k, l;
                            if (null == b) return !1;
                            K[b._gsTweenID] && Y(), this.vars.css || (b.style && b !== a && b.nodeType && Q.css && this.vars.autoCSS !== !1 && I(this.vars, b));
                            for (g in this.vars)
                                if (((l = this.vars[g]), T[g])) l && (l instanceof Array || (l.push && p(l))) && -1 !== l.join("").indexOf("{self}") && (this.vars[g] = l = this._swapSelfInParams(l, this));
                                else if (Q[g] && (j = new Q[g]())._onInitTween(b, this.vars[g], this, f)) {
                                    for (this._firstPT = k = { _next: this._firstPT, t: j, p: "setRatio", s: 0, c: 1, f: 1, n: g, pg: 1, pr: j._priority, m: 0 }, h = j._overwriteProps.length; --h > -1;)
                                        c[j._overwriteProps[h]] = this._firstPT;
                                    (j._priority || j._onInitAllProps) && (i = !0), (j._onDisable || j._onEnable) && (this._notifyPluginsOfEnabled = !0), k._next && (k._next._prev = k);
                                } else c[g] = O.call(this, b, g, "get", l, g, 0, null, this.vars.stringFilter, f);
                            return e && this._kill(e, b)
                                ? this._initProps(b, c, d, e, f)
                                : this._overwrite > 1 && this._firstPT && d.length > 1 && _(b, this, c, this._overwrite, d)
                                    ? (this._kill(c, b), this._initProps(b, c, d, e, f))
                                    : (this._firstPT && ((this.vars.lazy !== !1 && this._duration) || (this.vars.lazy && !this._duration)) && (K[b._gsTweenID] = !0), i);
                        }),
                        (h.render = function (a, b, c) {
                            var d,
                                e,
                                f,
                                g,
                                h = this._time,
                                i = this._duration,
                                j = this._rawPrevTime;
                            if (a >= i - 1e-7 && a >= 0)
                                (this._totalTime = this._time = i),
                                    (this.ratio = this._ease._calcEnd ? this._ease.getRatio(1) : 1),
                                    this._reversed || ((d = !0), (e = "onComplete"), (c = c || this._timeline.autoRemoveChildren)),
                                    0 === i &&
                                    (this._initted || !this.vars.lazy || c) &&
                                    (this._startTime === this._timeline._duration && (a = 0),
                                        (0 > j || (0 >= a && a >= -1e-7) || (j === m && "isPause" !== this.data)) && j !== a && ((c = !0), j > m && (e = "onReverseComplete")),
                                        (this._rawPrevTime = g = !b || a || j === a ? a : m));
                            else if (1e-7 > a)
                                (this._totalTime = this._time = 0),
                                    (this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0),
                                    (0 !== h || (0 === i && j > 0)) && ((e = "onReverseComplete"), (d = this._reversed)),
                                    0 > a && ((this._active = !1), 0 === i && (this._initted || !this.vars.lazy || c) && (j >= 0 && (j !== m || "isPause" !== this.data) && (c = !0), (this._rawPrevTime = g = !b || a || j === a ? a : m))),
                                    this._initted || (c = !0);
                            else if (((this._totalTime = this._time = a), this._easeType)) {
                                var k = a / i,
                                    l = this._easeType,
                                    n = this._easePower;
                                (1 === l || (3 === l && k >= 0.5)) && (k = 1 - k),
                                    3 === l && (k *= 2),
                                    1 === n ? (k *= k) : 2 === n ? (k *= k * k) : 3 === n ? (k *= k * k * k) : 4 === n && (k *= k * k * k * k),
                                    1 === l ? (this.ratio = 1 - k) : 2 === l ? (this.ratio = k) : 0.5 > a / i ? (this.ratio = k / 2) : (this.ratio = 1 - k / 2);
                            } else this.ratio = this._ease.getRatio(a / i);
                            if (this._time !== h || c) {
                                if (!this._initted) {
                                    if ((this._init(), !this._initted || this._gc)) return;
                                    if (!c && this._firstPT && ((this.vars.lazy !== !1 && this._duration) || (this.vars.lazy && !this._duration)))
                                        return (this._time = this._totalTime = h), (this._rawPrevTime = j), J.push(this), void (this._lazy = [a, b]);
                                    this._time && !d ? (this.ratio = this._ease.getRatio(this._time / i)) : d && this._ease._calcEnd && (this.ratio = this._ease.getRatio(0 === this._time ? 0 : 1));
                                }
                                for (
                                    this._lazy !== !1 && (this._lazy = !1),
                                    this._active || (!this._paused && this._time !== h && a >= 0 && (this._active = !0)),
                                    0 === h && (this._startAt && (a >= 0 ? this._startAt.render(a, b, c) : e || (e = "_dummyGS")), this.vars.onStart && (0 !== this._time || 0 === i) && (b || this._callback("onStart"))),
                                    f = this._firstPT;
                                    f;

                                )
                                    f.f ? f.t[f.p](f.c * this.ratio + f.s) : (f.t[f.p] = f.c * this.ratio + f.s), (f = f._next);
                                this._onUpdate && (0 > a && this._startAt && a !== -1e-4 && this._startAt.render(a, b, c), b || ((this._time !== h || d || c) && this._callback("onUpdate"))),
                                    e &&
                                    (!this._gc || c) &&
                                    (0 > a && this._startAt && !this._onUpdate && a !== -1e-4 && this._startAt.render(a, b, c),
                                        d && (this._timeline.autoRemoveChildren && this._enabled(!1, !1), (this._active = !1)),
                                        !b && this.vars[e] && this._callback(e),
                                        0 === i && this._rawPrevTime === m && g !== m && (this._rawPrevTime = 0));
                            }
                        }),
                        (h._kill = function (a, b, c) {
                            if (("all" === a && (a = null), null == a && (null == b || b === this.target))) return (this._lazy = !1), this._enabled(!1, !1);
                            b = "string" != typeof b ? b || this._targets || this.target : G.selector(b) || b;
                            var d,
                                e,
                                f,
                                g,
                                h,
                                i,
                                j,
                                k,
                                l,
                                m = c && this._time && c._startTime === this._startTime && this._timeline === c._timeline;
                            if ((p(b) || H(b)) && "number" != typeof b[0]) for (d = b.length; --d > -1;) this._kill(a, b[d], c) && (i = !0);
                            else {
                                if (this._targets) {
                                    for (d = this._targets.length; --d > -1;)
                                        if (b === this._targets[d]) {
                                            (h = this._propLookup[d] || {}), (this._overwrittenProps = this._overwrittenProps || []), (e = this._overwrittenProps[d] = a ? this._overwrittenProps[d] || {} : "all");
                                            break;
                                        }
                                } else {
                                    if (b !== this.target) return !1;
                                    (h = this._propLookup), (e = this._overwrittenProps = a ? this._overwrittenProps || {} : "all");
                                }
                                if (h) {
                                    if (((j = a || h), (k = a !== e && "all" !== e && a !== h && ("object" != typeof a || !a._tempKill)), c && (G.onOverwrite || this.vars.onOverwrite))) {
                                        for (f in j) h[f] && (l || (l = []), l.push(f));
                                        if ((l || !a) && !$(this, c, b, l)) return !1;
                                    }
                                    for (f in j)
                                        (g = h[f]) &&
                                            (m && (g.f ? g.t[g.p](g.s) : (g.t[g.p] = g.s), (i = !0)),
                                                g.pg && g.t._kill(j) && (i = !0),
                                                (g.pg && 0 !== g.t._overwriteProps.length) ||
                                                (g._prev ? (g._prev._next = g._next) : g === this._firstPT && (this._firstPT = g._next), g._next && (g._next._prev = g._prev), (g._next = g._prev = null)),
                                                delete h[f]),
                                            k && (e[f] = 1);
                                    !this._firstPT && this._initted && this._enabled(!1, !1);
                                }
                            }
                            return i;
                        }),
                        (h.invalidate = function () {
                            return (
                                this._notifyPluginsOfEnabled && G._onPluginEvent("_onDisable", this),
                                (this._firstPT = this._overwrittenProps = this._startAt = this._onUpdate = null),
                                (this._notifyPluginsOfEnabled = this._active = this._lazy = !1),
                                (this._propLookup = this._targets ? {} : []),
                                D.prototype.invalidate.call(this),
                                this.vars.immediateRender && ((this._time = -m), this.render(Math.min(0, -this._delay))),
                                this
                            );
                        }),
                        (h._enabled = function (a, b) {
                            if ((j || i.wake(), a && this._gc)) {
                                var c,
                                    d = this._targets;
                                if (d) for (c = d.length; --c > -1;) this._siblings[c] = Z(d[c], this, !0);
                                else this._siblings = Z(this.target, this, !0);
                            }
                            return D.prototype._enabled.call(this, a, b), this._notifyPluginsOfEnabled && this._firstPT ? G._onPluginEvent(a ? "_onEnable" : "_onDisable", this) : !1;
                        }),
                        (G.to = function (a, b, c) {
                            return new G(a, b, c);
                        }),
                        (G.from = function (a, b, c) {
                            return (c.runBackwards = !0), (c.immediateRender = 0 != c.immediateRender), new G(a, b, c);
                        }),
                        (G.fromTo = function (a, b, c, d) {
                            return (d.startAt = c), (d.immediateRender = 0 != d.immediateRender && 0 != c.immediateRender), new G(a, b, d);
                        }),
                        (G.delayedCall = function (a, b, c, d, e) {
                            return new G(b, 0, { delay: a, onComplete: b, onCompleteParams: c, callbackScope: d, onReverseComplete: b, onReverseCompleteParams: c, immediateRender: !1, lazy: !1, useFrames: e, overwrite: 0 });
                        }),
                        (G.set = function (a, b) {
                            return new G(a, 0, b);
                        }),
                        (G.getTweensOf = function (a, b) {
                            if (null == a) return [];
                            a = "string" != typeof a ? a : G.selector(a) || a;
                            var c, d, e, f;
                            if ((p(a) || H(a)) && "number" != typeof a[0]) {
                                for (c = a.length, d = []; --c > -1;) d = d.concat(G.getTweensOf(a[c], b));
                                for (c = d.length; --c > -1;) for (f = d[c], e = c; --e > -1;) f === d[e] && d.splice(c, 1);
                            } else for (d = Z(a).concat(), c = d.length; --c > -1;) (d[c]._gc || (b && !d[c].isActive())) && d.splice(c, 1);
                            return d;
                        }),
                        (G.killTweensOf = G.killDelayedCallsTo = function (a, b, c) {
                            "object" == typeof b && ((c = b), (b = !1));
                            for (var d = G.getTweensOf(a, b), e = d.length; --e > -1;) d[e]._kill(c, a);
                        });
                    var ba = t(
                        "plugins.TweenPlugin",
                        function (a, b) {
                            (this._overwriteProps = (a || "").split(",")), (this._propName = this._overwriteProps[0]), (this._priority = b || 0), (this._super = ba.prototype);
                        },
                        !0
                    );
                    if (
                        ((h = ba.prototype),
                            (ba.version = "1.19.0"),
                            (ba.API = 2),
                            (h._firstPT = null),
                            (h._addTween = O),
                            (h.setRatio = M),
                            (h._kill = function (a) {
                                var b,
                                    c = this._overwriteProps,
                                    d = this._firstPT;
                                if (null != a[this._propName]) this._overwriteProps = [];
                                else for (b = c.length; --b > -1;) null != a[c[b]] && c.splice(b, 1);
                                for (; d;) null != a[d.n] && (d._next && (d._next._prev = d._prev), d._prev ? ((d._prev._next = d._next), (d._prev = null)) : this._firstPT === d && (this._firstPT = d._next)), (d = d._next);
                                return !1;
                            }),
                            (h._mod = h._roundProps = function (a) {
                                for (var b, c = this._firstPT; c;)
                                    (b = a[this._propName] || (null != c.n && a[c.n.split(this._propName + "_").join("")])), b && "function" == typeof b && (2 === c.f ? (c.t._applyPT.m = b) : (c.m = b)), (c = c._next);
                            }),
                            (G._onPluginEvent = function (a, b) {
                                var c,
                                    d,
                                    e,
                                    f,
                                    g,
                                    h = b._firstPT;
                                if ("_onInitAllProps" === a) {
                                    for (; h;) {
                                        for (g = h._next, d = e; d && d.pr > h.pr;) d = d._next;
                                        (h._prev = d ? d._prev : f) ? (h._prev._next = h) : (e = h), (h._next = d) ? (d._prev = h) : (f = h), (h = g);
                                    }
                                    h = b._firstPT = e;
                                }
                                for (; h;) h.pg && "function" == typeof h.t[a] && h.t[a]() && (c = !0), (h = h._next);
                                return c;
                            }),
                            (ba.activate = function (a) {
                                for (var b = a.length; --b > -1;) a[b].API === ba.API && (Q[new a[b]()._propName] = a[b]);
                                return !0;
                            }),
                            (s.plugin = function (a) {
                                if (!(a && a.propName && a.init && a.API)) throw "illegal plugin definition.";
                                var b,
                                    c = a.propName,
                                    d = a.priority || 0,
                                    e = a.overwriteProps,
                                    f = { init: "_onInitTween", set: "setRatio", kill: "_kill", round: "_mod", mod: "_mod", initAll: "_onInitAllProps" },
                                    g = t(
                                        "plugins." + c.charAt(0).toUpperCase() + c.substr(1) + "Plugin",
                                        function () {
                                            ba.call(this, c, d), (this._overwriteProps = e || []);
                                        },
                                        a.global === !0
                                    ),
                                    h = (g.prototype = new ba(c));
                                (h.constructor = g), (g.API = a.API);
                                for (b in f) "function" == typeof a[b] && (h[f[b]] = a[b]);
                                return (g.version = a.version), ba.activate([g]), g;
                            }),
                            (f = a._gsQueue))
                    ) {
                        for (g = 0; g < f.length; g++) f[g]();
                        for (h in q) q[h].func || a.console.log("GSAP encountered missing dependency: " + h);
                    }
                    j = !1;
                }
            })("undefined" != "object" && module.exports && "undefined" != typeof commonjsGlobal ? commonjsGlobal : commonjsGlobal || window, "TweenMax");
    });
    function EventDispatcher() { }
    EventDispatcher.prototype = {
        listeners: {},
        listen: function (event, callback, scope) {
            if (typeof this.listeners[event] == "undefined") {
                this.listeners[event] = [];
            }
            this.listeners[event].push({ callback: callback, scope: scope });
        },
        dispatch: function (event, params) {
            if (typeof this.listeners[event] != "undefined") {
                for (var i = 0, l = this.listeners[event].length; i < l; ++i) {
                    var listener = this.listeners[event][i];
                    listener.callback.call(listener.scope || this, event, params);
                }
            }
        },
        removeListen: function (event, callback) {
            if (typeof this.listeners[event] != "undefined") {
                for (var i = 0, l = this.listeners[event].length; i < l; ++i) {
                    var listener = this.listeners[event][i];
                    if (callback === listener.callback) this.listeners[event].splice(i, 1);
                }
            }
        },
    };
    function MobileBrowser() {
        var ua = navigator.userAgent || navigator.vendor || window.opera;
        var test =
            /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od|ad)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(
                ua
            ) ||
            /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(
                ua.substr(0, 4)
            );
        var isAndroid = ua.indexOf("android") > -1;
        if (test) document.getElementsByTagName("HTML")[0].className = "mobile";
        return {
            get: function () {
                return test;
            },
            isAndorid: function () {
                return isAndroid;
            },
        };
    }
    var Events = {
        ADD_STATE: "addState",
        START_STATE: "startState",
        CHANGE_STATE: "changeState",
        REMOVE_STATE: "removeState",
        JOURNEY_COMPLETE: "journeyComplete",
        MENU_OPEN: "menuOpen",
        LEAF_OPEN: "leafOpen",
        LEAF_CLOSE: "leafClose",
        LEAF_PREV: "leafPrev",
        LEAF_NEXT: "leafNext",
        INPUT_WHEEL: "inputWheel",
        INPUT_START: "inputStart",
        INPUT_MOVE: "inputMove",
        INPUT_END: "inputEnd",
        INPUT_KEY: "inputKey",
        READY: "ready",
        UPDATE: "update",
        RENDER: "render",
        RESIZE: "resize",
    };
    function InputsControl(target) {
        this.delta = 0;
        this.mouse = {};
        this.target = target;
        this.mobile = new MobileBrowser().get();
        this.target.on("wheel", underscoreMin.bind(this.onWheel, this));
        this.target.on("mousewheel", underscoreMin.bind(this.onWheel, this));
        this.target.on("DOMMouseScroll", underscoreMin.bind(this.onWheel, this));
        this.target.on(this.mobile ? "touchstart" : "mousedown", underscoreMin.bind(this.onStart, this));
        this.target.on(this.mobile ? "touchmove" : "mousemove", underscoreMin.bind(this.onMove, this));
        this.target.on(this.mobile ? "touchend" : "mouseup", underscoreMin.bind(this.onEnd, this));
        this.target.on("mouseleave", underscoreMin.bind(this.onEnd, this));
        $(window).on("keyup", underscoreMin.bind(this.onKey, this));
    }
    InputsControl.prototype = {
        constructor: InputsControl,
        onWheel: function (e) {
            e.preventDefault();
            e.stopPropagation();
            var delta,
                speed = 20;
            if ("deltaX" in e.originalEvent) {
                if (e.originalEvent.deltaMode === 1) delta = -e.originalEvent.deltaY * speed;
                else delta = -e.originalEvent.deltaY;
            } else if ("wheelDeltaX" in e.originalEvent) delta = (e.originalEvent.delta / 120) * speed;
            else if ("wheelDelta" in e.originalEvent) delta = (e.originalEvent.wheelDelta / 120) * speed;
            else if ("detail" in e.originalEvent) delta = (-e.originalEvent.detail / 3) * speed;
            else return;
            this.delta = delta;
            this.dispatch(Events.INPUT_WHEEL, delta);
        },
        onStart: function (e) {
            this.mouse = this.getCoords(e);
            this.dispatch(Events.INPUT_START, { target: e.target, mouse: this.mouse });
        },
        onMove: function (e) {
            this.mouse = this.getCoords(e);
            this.dispatch(Events.INPUT_MOVE, { evt: e, target: e.target, mouse: this.mouse });
        },
        onEnd: function (e) {
            this.dispatch(Events.INPUT_END, { evt: e, target: e.target, mouse: this.mouse });
        },
        onKey: function (e) {
            this.dispatch(Events.INPUT_KEY, e.keyCode);
        },
        getCoords: function (e) {
            var x = e.originalEvent.touches ? e.originalEvent.touches[0].clientX : e.clientX,
                y = e.originalEvent.touches ? e.originalEvent.touches[0].clientY : e.clientY;
            return { x: x, y: y };
        },
    };
    Object.assign(InputsControl.prototype, EventDispatcher.prototype);
    function AppController($rootScope, $scope, $state, $urlRouter, $timeout, DataLoader, ChapterLoader) {
        $scope.store = { 
            
            loaded: false, 
            progress: 0, 
            intro: null,
            data: {} 
        };
        var scope = this,
            loader = {},
            control,
            stats,
            gui;
        function initialize() {
            control = new InputsControl($("#application"));
            $(window).on(Events.RESIZE, resize).trigger(Events.RESIZE);
            $timeout(function () {
                DataLoader.load(progress).then(complete);
            }, 600);
            $rootScope.$on("$stateChangeStart", onChangeState);
            scope.listen(Events.READY, ready);
            addStats();
            render();
        }
        function addStats() {
            stats = new Stats();
        }
        function progress(progress) {
            loader.assets = progress * 0.25;
            totalProgress();
        }
        function totalProgress() {
            var perc = 0;
            underscoreMin.each(loader, function (item) {
                perc += item;
            });
            $scope.store.progress = Math.round(perc * 100) / 100;
            $scope.$apply();
        }
        function complete(data) {
            var lang = $scope.store.lang;
            $scope.store.data = data;
            $scope.store.data.book = data.book[lang];
            $scope.store.data.params = data.params[lang];
            $scope.store.data.locale = data.locale[lang];
            $scope.store.data.contents = data.contents[lang];
            $scope.store.data.models = {};
            ChapterLoader.store($scope.store.data.book);
            ChapterLoader.load(
                $scope.store.initIndex,
                2,
                function (progress) {
                    loader.chapter = progress * 0.75;
                    totalProgress();
                },
                function (chunk) {
                    $scope.store.data.models[chunk.key] = chunk.response;
                    console.info(chunk.key, "COMPLETE");
                }
            ).then(function (models) {
                $scope.store.loaded = true;
            });
        }
        function ready() {
            scope.removeListen(Events.READY, ready);
            $scope.store.intro = true;
            $scope.changeChapter({});
            $scope.$apply();
        }
        function onChangeState(e, toState, toParams, fromState, fromParams, options) {
            $scope.store.lang = toParams.lang || "it";
            if (!$scope.store.loaded) {
                $scope.store.initIndex = getIndex(undefined, toParams.chapter);
                e.preventDefault();
                return false;
            } else if (!toParams.chapter && !$scope.store.intro) {
                e.preventDefault();
                return false;
            }
            options.index = getIndex(options.index, toParams.chapter);
            $scope.store.state = { to: toState, from: fromState, params: { to: toParams, from: fromParams }, options: options };
            $scope.store.intro = toState.name == "app.intro";
            $scope.store.lang = toParams.lang;
            scope.dispatch(Events.CHANGE_STATE, $scope.store.state);
        }
        function getIndex(index, chapter) {
            return underscoreMin.isUndefined(index) ? (chapter ? parseInt(chapter.split(/(\d+)/)[1]) - 1 : 0) : index;
        }
        function render() {
            requestAnimationFrame(render);
            scope.dispatch(Events.RENDER);
            if (stats) stats.update();
        }
        function resize() {
            var stagesize = { w: window.innerWidth, h: window.innerHeight, x: window.innerWidth / 2, y: window.innerHeight / 2 };
            scope.dispatch(Events.RESIZE, stagesize);
        }
        $scope.changeChapter = function (options) {
            var snap = options.snap,
                index = options.index,
                lang = $state.params.lang || $scope.store.lang,
                limit = window.temp_limit || $scope.store.data.book.length,
                chapter = "chapter-" + (index < 9 ? "0" : "") + (index + 1);
            if (underscoreMin.isUndefined(index)) $state.go("app.intro", { lang: lang });
            else if (index < limit) $state.go("app.chapter", { chapter: chapter, lang: lang }, { index: index, snap: snap });
            else if (index == limit && snap) scope.dispatch(Events.JOURNEY_COMPLETE);
            else return;
        };
        initialize();
    }
    Object.assign(AppController.prototype, EventDispatcher.prototype);
    THREE.EffectComposer = function (renderer, renderTarget) {
        this.renderer = renderer;
        if (renderTarget === undefined) {
            var parameters = { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBAFormat, stencilBuffer: false };
            var size = renderer.getSize();
            renderTarget = new THREE.WebGLRenderTarget(size.width, size.height, parameters);
        }
        this.renderTarget1 = renderTarget;
        this.renderTarget2 = renderTarget.clone();
        this.writeBuffer = this.renderTarget1;
        this.readBuffer = this.renderTarget2;
        this.passes = [];
        if (THREE.CopyShader === undefined) console.error("THREE.EffectComposer relies on THREE.CopyShader");
        this.copyPass = new THREE.ShaderPass(THREE.CopyShader);
    };
    Object.assign(THREE.EffectComposer.prototype, {
        swapBuffers: function () {
            var tmp = this.readBuffer;
            this.readBuffer = this.writeBuffer;
            this.writeBuffer = tmp;
        },
        addPass: function (pass) {
            this.passes.push(pass);
            var size = this.renderer.getSize();
            pass.setSize(size.width, size.height);
        },
        insertPass: function (pass, index) {
            this.passes.splice(index, 0, pass);
        },
        render: function (delta) {
            var maskActive = false;
            var pass,
                i,
                il = this.passes.length;
            for (i = 0; i < il; i++) {
                pass = this.passes[i];
                if (pass.enabled === false) continue;
                pass.render(this.renderer, this.writeBuffer, this.readBuffer, delta, maskActive);
                if (pass.needsSwap) {
                    if (maskActive) {
                        var context = this.renderer.context;
                        context.stencilFunc(context.NOTEQUAL, 1, 4294967295);
                        this.copyPass.render(this.renderer, this.writeBuffer, this.readBuffer, delta);
                        context.stencilFunc(context.EQUAL, 1, 4294967295);
                    }
                    this.swapBuffers();
                }
                if (THREE.MaskPass !== undefined) {
                    if (pass instanceof THREE.MaskPass) {
                        maskActive = true;
                    } else if (pass instanceof THREE.ClearMaskPass) {
                        maskActive = false;
                    }
                }
            }
        },
        reset: function (renderTarget) {
            if (renderTarget === undefined) {
                var size = this.renderer.getSize();
                renderTarget = this.renderTarget1.clone();
                renderTarget.setSize(size.width, size.height);
            }
            this.renderTarget1.dispose();
            this.renderTarget2.dispose();
            this.renderTarget1 = renderTarget;
            this.renderTarget2 = renderTarget.clone();
            this.writeBuffer = this.renderTarget1;
            this.readBuffer = this.renderTarget2;
        },
        setSize: function (width, height) {
            this.renderTarget1.setSize(width, height);
            this.renderTarget2.setSize(width, height);
            for (var i = 0; i < this.passes.length; i++) {
                this.passes[i].setSize(width, height);
            }
        },
    });
    THREE.Pass = function () {
        this.enabled = true;
        this.needsSwap = true;
        this.clear = false;
        this.renderToScreen = false;
    };
    Object.assign(THREE.Pass.prototype, {
        setSize: function (width, height) { },
        render: function (renderer, writeBuffer, readBuffer, delta, maskActive) {
            console.error("THREE.Pass: .render() must be implemented in derived pass.");
        },
    });
    THREE.RenderPass = function (scene, camera, overrideMaterial, clearColor, clearAlpha) {
        THREE.Pass.call(this);
        this.scene = scene;
        this.camera = camera;
        this.overrideMaterial = overrideMaterial;
        this.clearColor = clearColor;
        this.clearAlpha = clearAlpha !== undefined ? clearAlpha : 0;
        this.clear = true;
        this.clearDepth = false;
        this.needsSwap = false;
    };
    THREE.RenderPass.prototype = Object.assign(Object.create(THREE.Pass.prototype), {
        constructor: THREE.RenderPass,
        render: function (renderer, writeBuffer, readBuffer, delta, maskActive) {
            var oldAutoClear = renderer.autoClear;
            renderer.autoClear = false;
            this.scene.overrideMaterial = this.overrideMaterial;
            var oldClearColor, oldClearAlpha;
            if (this.clearColor) {
                oldClearColor = renderer.getClearColor().getHex();
                oldClearAlpha = renderer.getClearAlpha();
                renderer.setClearColor(this.clearColor, this.clearAlpha);
            }
            if (this.clearDepth) {
                renderer.clearDepth();
            }
            renderer.render(this.scene, this.camera, this.renderToScreen ? null : readBuffer, this.clear);
            if (this.clearColor) {
                renderer.setClearColor(oldClearColor, oldClearAlpha);
            }
            this.scene.overrideMaterial = null;
            renderer.autoClear = oldAutoClear;
        },
    });
    THREE.ShaderPass = function (shader, textureID) {
        THREE.Pass.call(this);
        this.textureID = textureID !== undefined ? textureID : "tDiffuse";
        if (shader instanceof THREE.ShaderMaterial) {
            this.uniforms = shader.uniforms;
            this.material = shader;
        } else if (shader) {
            this.uniforms = THREE.UniformsUtils.clone(shader.uniforms);
            this.material = new THREE.ShaderMaterial({ defines: shader.defines || {}, uniforms: this.uniforms, vertexShader: shader.vertexShader, fragmentShader: shader.fragmentShader });
        }
        this.camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
        this.scene = new THREE.Scene();
        this.quad = new THREE.Mesh(new THREE.PlaneBufferGeometry(2, 2), null);
        this.scene.add(this.quad);
    };
    THREE.ShaderPass.prototype = Object.assign(Object.create(THREE.Pass.prototype), {
        constructor: THREE.ShaderPass,
        render: function (renderer, writeBuffer, readBuffer, delta, maskActive) {
            if (this.uniforms[this.textureID]) {
                this.uniforms[this.textureID].value = readBuffer.texture;
            }
            this.quad.material = this.material;
            if (this.renderToScreen) {
                renderer.render(this.scene, this.camera);
            } else {
                renderer.render(this.scene, this.camera, writeBuffer, this.clear);
            }
        },
    });
    THREE.FilmPass = function (noiseIntensity, scanlinesIntensity, scanlinesCount, grayscale) {
        THREE.Pass.call(this);
        if (THREE.FilmShader === undefined) console.error("THREE.FilmPass relies on THREE.FilmShader");
        var shader = THREE.FilmShader;
        this.uniforms = THREE.UniformsUtils.clone(shader.uniforms);
        this.material = new THREE.ShaderMaterial({ uniforms: this.uniforms, vertexShader: shader.vertexShader, fragmentShader: shader.fragmentShader });
        if (grayscale !== undefined) this.uniforms.grayscale.value = grayscale;
        if (noiseIntensity !== undefined) this.uniforms.nIntensity.value = noiseIntensity;
        if (scanlinesIntensity !== undefined) this.uniforms.sIntensity.value = scanlinesIntensity;
        if (scanlinesCount !== undefined) this.uniforms.sCount.value = scanlinesCount;
        this.camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
        this.scene = new THREE.Scene();
        this.quad = new THREE.Mesh(new THREE.PlaneBufferGeometry(2, 2), null);
        this.scene.add(this.quad);
    };
    THREE.FilmPass.prototype = Object.assign(Object.create(THREE.Pass.prototype), {
        constructor: THREE.FilmPass,
        render: function (renderer, writeBuffer, readBuffer, delta, maskActive) {
            this.uniforms["tDiffuse"].value = readBuffer.texture;
            this.uniforms["time"].value += delta;
            this.quad.material = this.material;
            if (this.renderToScreen) {
                renderer.render(this.scene, this.camera);
            } else {
                renderer.render(this.scene, this.camera, writeBuffer, this.clear);
            }
        },
    });
    THREE.AdditiveBlendingShader = {
        uniforms: { tDiffuse: { value: null }, tAdd: { value: null } },
        vertexShader: ["varying vec2 vUv;", "void main() {", "vUv = uv;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
        fragmentShader: [
            "uniform sampler2D tDiffuse;",
            "uniform sampler2D tAdd;",
            "varying vec2 vUv;",
            "void main() {",
            "vec4 color = texture2D( tDiffuse, vUv );",
            "vec4 add = texture2D( tAdd, vUv );",
            "gl_FragColor = add - color;",
            "}",
        ].join("\n"),
    };
    THREE.VignetteShader = {
        uniforms: { tDiffuse: { value: null }, offset: { value: 1 }, darkness: { value: 1 } },
        vertexShader: ["varying vec2 vUv;", "void main() {", "vUv = uv;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
        fragmentShader: [
            "uniform float offset;",
            "uniform float darkness;",
            "uniform sampler2D tDiffuse;",
            "varying vec2 vUv;",
            "void main() {",
            "vec4 texel = texture2D( tDiffuse, vUv );",
            "vec2 uv = ( vUv - vec2( 0.5 ) ) * vec2( offset );",
            "gl_FragColor = vec4( mix( texel.rgb, vec3( 1.0 - darkness ), dot( uv, uv ) ), texel.a );",
            "}",
        ].join("\n"),
    };
    THREE.FilmShader = {
        uniforms: { tDiffuse: { value: null }, time: { value: 0 }, nIntensity: { value: 0.5 }, sIntensity: { value: 0.05 }, sCount: { value: 4096 }, grayscale: { value: 1 } },
        vertexShader: ["varying vec2 vUv;", "void main() {", "vUv = uv;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
        fragmentShader: [
            "#include <common>",
            "uniform float time;",
            "uniform bool grayscale;",
            "uniform float nIntensity;",
            "uniform float sIntensity;",
            "uniform float sCount;",
            "uniform sampler2D tDiffuse;",
            "varying vec2 vUv;",
            "void main() {",
            "vec4 cTextureScreen = texture2D( tDiffuse, vUv );",
            "float dx = rand( vUv + time );",
            "vec3 cResult = cTextureScreen.rgb + cTextureScreen.rgb * clamp( 0.1 + dx, 0.0, 1.0 );",
            "vec2 sc = vec2( sin( vUv.y * sCount ), cos( vUv.y * sCount ) );",
            "cResult += cTextureScreen.rgb * vec3( sc.x, sc.y, sc.x ) * sIntensity;",
            "cResult = cTextureScreen.rgb + clamp( nIntensity, 0.0,1.0 ) * ( cResult - cTextureScreen.rgb );",
            "if( grayscale ) {",
            "cResult = vec3( cResult.r * 0.3 + cResult.g * 0.59 + cResult.b * 0.11 );",
            "}",
            "gl_FragColor =  vec4( cResult, cTextureScreen.a );",
            "}",
        ].join("\n"),
    };
    THREE.CopyShader = {
        uniforms: { tDiffuse: { value: null }, opacity: { value: 1 } },
        vertexShader: ["varying vec2 vUv;", "void main() {", "vUv = uv;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
        fragmentShader: ["uniform float opacity;", "uniform sampler2D tDiffuse;", "varying vec2 vUv;", "void main() {", "vec4 texel = texture2D( tDiffuse, vUv );", "gl_FragColor = opacity * texel;", "}"].join("\n"),
    };
    var params = {
        debug: { drag: -90, angle: -Math.PI / 2, toggleColor: false, toggleHelpers: false, toggleCamera: false },
        controls: {
            statue: {
                twist: { turb: { ta: 0.01, tb: 0.1122, tc: 2.269, td: 2.5, te: 0.01, tf: 0.01 }, disp: { da: 0.01, db: 0.01, dc: 0.01, dd: 0.01, de: 0.01 } },
                transform: { translationX: 0, translationY: 0, translationZ: 0, rotationX: 0, rotationY: 0, rotationZ: 0, scaleX: 1, scaleY: 1, scaleZ: 1 },
                presets: { presetA: function () { }, reset: function () { } },
            },
            hotspots: {
                twist: { turb: { ta: 0.01, tb: 0.1122, tc: 2.269, td: 2.5, te: 0.01, tf: 0.01 }, disp: { da: 0.01, db: 0.01, dc: 0.01, dd: 0.01, de: 0.01 } },
                transform: { translationX: 0, translationY: 0, translationZ: 0, rotationX: 0, rotationY: 0, rotationZ: 0, scaleX: 1, scaleY: 1, scaleZ: 1 },
                flames: { noiseScale: 1.2, magnitude: 2.5, lacunarity: 0.35, scale: 0.1, gain: 0.9, blendEquation: 102, blendSrc: 201, blendDst: 205, opacity: 0.5 },
                colorAmmount: 0.5,
            },
        },
        post: { film: { nIntensity: 0.05, sIntensity: 0.85, filmActive: false }, dots: { dotsAngle: 90, dotsScale: 5, dotsActive: false }, active: true },
    };
    function Renderer3d(options) {
        var renderer, composers, renderpass, debugcamera, scenecamera, camerahelper, cameracount, camerasteps, cameranull, raycaster, controls, filters, camera, intro, scene;
        this.initialize = function (options) {
            intro = true;
            composers = [];
            cameracount = 0;
            var dpr = Math.floor(window.devicePixelRatio) || 1;
            renderer = new THREE.WebGLRenderer({ canvas: options.canvas, antialias: true });
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.setClearColor(16777215, 1);
            renderer.setSize(1280, 720);
            renderer.setPixelRatio(dpr);
            renderer.autoClear = true;
            scenecamera = new THREE.PerspectiveCamera(66, 1280 / 720, 0.4, 100);
            scenecamera.position.y = 3;
            debugcamera = new THREE.PerspectiveCamera(70, 1280 / 720, 0.1, 100);
            debugcamera.position.y = 1.5;
            debugcamera.position.z = 3.5;
            cameranull = new THREE.Vector3(0, 0, 0);
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(16777215, 2.85);
            raycaster = new THREE.Raycaster();
            renderpass = new THREE.RenderPass(scene, camera);
            composers[0] = new THREE.EffectComposer(renderer);
            composers[0].addPass(renderpass);
            this.addFilters();
        };
        this.addFilters = function () {
            filters = {};
            filters.film = new THREE.FilmPass(0, 0, 1024, false);
            filters.vignette = new THREE.ShaderPass(THREE.VignetteShader);
            filters.vignette.renderToScreen = true;
            composers[0].addPass(filters.film);
            composers[0].addPass(filters.vignette);
            this.post();
        };
        this.post = function () {
            filters.film.uniforms.nIntensity.value = params.post.film.nIntensity;
            filters.film.uniforms.sIntensity.value = params.post.film.sIntensity;
            filters.film.enabled = params.post.film.filmActive;
            filters.vignette.uniforms.darkness.value = 0;
            filters.vignette.uniforms.offset.value = 0;
        };
        this.append = function (child) {
            scene.add(child);
        };
        this.remove = function (child) {
            scene.remove(child);
        };
        this.reveal = function () {
            return new TimelineMax({ tweens: [TweenMax.to(scene.fog, 2.5, { density: 1.15, ease: Linear.easeInOut })], delay: 2 });
        };
        this.start = function () {
            return new TimelineMax({
                tweens: [
                    TweenMax.to(scene.fog, 3.25, { density: 0.175, ease: Linear.easeInOut }),
                    TweenMax.to({ count: 0, fov: 66 }, 6, {
                        count: 1,
                        fov: 36,
                        ease: Cubic.easeInOut,
                        onUpdate: function () {
                            cameracount = this.target.count;
                            scenecamera.fov = this.target.fov;
                            scenecamera.updateProjectionMatrix();
                        },
                    }),
                ],
                onComplete: function () {
                    intro = false;
                    clearCamcount();
                },
            });
        };
        this.spin = function () {
            return TweenMax.to({ count: 0 }, 5, {
                count: 1,
                ease: Cubic.easeInOut,
                onUpdate: function () {
                    cameracount = this.target.count;
                },
                onComplete: clearCamcount,
            });
        };
        this.move = function (angle) {
            cameracount = (angle + Math.PI / 2) / (Math.PI * 1.5);
        };
        this.render = function () {
            camera = params.debug.toggleCamera ? debugcamera : scenecamera;
            debugcamera.lookAt({ x: 0, y: 1, z: 0 });
            cameranull.y = intro ? 1.8 - cameracount * 0.58 : 1.22;
            renderpass.camera = camera;
            if (!params.post.active) renderer.render(scene, camera);
            else {
                composers[0].render(0.01);
            }
        };
        this.moveCamera = function (chapter) {
            scenecamera.position.copy(chapter.getSplinePointAt(cameracount, intro));
            scenecamera.up = new THREE.Vector3(0, 1, 0);
            scenecamera.lookAt(cameranull);
            var column, colpos, campos;
            for (var i = 0; i < chapter.columns.scene.children.length; ++i) {
                column = chapter.columns.scene.children[i];
                campos = camera.position;
                colpos = column.position;
                column.rotation.y = Math.atan2(campos.x - colpos.x, campos.z - colpos.z);
            }
        };
        this.getIntersects = function (coords, objects) {
            var intersects,
                mouse = { x: !coords ? 0 : (coords.x / window.innerWidth) * 2 - 1, y: !coords ? 0 : -(coords.y / window.innerHeight) * 2 + 1 };
            raycaster.setFromCamera(mouse, camera);
            intersects = raycaster.intersectObjects(objects, true);
            for (var i = 0; i < intersects.length; ++i) {
                var result = intersects[i];
                if (result) return result.object;
            }
            return false;
        };
        this.resize = function (stagesize) {
            var ratio = renderer.getPixelRatio();
            scenecamera.aspect = stagesize.w / stagesize.h;
            scenecamera.updateProjectionMatrix();
            debugcamera.aspect = stagesize.w / stagesize.h;
            debugcamera.updateProjectionMatrix();
            renderer.setSize(stagesize.w, stagesize.h);
            composers[0].setSize(stagesize.w * ratio, stagesize.h * ratio);
        };
        function clearCamcount() {
            cameracount = 0;
        }
        this.initialize(options);
    }
    function Renderer2d(options) {
        var renderer, scene;
        this.initialize = function (options) {
            var dpr = Math.floor(window.devicePixelRatio) || 1;
            renderer = new PIXI.CanvasRenderer(380, 380, { view: options.canvas, antialias: true, transparent: true, resolution: dpr });
            scene = new PIXI.Container();
        };
        this.append = function (child) {
            scene.addChild(child);
        };
        this.remove = function (child) {
            scene.removeChild(child);
        };
        this.render = function () {
            renderer.render(scene);
        };
        this.initialize(options);
    }
    function StateMachine() {
        this.state = undefined;
    }
    StateMachine.prototype = {
        constructor: StateMachine,
        setState: function (state) {
            if (!state.to) return;
            if (underscoreMin.isUndefined(this.state)) {
                this.state = state;
                this.addState(state);
                return;
            }
            if (state.params.to.chapter != this.state.params.to.chapter) {
                if (underscoreMin.isUndefined(this.state.params.to.chapter)) {
                    this.state = state;
                    this.startState(state);
                    return;
                }
                this.removeState(this.state);
                this.state = state;
            }
            this.addState(state);
        },
        startState: function (state) {
            this.dispatch(Events.START_STATE, state);
        },
        addState: function (state) {
            this.dispatch(Events.ADD_STATE, state);
        },
        removeState: function (state) {
            this.dispatch(Events.REMOVE_STATE, state);
        },
    };
    Object.assign(StateMachine.prototype, EventDispatcher.prototype);
    var iscroll = createCommonjsModule(function (module) {
        (function (window, document, Math) {
            var rAF =
                window.requestAnimationFrame ||
                window.webkitRequestAnimationFrame ||
                window.mozRequestAnimationFrame ||
                window.oRequestAnimationFrame ||
                window.msRequestAnimationFrame ||
                function (callback) {
                    window.setTimeout(callback, 1e3 / 60);
                };
            var utils = (function () {
                var me = {};
                var _elementStyle = document.createElement("div").style;
                var _vendor = (function () {
                    var vendors = ["t", "webkitT", "MozT", "msT", "OT"],
                        transform,
                        i = 0,
                        l = vendors.length;
                    for (; i < l; i++) {
                        transform = vendors[i] + "ransform";
                        if (transform in _elementStyle) return vendors[i].substr(0, vendors[i].length - 1);
                    }
                    return false;
                })();
                function _prefixStyle(style) {
                    if (_vendor === false) return false;
                    if (_vendor === "") return style;
                    return _vendor + style.charAt(0).toUpperCase() + style.substr(1);
                }
                me.getTime =
                    Date.now ||
                    function getTime() {
                        return new Date().getTime();
                    };
                me.extend = function (target, obj) {
                    for (var i in obj) {
                        target[i] = obj[i];
                    }
                };
                me.addEvent = function (el, type, fn, capture) {
                    el.addEventListener(type, fn, !!capture);
                };
                me.removeEvent = function (el, type, fn, capture) {
                    el.removeEventListener(type, fn, !!capture);
                };
                me.prefixPointerEvent = function (pointerEvent) {
                    return window.MSPointerEvent ? "MSPointer" + pointerEvent.charAt(7).toUpperCase() + pointerEvent.substr(8) : pointerEvent;
                };
                me.momentum = function (current, start, time, lowerMargin, wrapperSize, deceleration) {
                    var distance = current - start,
                        speed = Math.abs(distance) / time,
                        destination,
                        duration;
                    deceleration = deceleration === undefined ? 6e-4 : deceleration;
                    destination = current + ((speed * speed) / (2 * deceleration)) * (distance < 0 ? -1 : 1);
                    duration = speed / deceleration;
                    if (destination < lowerMargin) {
                        destination = wrapperSize ? lowerMargin - (wrapperSize / 2.5) * (speed / 8) : lowerMargin;
                        distance = Math.abs(destination - current);
                        duration = distance / speed;
                    } else if (destination > 0) {
                        destination = wrapperSize ? (wrapperSize / 2.5) * (speed / 8) : 0;
                        distance = Math.abs(current) + destination;
                        duration = distance / speed;
                    }
                    return { destination: Math.round(destination), duration: duration };
                };
                var _transform = _prefixStyle("transform");
                me.extend(me, {
                    hasTransform: _transform !== false,
                    hasPerspective: _prefixStyle("perspective") in _elementStyle,
                    hasTouch: "ontouchstart" in window,
                    hasPointer: !!(window.PointerEvent || window.MSPointerEvent),
                    hasTransition: _prefixStyle("transition") in _elementStyle,
                });
                me.isBadAndroid = (function () {
                    var appVersion = window.navigator.appVersion;
                    if (/Android/.test(appVersion) && !/Chrome\/\d/.test(appVersion)) {
                        var safariVersion = appVersion.match(/Safari\/(\d+.\d)/);
                        if (safariVersion && typeof safariVersion === "object" && safariVersion.length >= 2) {
                            return parseFloat(safariVersion[1]) < 535.19;
                        } else {
                            return true;
                        }
                    } else {
                        return false;
                    }
                })();
                me.extend((me.style = {}), {
                    transform: _transform,
                    transitionTimingFunction: _prefixStyle("transitionTimingFunction"),
                    transitionDuration: _prefixStyle("transitionDuration"),
                    transitionDelay: _prefixStyle("transitionDelay"),
                    transformOrigin: _prefixStyle("transformOrigin"),
                });
                me.hasClass = function (e, c) {
                    var re = new RegExp("(^|\\s)" + c + "(\\s|$)");
                    return re.test(e.className);
                };
                me.addClass = function (e, c) {
                    if (me.hasClass(e, c)) {
                        return;
                    }
                    var newclass = e.className.split(" ");
                    newclass.push(c);
                    e.className = newclass.join(" ");
                };
                me.removeClass = function (e, c) {
                    if (!me.hasClass(e, c)) {
                        return;
                    }
                    var re = new RegExp("(^|\\s)" + c + "(\\s|$)", "g");
                    e.className = e.className.replace(re, " ");
                };
                me.offset = function (el) {
                    var left = -el.offsetLeft,
                        top = -el.offsetTop;
                    while ((el = el.offsetParent)) {
                        left -= el.offsetLeft;
                        top -= el.offsetTop;
                    }
                    return { left: left, top: top };
                };
                me.preventDefaultException = function (el, exceptions) {
                    for (var i in exceptions) {
                        if (exceptions[i].test(el[i])) {
                            return true;
                        }
                    }
                    return false;
                };
                me.extend((me.eventType = {}), { touchstart: 1, touchmove: 1, touchend: 1, mousedown: 2, mousemove: 2, mouseup: 2, pointerdown: 3, pointermove: 3, pointerup: 3, MSPointerDown: 3, MSPointerMove: 3, MSPointerUp: 3 });
                me.extend((me.ease = {}), {
                    quadratic: {
                        style: "cubic-bezier(0.25, 0.46, 0.45, 0.94)",
                        fn: function (k) {
                            return k * (2 - k);
                        },
                    },
                    circular: {
                        style: "cubic-bezier(0.1, 0.57, 0.1, 1)",
                        fn: function (k) {
                            return Math.sqrt(1 - --k * k);
                        },
                    },
                    back: {
                        style: "cubic-bezier(0.175, 0.885, 0.32, 1.275)",
                        fn: function (k) {
                            var b = 4;
                            return (k = k - 1) * k * ((b + 1) * k + b) + 1;
                        },
                    },
                    bounce: {
                        style: "",
                        fn: function (k) {
                            if ((k /= 1) < 1 / 2.75) {
                                return 7.5625 * k * k;
                            } else if (k < 2 / 2.75) {
                                return 7.5625 * (k -= 1.5 / 2.75) * k + 0.75;
                            } else if (k < 2.5 / 2.75) {
                                return 7.5625 * (k -= 2.25 / 2.75) * k + 0.9375;
                            } else {
                                return 7.5625 * (k -= 2.625 / 2.75) * k + 0.984375;
                            }
                        },
                    },
                    elastic: {
                        style: "",
                        fn: function (k) {
                            var f = 0.22,
                                e = 0.4;
                            if (k === 0) {
                                return 0;
                            }
                            if (k == 1) {
                                return 1;
                            }
                            return e * Math.pow(2, -10 * k) * Math.sin(((k - f / 4) * (2 * Math.PI)) / f) + 1;
                        },
                    },
                });
                me.tap = function (e, eventName) {
                    var ev = document.createEvent("Event");
                    ev.initEvent(eventName, true, true);
                    ev.pageX = e.pageX;
                    ev.pageY = e.pageY;
                    e.target.dispatchEvent(ev);
                };
                me.click = function (e) {
                    var target = e.target,
                        ev;
                    if (!/(SELECT|INPUT|TEXTAREA)/i.test(target.tagName)) {
                        ev = document.createEvent("MouseEvents");
                        ev.initMouseEvent("click", true, true, e.view, 1, target.screenX, target.screenY, target.clientX, target.clientY, e.ctrlKey, e.altKey, e.shiftKey, e.metaKey, 0, null);
                        ev._constructed = true;
                        target.dispatchEvent(ev);
                    }
                };
                return me;
            })();
            function IScroll(el, options) {
                this.wrapper = typeof el == "string" ? document.querySelector(el) : el;
                this.scroller = this.wrapper.children[0];
                this.scrollerStyle = this.scroller.style;
                this.options = {
                    resizeScrollbars: true,
                    mouseWheelSpeed: 20,
                    snapThreshold: 0.334,
                    disablePointer: !utils.hasPointer,
                    disableTouch: utils.hasPointer || !utils.hasTouch,
                    disableMouse: utils.hasPointer || utils.hasTouch,
                    startX: 0,
                    startY: 0,
                    scrollY: true,
                    directionLockThreshold: 5,
                    momentum: true,
                    bounce: true,
                    bounceTime: 600,
                    bounceEasing: "",
                    preventDefault: true,
                    preventDefaultException: { tagName: /^(INPUT|TEXTAREA|BUTTON|SELECT)$/ },
                    HWCompositing: true,
                    useTransition: true,
                    useTransform: true,
                    bindToWrapper: typeof window.onmousedown === "undefined",
                };
                for (var i in options) {
                    this.options[i] = options[i];
                }
                this.translateZ = this.options.HWCompositing && utils.hasPerspective ? " translateZ(0)" : "";
                this.options.useTransition = utils.hasTransition && this.options.useTransition;
                this.options.useTransform = utils.hasTransform && this.options.useTransform;
                this.options.eventPassthrough = this.options.eventPassthrough === true ? "vertical" : this.options.eventPassthrough;
                this.options.preventDefault = !this.options.eventPassthrough && this.options.preventDefault;
                this.options.scrollY = this.options.eventPassthrough == "vertical" ? false : this.options.scrollY;
                this.options.scrollX = this.options.eventPassthrough == "horizontal" ? false : this.options.scrollX;
                this.options.freeScroll = this.options.freeScroll && !this.options.eventPassthrough;
                this.options.directionLockThreshold = this.options.eventPassthrough ? 0 : this.options.directionLockThreshold;
                this.options.bounceEasing = typeof this.options.bounceEasing == "string" ? utils.ease[this.options.bounceEasing] || utils.ease.circular : this.options.bounceEasing;
                this.options.resizePolling = this.options.resizePolling === undefined ? 60 : this.options.resizePolling;
                if (this.options.tap === true) {
                    this.options.tap = "tap";
                }
                if (this.options.shrinkScrollbars == "scale") {
                    this.options.useTransition = false;
                }
                this.options.invertWheelDirection = this.options.invertWheelDirection ? -1 : 1;
                this.x = 0;
                this.y = 0;
                this.directionX = 0;
                this.directionY = 0;
                this._events = {};
                this._init();
                this.refresh();
                this.scrollTo(this.options.startX, this.options.startY);
                this.enable();
            }
            IScroll.prototype = {
                version: "5.2.0",
                _init: function () {
                    this._initEvents();
                    if (this.options.scrollbars || this.options.indicators) {
                        this._initIndicators();
                    }
                    if (this.options.mouseWheel) {
                        this._initWheel();
                    }
                    if (this.options.snap) {
                        this._initSnap();
                    }
                    if (this.options.keyBindings) {
                        this._initKeys();
                    }
                },
                destroy: function () {
                    this._initEvents(true);
                    clearTimeout(this.resizeTimeout);
                    this.resizeTimeout = null;
                    this._execEvent("destroy");
                },
                _transitionEnd: function (e) {
                    if (e.target != this.scroller || !this.isInTransition) {
                        return;
                    }
                    this._transitionTime();
                    if (!this.resetPosition(this.options.bounceTime)) {
                        this.isInTransition = false;
                        this._execEvent("scrollEnd");
                    }
                },
                _start: function (e) {
                    if (utils.eventType[e.type] != 1) {
                        var button;
                        if (!e.which) {
                            button = e.button < 2 ? 0 : e.button == 4 ? 1 : 2;
                        } else {
                            button = e.button;
                        }
                        if (button !== 0) {
                            return;
                        }
                    }
                    if (!this.enabled || (this.initiated && utils.eventType[e.type] !== this.initiated)) {
                        return;
                    }
                    if (this.options.preventDefault && !utils.isBadAndroid && !utils.preventDefaultException(e.target, this.options.preventDefaultException)) {
                        e.preventDefault();
                    }
                    var point = e.touches ? e.touches[0] : e,
                        pos;
                    this.initiated = utils.eventType[e.type];
                    this.moved = false;
                    this.distX = 0;
                    this.distY = 0;
                    this.directionX = 0;
                    this.directionY = 0;
                    this.directionLocked = 0;
                    this.startTime = utils.getTime();
                    if (this.options.useTransition && this.isInTransition) {
                        this._transitionTime();
                        this.isInTransition = false;
                        pos = this.getComputedPosition();
                        this._translate(Math.round(pos.x), Math.round(pos.y));
                        this._execEvent("scrollEnd");
                    } else if (!this.options.useTransition && this.isAnimating) {
                        this.isAnimating = false;
                        this._execEvent("scrollEnd");
                    }
                    this.startX = this.x;
                    this.startY = this.y;
                    this.absStartX = this.x;
                    this.absStartY = this.y;
                    this.pointX = point.pageX;
                    this.pointY = point.pageY;
                    this._execEvent("beforeScrollStart");
                },
                _move: function (e) {
                    if (!this.enabled || utils.eventType[e.type] !== this.initiated) {
                        return;
                    }
                    if (this.options.preventDefault) {
                        e.preventDefault();
                    }
                    var point = e.touches ? e.touches[0] : e,
                        deltaX = point.pageX - this.pointX,
                        deltaY = point.pageY - this.pointY,
                        timestamp = utils.getTime(),
                        newX,
                        newY,
                        absDistX,
                        absDistY;
                    this.pointX = point.pageX;
                    this.pointY = point.pageY;
                    this.distX += deltaX;
                    this.distY += deltaY;
                    absDistX = Math.abs(this.distX);
                    absDistY = Math.abs(this.distY);
                    if (timestamp - this.endTime > 300 && absDistX < 10 && absDistY < 10) {
                        return;
                    }
                    if (!this.directionLocked && !this.options.freeScroll) {
                        if (absDistX > absDistY + this.options.directionLockThreshold) {
                            this.directionLocked = "h";
                        } else if (absDistY >= absDistX + this.options.directionLockThreshold) {
                            this.directionLocked = "v";
                        } else {
                            this.directionLocked = "n";
                        }
                    }
                    if (this.directionLocked == "h") {
                        if (this.options.eventPassthrough == "vertical") {
                            e.preventDefault();
                        } else if (this.options.eventPassthrough == "horizontal") {
                            this.initiated = false;
                            return;
                        }
                        deltaY = 0;
                    } else if (this.directionLocked == "v") {
                        if (this.options.eventPassthrough == "horizontal") {
                            e.preventDefault();
                        } else if (this.options.eventPassthrough == "vertical") {
                            this.initiated = false;
                            return;
                        }
                        deltaX = 0;
                    }
                    deltaX = this.hasHorizontalScroll ? deltaX : 0;
                    deltaY = this.hasVerticalScroll ? deltaY : 0;
                    newX = this.x + deltaX;
                    newY = this.y + deltaY;
                    if (newX > 0 || newX < this.maxScrollX) {
                        newX = this.options.bounce ? this.x + deltaX / 3 : newX > 0 ? 0 : this.maxScrollX;
                    }
                    if (newY > 0 || newY < this.maxScrollY) {
                        newY = this.options.bounce ? this.y + deltaY / 3 : newY > 0 ? 0 : this.maxScrollY;
                    }
                    this.directionX = deltaX > 0 ? -1 : deltaX < 0 ? 1 : 0;
                    this.directionY = deltaY > 0 ? -1 : deltaY < 0 ? 1 : 0;
                    if (!this.moved) {
                        this._execEvent("scrollStart");
                    }
                    this.moved = true;
                    this._translate(newX, newY);
                    if (timestamp - this.startTime > 300) {
                        this.startTime = timestamp;
                        this.startX = this.x;
                        this.startY = this.y;
                    }
                },
                _end: function (e) {
                    if (!this.enabled || utils.eventType[e.type] !== this.initiated) {
                        return;
                    }
                    if (this.options.preventDefault && !utils.preventDefaultException(e.target, this.options.preventDefaultException)) {
                        e.preventDefault();
                    }
                    var point = e.changedTouches ? e.changedTouches[0] : e,
                        momentumX,
                        momentumY,
                        duration = utils.getTime() - this.startTime,
                        newX = Math.round(this.x),
                        newY = Math.round(this.y),
                        distanceX = Math.abs(newX - this.startX),
                        distanceY = Math.abs(newY - this.startY),
                        time = 0,
                        easing = "";
                    this.isInTransition = 0;
                    this.initiated = 0;
                    this.endTime = utils.getTime();
                    if (this.resetPosition(this.options.bounceTime)) {
                        return;
                    }
                    this.scrollTo(newX, newY);
                    if (!this.moved) {
                        if (this.options.tap) {
                            utils.tap(e, this.options.tap);
                        }
                        if (this.options.click) {
                            utils.click(e);
                        }
                        this._execEvent("scrollCancel");
                        return;
                    }
                    if (this._events.flick && duration < 200 && distanceX < 100 && distanceY < 100) {
                        this._execEvent("flick");
                        return;
                    }
                    if (this.options.momentum && duration < 300) {
                        momentumX = this.hasHorizontalScroll ? utils.momentum(this.x, this.startX, duration, this.maxScrollX, this.options.bounce ? this.wrapperWidth : 0, this.options.deceleration) : { destination: newX, duration: 0 };
                        momentumY = this.hasVerticalScroll ? utils.momentum(this.y, this.startY, duration, this.maxScrollY, this.options.bounce ? this.wrapperHeight : 0, this.options.deceleration) : { destination: newY, duration: 0 };
                        newX = momentumX.destination;
                        newY = momentumY.destination;
                        time = Math.max(momentumX.duration, momentumY.duration);
                        this.isInTransition = 1;
                    }
                    if (this.options.snap) {
                        var snap = this._nearestSnap(newX, newY);
                        this.currentPage = snap;
                        time = this.options.snapSpeed || Math.max(Math.max(Math.min(Math.abs(newX - snap.x), 1e3), Math.min(Math.abs(newY - snap.y), 1e3)), 300);
                        newX = snap.x;
                        newY = snap.y;
                        this.directionX = 0;
                        this.directionY = 0;
                        easing = this.options.bounceEasing;
                    }
                    if (newX != this.x || newY != this.y) {
                        if (newX > 0 || newX < this.maxScrollX || newY > 0 || newY < this.maxScrollY) {
                            easing = utils.ease.quadratic;
                        }
                        this.scrollTo(newX, newY, time, easing);
                        return;
                    }
                    this._execEvent("scrollEnd");
                },
                _resize: function () {
                    var that = this;
                    clearTimeout(this.resizeTimeout);
                    this.resizeTimeout = setTimeout(function () {
                        that.refresh();
                    }, this.options.resizePolling);
                },
                resetPosition: function (time) {
                    var x = this.x,
                        y = this.y;
                    time = time || 0;
                    if (!this.hasHorizontalScroll || this.x > 0) {
                        x = 0;
                    } else if (this.x < this.maxScrollX) {
                        x = this.maxScrollX;
                    }
                    if (!this.hasVerticalScroll || this.y > 0) {
                        y = 0;
                    } else if (this.y < this.maxScrollY) {
                        y = this.maxScrollY;
                    }
                    if (x == this.x && y == this.y) {
                        return false;
                    }
                    this.scrollTo(x, y, time, this.options.bounceEasing);
                    return true;
                },
                disable: function () {
                    this.enabled = false;
                },
                enable: function () {
                    this.enabled = true;
                },
                refresh: function () {
                    var rf = this.wrapper.offsetHeight;
                    this.wrapperWidth = this.wrapper.clientWidth;
                    this.wrapperHeight = this.wrapper.clientHeight;
                    this.scrollerWidth = this.scroller.offsetWidth;
                    this.scrollerHeight = this.scroller.offsetHeight;
                    this.maxScrollX = this.wrapperWidth - this.scrollerWidth;
                    this.maxScrollY = this.wrapperHeight - this.scrollerHeight;
                    this.hasHorizontalScroll = this.options.scrollX && this.maxScrollX < 0;
                    this.hasVerticalScroll = this.options.scrollY && this.maxScrollY < 0;
                    if (!this.hasHorizontalScroll) {
                        this.maxScrollX = 0;
                        this.scrollerWidth = this.wrapperWidth;
                    }
                    if (!this.hasVerticalScroll) {
                        this.maxScrollY = 0;
                        this.scrollerHeight = this.wrapperHeight;
                    }
                    this.endTime = 0;
                    this.directionX = 0;
                    this.directionY = 0;
                    this.wrapperOffset = utils.offset(this.wrapper);
                    this._execEvent("refresh");
                    this.resetPosition();
                },
                on: function (type, fn) {
                    if (!this._events[type]) {
                        this._events[type] = [];
                    }
                    this._events[type].push(fn);
                },
                off: function (type, fn) {
                    if (!this._events[type]) {
                        return;
                    }
                    var index = this._events[type].indexOf(fn);
                    if (index > -1) {
                        this._events[type].splice(index, 1);
                    }
                },
                _execEvent: function (type) {
                    if (!this._events[type]) {
                        return;
                    }
                    var i = 0,
                        l = this._events[type].length;
                    if (!l) {
                        return;
                    }
                    for (; i < l; i++) {
                        this._events[type][i].apply(this, [].slice.call(arguments, 1));
                    }
                },
                scrollBy: function (x, y, time, easing) {
                    x = this.x + x;
                    y = this.y + y;
                    time = time || 0;
                    this.scrollTo(x, y, time, easing);
                },
                scrollTo: function (x, y, time, easing) {
                    easing = easing || utils.ease.circular;
                    this.isInTransition = this.options.useTransition && time > 0;
                    var transitionType = this.options.useTransition && easing.style;
                    if (!time || transitionType) {
                        if (transitionType) {
                            this._transitionTimingFunction(easing.style);
                            this._transitionTime(time);
                        }
                        this._translate(x, y);
                    } else {
                        this._animate(x, y, time, easing.fn);
                    }
                },
                scrollToElement: function (el, time, offsetX, offsetY, easing) {
                    el = el.nodeType ? el : this.scroller.querySelector(el);
                    if (!el) {
                        return;
                    }
                    var pos = utils.offset(el);
                    pos.left -= this.wrapperOffset.left;
                    pos.top -= this.wrapperOffset.top;
                    if (offsetX === true) {
                        offsetX = Math.round(el.offsetWidth / 2 - this.wrapper.offsetWidth / 2);
                    }
                    if (offsetY === true) {
                        offsetY = Math.round(el.offsetHeight / 2 - this.wrapper.offsetHeight / 2);
                    }
                    pos.left -= offsetX || 0;
                    pos.top -= offsetY || 0;
                    pos.left = pos.left > 0 ? 0 : pos.left < this.maxScrollX ? this.maxScrollX : pos.left;
                    pos.top = pos.top > 0 ? 0 : pos.top < this.maxScrollY ? this.maxScrollY : pos.top;
                    time = time === undefined || time === null || time === "auto" ? Math.max(Math.abs(this.x - pos.left), Math.abs(this.y - pos.top)) : time;
                    this.scrollTo(pos.left, pos.top, time, easing);
                },
                _transitionTime: function (time) {
                    time = time || 0;
                    var durationProp = utils.style.transitionDuration;
                    this.scrollerStyle[durationProp] = time + "ms";
                    if (!time && utils.isBadAndroid) {
                        this.scrollerStyle[durationProp] = "0.0001ms";
                        var self = this;
                        rAF(function () {
                            if (self.scrollerStyle[durationProp] === "0.0001ms") {
                                self.scrollerStyle[durationProp] = "0s";
                            }
                        });
                    }
                    if (this.indicators) {
                        for (var i = this.indicators.length; i--;) {
                            this.indicators[i].transitionTime(time);
                        }
                    }
                },
                _transitionTimingFunction: function (easing) {
                    this.scrollerStyle[utils.style.transitionTimingFunction] = easing;
                    if (this.indicators) {
                        for (var i = this.indicators.length; i--;) {
                            this.indicators[i].transitionTimingFunction(easing);
                        }
                    }
                },
                _translate: function (x, y) {
                    if (this.options.useTransform) {
                        this.scrollerStyle[utils.style.transform] = "translate(" + x + "px," + y + "px)" + this.translateZ;
                    } else {
                        x = Math.round(x);
                        y = Math.round(y);
                        this.scrollerStyle.left = x + "px";
                        this.scrollerStyle.top = y + "px";
                    }
                    this.x = x;
                    this.y = y;
                    if (this.indicators) {
                        for (var i = this.indicators.length; i--;) {
                            this.indicators[i].updatePosition();
                        }
                    }
                },
                _initEvents: function (remove) {
                    var eventType = remove ? utils.removeEvent : utils.addEvent,
                        target = this.options.bindToWrapper ? this.wrapper : window;
                    eventType(window, "orientationchange", this);
                    eventType(window, "resize", this);
                    if (this.options.click) {
                        eventType(this.wrapper, "click", this, true);
                    }
                    if (!this.options.disableMouse) {
                        eventType(this.wrapper, "mousedown", this);
                        eventType(target, "mousemove", this);
                        eventType(target, "mousecancel", this);
                        eventType(target, "mouseup", this);
                    }
                    if (utils.hasPointer && !this.options.disablePointer) {
                        eventType(this.wrapper, utils.prefixPointerEvent("pointerdown"), this);
                        eventType(target, utils.prefixPointerEvent("pointermove"), this);
                        eventType(target, utils.prefixPointerEvent("pointercancel"), this);
                        eventType(target, utils.prefixPointerEvent("pointerup"), this);
                    }
                    if (utils.hasTouch && !this.options.disableTouch) {
                        eventType(this.wrapper, "touchstart", this);
                        eventType(target, "touchmove", this);
                        eventType(target, "touchcancel", this);
                        eventType(target, "touchend", this);
                    }
                    eventType(this.scroller, "transitionend", this);
                    eventType(this.scroller, "webkitTransitionEnd", this);
                    eventType(this.scroller, "oTransitionEnd", this);
                    eventType(this.scroller, "MSTransitionEnd", this);
                },
                getComputedPosition: function () {
                    var matrix = window.getComputedStyle(this.scroller, null),
                        x,
                        y;
                    if (this.options.useTransform) {
                        matrix = matrix[utils.style.transform].split(")")[0].split(", ");
                        x = +(matrix[12] || matrix[4]);
                        y = +(matrix[13] || matrix[5]);
                    } else {
                        x = +matrix.left.replace(/[^-\d.]/g, "");
                        y = +matrix.top.replace(/[^-\d.]/g, "");
                    }
                    return { x: x, y: y };
                },
                _initIndicators: function () {
                    var interactive = this.options.interactiveScrollbars,
                        customStyle = typeof this.options.scrollbars != "string",
                        indicators = [],
                        indicator;
                    var that = this;
                    this.indicators = [];
                    if (this.options.scrollbars) {
                        if (this.options.scrollY) {
                            indicator = {
                                el: createDefaultScrollbar("v", interactive, this.options.scrollbars),
                                interactive: interactive,
                                defaultScrollbars: true,
                                customStyle: customStyle,
                                resize: this.options.resizeScrollbars,
                                shrink: this.options.shrinkScrollbars,
                                fade: this.options.fadeScrollbars,
                                listenX: false,
                            };
                            this.wrapper.appendChild(indicator.el);
                            indicators.push(indicator);
                        }
                        if (this.options.scrollX) {
                            indicator = {
                                el: createDefaultScrollbar("h", interactive, this.options.scrollbars),
                                interactive: interactive,
                                defaultScrollbars: true,
                                customStyle: customStyle,
                                resize: this.options.resizeScrollbars,
                                shrink: this.options.shrinkScrollbars,
                                fade: this.options.fadeScrollbars,
                                listenY: false,
                            };
                            this.wrapper.appendChild(indicator.el);
                            indicators.push(indicator);
                        }
                    }
                    if (this.options.indicators) {
                        indicators = indicators.concat(this.options.indicators);
                    }
                    for (var i = indicators.length; i--;) {
                        this.indicators.push(new Indicator(this, indicators[i]));
                    }
                    function _indicatorsMap(fn) {
                        if (that.indicators) {
                            for (var i = that.indicators.length; i--;) {
                                fn.call(that.indicators[i]);
                            }
                        }
                    }
                    if (this.options.fadeScrollbars) {
                        this.on("scrollEnd", function () {
                            _indicatorsMap(function () {
                                this.fade();
                            });
                        });
                        this.on("scrollCancel", function () {
                            _indicatorsMap(function () {
                                this.fade();
                            });
                        });
                        this.on("scrollStart", function () {
                            _indicatorsMap(function () {
                                this.fade(1);
                            });
                        });
                        this.on("beforeScrollStart", function () {
                            _indicatorsMap(function () {
                                this.fade(1, true);
                            });
                        });
                    }
                    this.on("refresh", function () {
                        _indicatorsMap(function () {
                            this.refresh();
                        });
                    });
                    this.on("destroy", function () {
                        _indicatorsMap(function () {
                            this.destroy();
                        });
                        delete this.indicators;
                    });
                },
                _initWheel: function () {
                    utils.addEvent(this.wrapper, "wheel", this);
                    utils.addEvent(this.wrapper, "mousewheel", this);
                    utils.addEvent(this.wrapper, "DOMMouseScroll", this);
                    this.on("destroy", function () {
                        clearTimeout(this.wheelTimeout);
                        this.wheelTimeout = null;
                        utils.removeEvent(this.wrapper, "wheel", this);
                        utils.removeEvent(this.wrapper, "mousewheel", this);
                        utils.removeEvent(this.wrapper, "DOMMouseScroll", this);
                    });
                },
                _wheel: function (e) {
                    if (!this.enabled) {
                        return;
                    }
                    e.preventDefault();
                    var wheelDeltaX,
                        wheelDeltaY,
                        newX,
                        newY,
                        that = this;
                    if (this.wheelTimeout === undefined) {
                        that._execEvent("scrollStart");
                    }
                    clearTimeout(this.wheelTimeout);
                    this.wheelTimeout = setTimeout(function () {
                        if (!that.options.snap) {
                            that._execEvent("scrollEnd");
                        }
                        that.wheelTimeout = undefined;
                    }, 400);
                    if ("deltaX" in e) {
                        if (e.deltaMode === 1) {
                            wheelDeltaX = -e.deltaX * this.options.mouseWheelSpeed;
                            wheelDeltaY = -e.deltaY * this.options.mouseWheelSpeed;
                        } else {
                            wheelDeltaX = -e.deltaX;
                            wheelDeltaY = -e.deltaY;
                        }
                    } else if ("wheelDeltaX" in e) {
                        wheelDeltaX = (e.wheelDeltaX / 120) * this.options.mouseWheelSpeed;
                        wheelDeltaY = (e.wheelDeltaY / 120) * this.options.mouseWheelSpeed;
                    } else if ("wheelDelta" in e) {
                        wheelDeltaX = wheelDeltaY = (e.wheelDelta / 120) * this.options.mouseWheelSpeed;
                    } else if ("detail" in e) {
                        wheelDeltaX = wheelDeltaY = (-e.detail / 3) * this.options.mouseWheelSpeed;
                    } else {
                        return;
                    }
                    wheelDeltaX *= this.options.invertWheelDirection;
                    wheelDeltaY *= this.options.invertWheelDirection;
                    if (!this.hasVerticalScroll) {
                        wheelDeltaX = wheelDeltaY;
                        wheelDeltaY = 0;
                    }
                    if (this.options.snap) {
                        newX = this.currentPage.pageX;
                        newY = this.currentPage.pageY;
                        if (wheelDeltaX > 0) {
                            newX--;
                        } else if (wheelDeltaX < 0) {
                            newX++;
                        }
                        if (wheelDeltaY > 0) {
                            newY--;
                        } else if (wheelDeltaY < 0) {
                            newY++;
                        }
                        this.goToPage(newX, newY);
                        return;
                    }
                    newX = this.x + Math.round(this.hasHorizontalScroll ? wheelDeltaX : 0);
                    newY = this.y + Math.round(this.hasVerticalScroll ? wheelDeltaY : 0);
                    this.directionX = wheelDeltaX > 0 ? -1 : wheelDeltaX < 0 ? 1 : 0;
                    this.directionY = wheelDeltaY > 0 ? -1 : wheelDeltaY < 0 ? 1 : 0;
                    if (newX > 0) {
                        newX = 0;
                    } else if (newX < this.maxScrollX) {
                        newX = this.maxScrollX;
                    }
                    if (newY > 0) {
                        newY = 0;
                    } else if (newY < this.maxScrollY) {
                        newY = this.maxScrollY;
                    }
                    this.scrollTo(newX, newY, 800);
                },
                _initSnap: function () {
                    this.currentPage = {};
                    if (typeof this.options.snap == "string") {
                        this.options.snap = this.scroller.querySelectorAll(this.options.snap);
                    }
                    this.on("refresh", function () {
                        var i = 0,
                            l,
                            m = 0,
                            n,
                            cx,
                            cy,
                            x = 0,
                            y,
                            stepX = this.options.snapStepX || this.wrapperWidth,
                            stepY = this.options.snapStepY || this.wrapperHeight,
                            el;
                        this.pages = [];
                        if (!this.wrapperWidth || !this.wrapperHeight || !this.scrollerWidth || !this.scrollerHeight) {
                            return;
                        }
                        if (this.options.snap === true) {
                            cx = Math.round(stepX / 2);
                            cy = Math.round(stepY / 2);
                            while (x > -this.scrollerWidth) {
                                this.pages[i] = [];
                                l = 0;
                                y = 0;
                                while (y > -this.scrollerHeight) {
                                    this.pages[i][l] = { x: Math.max(x, this.maxScrollX), y: Math.max(y, this.maxScrollY), width: stepX, height: stepY, cx: x - cx, cy: y - cy };
                                    y -= stepY;
                                    l++;
                                }
                                x -= stepX;
                                i++;
                            }
                        } else {
                            el = this.options.snap;
                            l = el.length;
                            n = -1;
                            for (; i < l; i++) {
                                if (i === 0 || el[i].offsetLeft <= el[i - 1].offsetLeft) {
                                    m = 0;
                                    n++;
                                }
                                if (!this.pages[m]) {
                                    this.pages[m] = [];
                                }
                                x = Math.max(-el[i].offsetLeft, this.maxScrollX);
                                y = Math.max(-el[i].offsetTop, this.maxScrollY);
                                cx = x - Math.round(el[i].offsetWidth / 2);
                                cy = y - Math.round(el[i].offsetHeight / 2);
                                this.pages[m][n] = { x: x, y: y, width: el[i].offsetWidth, height: el[i].offsetHeight, cx: cx, cy: cy };
                                if (x > this.maxScrollX) {
                                    m++;
                                }
                            }
                        }
                        this.goToPage(this.currentPage.pageX || 0, this.currentPage.pageY || 0, 0);
                        if (this.options.snapThreshold % 1 === 0) {
                            this.snapThresholdX = this.options.snapThreshold;
                            this.snapThresholdY = this.options.snapThreshold;
                        } else {
                            this.snapThresholdX = Math.round(this.pages[this.currentPage.pageX][this.currentPage.pageY].width * this.options.snapThreshold);
                            this.snapThresholdY = Math.round(this.pages[this.currentPage.pageX][this.currentPage.pageY].height * this.options.snapThreshold);
                        }
                    });
                    this.on("flick", function () {
                        var time = this.options.snapSpeed || Math.max(Math.max(Math.min(Math.abs(this.x - this.startX), 1e3), Math.min(Math.abs(this.y - this.startY), 1e3)), 300);
                        this.goToPage(this.currentPage.pageX + this.directionX, this.currentPage.pageY + this.directionY, time);
                    });
                },
                _nearestSnap: function (x, y) {
                    if (!this.pages.length) {
                        return { x: 0, y: 0, pageX: 0, pageY: 0 };
                    }
                    var i = 0,
                        l = this.pages.length,
                        m = 0;
                    if (Math.abs(x - this.absStartX) < this.snapThresholdX && Math.abs(y - this.absStartY) < this.snapThresholdY) {
                        return this.currentPage;
                    }
                    if (x > 0) {
                        x = 0;
                    } else if (x < this.maxScrollX) {
                        x = this.maxScrollX;
                    }
                    if (y > 0) {
                        y = 0;
                    } else if (y < this.maxScrollY) {
                        y = this.maxScrollY;
                    }
                    for (; i < l; i++) {
                        if (x >= this.pages[i][0].cx) {
                            x = this.pages[i][0].x;
                            break;
                        }
                    }
                    l = this.pages[i].length;
                    for (; m < l; m++) {
                        if (y >= this.pages[0][m].cy) {
                            y = this.pages[0][m].y;
                            break;
                        }
                    }
                    if (i == this.currentPage.pageX) {
                        i += this.directionX;
                        if (i < 0) {
                            i = 0;
                        } else if (i >= this.pages.length) {
                            i = this.pages.length - 1;
                        }
                        x = this.pages[i][0].x;
                    }
                    if (m == this.currentPage.pageY) {
                        m += this.directionY;
                        if (m < 0) {
                            m = 0;
                        } else if (m >= this.pages[0].length) {
                            m = this.pages[0].length - 1;
                        }
                        y = this.pages[0][m].y;
                    }
                    return { x: x, y: y, pageX: i, pageY: m };
                },
                goToPage: function (x, y, time, easing) {
                    easing = easing || this.options.bounceEasing;
                    if (x >= this.pages.length) {
                        x = this.pages.length - 1;
                    } else if (x < 0) {
                        x = 0;
                    }
                    if (y >= this.pages[x].length) {
                        y = this.pages[x].length - 1;
                    } else if (y < 0) {
                        y = 0;
                    }
                    var posX = this.pages[x][y].x,
                        posY = this.pages[x][y].y;
                    time = time === undefined ? this.options.snapSpeed || Math.max(Math.max(Math.min(Math.abs(posX - this.x), 1e3), Math.min(Math.abs(posY - this.y), 1e3)), 300) : time;
                    this.currentPage = { x: posX, y: posY, pageX: x, pageY: y };
                    this.scrollTo(posX, posY, time, easing);
                },
                next: function (time, easing) {
                    var x = this.currentPage.pageX,
                        y = this.currentPage.pageY;
                    x++;
                    if (x >= this.pages.length && this.hasVerticalScroll) {
                        x = 0;
                        y++;
                    }
                    this.goToPage(x, y, time, easing);
                },
                prev: function (time, easing) {
                    var x = this.currentPage.pageX,
                        y = this.currentPage.pageY;
                    x--;
                    if (x < 0 && this.hasVerticalScroll) {
                        x = 0;
                        y--;
                    }
                    this.goToPage(x, y, time, easing);
                },
                _initKeys: function (e) {
                    var keys = { pageUp: 33, pageDown: 34, end: 35, home: 36, left: 37, up: 38, right: 39, down: 40 };
                    var i;
                    if (typeof this.options.keyBindings == "object") {
                        for (i in this.options.keyBindings) {
                            if (typeof this.options.keyBindings[i] == "string") {
                                this.options.keyBindings[i] = this.options.keyBindings[i].toUpperCase().charCodeAt(0);
                            }
                        }
                    } else {
                        this.options.keyBindings = {};
                    }
                    for (i in keys) {
                        this.options.keyBindings[i] = this.options.keyBindings[i] || keys[i];
                    }
                    utils.addEvent(window, "keydown", this);
                    this.on("destroy", function () {
                        utils.removeEvent(window, "keydown", this);
                    });
                },
                _key: function (e) {
                    if (!this.enabled) {
                        return;
                    }
                    var snap = this.options.snap,
                        newX = snap ? this.currentPage.pageX : this.x,
                        newY = snap ? this.currentPage.pageY : this.y,
                        now = utils.getTime(),
                        prevTime = this.keyTime || 0,
                        acceleration = 0.25,
                        pos;
                    if (this.options.useTransition && this.isInTransition) {
                        pos = this.getComputedPosition();
                        this._translate(Math.round(pos.x), Math.round(pos.y));
                        this.isInTransition = false;
                    }
                    this.keyAcceleration = now - prevTime < 200 ? Math.min(this.keyAcceleration + acceleration, 50) : 0;
                    switch (e.keyCode) {
                        case this.options.keyBindings.pageUp:
                            if (this.hasHorizontalScroll && !this.hasVerticalScroll) {
                                newX += snap ? 1 : this.wrapperWidth;
                            } else {
                                newY += snap ? 1 : this.wrapperHeight;
                            }
                            break;
                        case this.options.keyBindings.pageDown:
                            if (this.hasHorizontalScroll && !this.hasVerticalScroll) {
                                newX -= snap ? 1 : this.wrapperWidth;
                            } else {
                                newY -= snap ? 1 : this.wrapperHeight;
                            }
                            break;
                        case this.options.keyBindings.end:
                            newX = snap ? this.pages.length - 1 : this.maxScrollX;
                            newY = snap ? this.pages[0].length - 1 : this.maxScrollY;
                            break;
                        case this.options.keyBindings.home:
                            newX = 0;
                            newY = 0;
                            break;
                        case this.options.keyBindings.left:
                            newX += snap ? -1 : (5 + this.keyAcceleration) >> 0;
                            break;
                        case this.options.keyBindings.up:
                            newY += snap ? 1 : (5 + this.keyAcceleration) >> 0;
                            break;
                        case this.options.keyBindings.right:
                            newX -= snap ? -1 : (5 + this.keyAcceleration) >> 0;
                            break;
                        case this.options.keyBindings.down:
                            newY -= snap ? 1 : (5 + this.keyAcceleration) >> 0;
                            break;
                        default:
                            return;
                    }
                    if (snap) {
                        this.goToPage(newX, newY);
                        return;
                    }
                    if (newX > 0) {
                        newX = 0;
                        this.keyAcceleration = 0;
                    } else if (newX < this.maxScrollX) {
                        newX = this.maxScrollX;
                        this.keyAcceleration = 0;
                    }
                    if (newY > 0) {
                        newY = 0;
                        this.keyAcceleration = 0;
                    } else if (newY < this.maxScrollY) {
                        newY = this.maxScrollY;
                        this.keyAcceleration = 0;
                    }
                    this.scrollTo(newX, newY, 0);
                    this.keyTime = now;
                },
                _animate: function (destX, destY, duration, easingFn) {
                    var that = this,
                        startX = this.x,
                        startY = this.y,
                        startTime = utils.getTime(),
                        destTime = startTime + duration;
                    function step() {
                        var now = utils.getTime(),
                            newX,
                            newY,
                            easing;
                        if (now >= destTime) {
                            that.isAnimating = false;
                            that._translate(destX, destY);
                            if (!that.resetPosition(that.options.bounceTime)) {
                                that._execEvent("scrollEnd");
                            }
                            return;
                        }
                        now = (now - startTime) / duration;
                        easing = easingFn(now);
                        newX = (destX - startX) * easing + startX;
                        newY = (destY - startY) * easing + startY;
                        that._translate(newX, newY);
                        if (that.isAnimating) {
                            rAF(step);
                        }
                    }
                    this.isAnimating = true;
                    step();
                },
                handleEvent: function (e) {
                    switch (e.type) {
                        case "touchstart":
                        case "pointerdown":
                        case "MSPointerDown":
                        case "mousedown":
                            this._start(e);
                            break;
                        case "touchmove":
                        case "pointermove":
                        case "MSPointerMove":
                        case "mousemove":
                            this._move(e);
                            break;
                        case "touchend":
                        case "pointerup":
                        case "MSPointerUp":
                        case "mouseup":
                        case "touchcancel":
                        case "pointercancel":
                        case "MSPointerCancel":
                        case "mousecancel":
                            this._end(e);
                            break;
                        case "orientationchange":
                        case "resize":
                            this._resize();
                            break;
                        case "transitionend":
                        case "webkitTransitionEnd":
                        case "oTransitionEnd":
                        case "MSTransitionEnd":
                            this._transitionEnd(e);
                            break;
                        case "wheel":
                        case "DOMMouseScroll":
                        case "mousewheel":
                            this._wheel(e);
                            break;
                        case "keydown":
                            this._key(e);
                            break;
                        case "click":
                            if (this.enabled && !e._constructed) {
                                e.preventDefault();
                                e.stopPropagation();
                            }
                            break;
                    }
                },
            };
            function createDefaultScrollbar(direction, interactive, type) {
                var scrollbar = document.createElement("div"),
                    indicator = document.createElement("div");
                if (type === true) {
                    scrollbar.style.cssText = "position:absolute;z-index:9999";
                    indicator.style.cssText = "-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;position:absolute;background:rgba(0,0,0,0.5);border:1px solid rgba(255,255,255,0.9);border-radius:3px";
                }
                indicator.className = "iScrollIndicator";
                if (direction == "h") {
                    if (type === true) {
                        scrollbar.style.cssText += ";height:7px;left:2px;right:2px;bottom:0";
                        indicator.style.height = "100%";
                    }
                    scrollbar.className = "iScrollHorizontalScrollbar";
                } else {
                    if (type === true) {
                        scrollbar.style.cssText += ";width:7px;bottom:2px;top:2px;right:1px";
                        indicator.style.width = "100%";
                    }
                    scrollbar.className = "iScrollVerticalScrollbar";
                }
                scrollbar.style.cssText += ";overflow:hidden";
                if (!interactive) {
                    scrollbar.style.pointerEvents = "none";
                }
                scrollbar.appendChild(indicator);
                return scrollbar;
            }
            function Indicator(scroller, options) {
                this.wrapper = typeof options.el == "string" ? document.querySelector(options.el) : options.el;
                this.wrapperStyle = this.wrapper.style;
                this.indicator = this.wrapper.children[0];
                this.indicatorStyle = this.indicator.style;
                this.scroller = scroller;
                this.options = { listenX: true, listenY: true, interactive: false, resize: true, defaultScrollbars: false, shrink: false, fade: false, speedRatioX: 0, speedRatioY: 0 };
                for (var i in options) {
                    this.options[i] = options[i];
                }
                this.sizeRatioX = 1;
                this.sizeRatioY = 1;
                this.maxPosX = 0;
                this.maxPosY = 0;
                if (this.options.interactive) {
                    if (!this.options.disableTouch) {
                        utils.addEvent(this.indicator, "touchstart", this);
                        utils.addEvent(window, "touchend", this);
                    }
                    if (!this.options.disablePointer) {
                        utils.addEvent(this.indicator, utils.prefixPointerEvent("pointerdown"), this);
                        utils.addEvent(window, utils.prefixPointerEvent("pointerup"), this);
                    }
                    if (!this.options.disableMouse) {
                        utils.addEvent(this.indicator, "mousedown", this);
                        utils.addEvent(window, "mouseup", this);
                    }
                }
                if (this.options.fade) {
                    this.wrapperStyle[utils.style.transform] = this.scroller.translateZ;
                    var durationProp = utils.style.transitionDuration;
                    this.wrapperStyle[durationProp] = utils.isBadAndroid ? "0.0001ms" : "0ms";
                    var self = this;
                    if (utils.isBadAndroid) {
                        rAF(function () {
                            if (self.wrapperStyle[durationProp] === "0.0001ms") {
                                self.wrapperStyle[durationProp] = "0s";
                            }
                        });
                    }
                    this.wrapperStyle.opacity = "0";
                }
            }
            Indicator.prototype = {
                handleEvent: function (e) {
                    switch (e.type) {
                        case "touchstart":
                        case "pointerdown":
                        case "MSPointerDown":
                        case "mousedown":
                            this._start(e);
                            break;
                        case "touchmove":
                        case "pointermove":
                        case "MSPointerMove":
                        case "mousemove":
                            this._move(e);
                            break;
                        case "touchend":
                        case "pointerup":
                        case "MSPointerUp":
                        case "mouseup":
                        case "touchcancel":
                        case "pointercancel":
                        case "MSPointerCancel":
                        case "mousecancel":
                            this._end(e);
                            break;
                    }
                },
                destroy: function () {
                    if (this.options.fadeScrollbars) {
                        clearTimeout(this.fadeTimeout);
                        this.fadeTimeout = null;
                    }
                    if (this.options.interactive) {
                        utils.removeEvent(this.indicator, "touchstart", this);
                        utils.removeEvent(this.indicator, utils.prefixPointerEvent("pointerdown"), this);
                        utils.removeEvent(this.indicator, "mousedown", this);
                        utils.removeEvent(window, "touchmove", this);
                        utils.removeEvent(window, utils.prefixPointerEvent("pointermove"), this);
                        utils.removeEvent(window, "mousemove", this);
                        utils.removeEvent(window, "touchend", this);
                        utils.removeEvent(window, utils.prefixPointerEvent("pointerup"), this);
                        utils.removeEvent(window, "mouseup", this);
                    }
                    if (this.options.defaultScrollbars) {
                        this.wrapper.parentNode.removeChild(this.wrapper);
                    }
                },
                _start: function (e) {
                    var point = e.touches ? e.touches[0] : e;
                    e.preventDefault();
                    e.stopPropagation();
                    this.transitionTime();
                    this.initiated = true;
                    this.moved = false;
                    this.lastPointX = point.pageX;
                    this.lastPointY = point.pageY;
                    this.startTime = utils.getTime();
                    if (!this.options.disableTouch) {
                        utils.addEvent(window, "touchmove", this);
                    }
                    if (!this.options.disablePointer) {
                        utils.addEvent(window, utils.prefixPointerEvent("pointermove"), this);
                    }
                    if (!this.options.disableMouse) {
                        utils.addEvent(window, "mousemove", this);
                    }
                    this.scroller._execEvent("beforeScrollStart");
                },
                _move: function (e) {
                    var point = e.touches ? e.touches[0] : e,
                        deltaX,
                        deltaY,
                        newX,
                        newY,
                        timestamp = utils.getTime();
                    if (!this.moved) {
                        this.scroller._execEvent("scrollStart");
                    }
                    this.moved = true;
                    deltaX = point.pageX - this.lastPointX;
                    this.lastPointX = point.pageX;
                    deltaY = point.pageY - this.lastPointY;
                    this.lastPointY = point.pageY;
                    newX = this.x + deltaX;
                    newY = this.y + deltaY;
                    this._pos(newX, newY);
                    e.preventDefault();
                    e.stopPropagation();
                },
                _end: function (e) {
                    if (!this.initiated) {
                        return;
                    }
                    this.initiated = false;
                    e.preventDefault();
                    e.stopPropagation();
                    utils.removeEvent(window, "touchmove", this);
                    utils.removeEvent(window, utils.prefixPointerEvent("pointermove"), this);
                    utils.removeEvent(window, "mousemove", this);
                    if (this.scroller.options.snap) {
                        var snap = this.scroller._nearestSnap(this.scroller.x, this.scroller.y);
                        var time = this.options.snapSpeed || Math.max(Math.max(Math.min(Math.abs(this.scroller.x - snap.x), 1e3), Math.min(Math.abs(this.scroller.y - snap.y), 1e3)), 300);
                        if (this.scroller.x != snap.x || this.scroller.y != snap.y) {
                            this.scroller.directionX = 0;
                            this.scroller.directionY = 0;
                            this.scroller.currentPage = snap;
                            this.scroller.scrollTo(snap.x, snap.y, time, this.scroller.options.bounceEasing);
                        }
                    }
                    if (this.moved) {
                        this.scroller._execEvent("scrollEnd");
                    }
                },
                transitionTime: function (time) {
                    time = time || 0;
                    var durationProp = utils.style.transitionDuration;
                    this.indicatorStyle[durationProp] = time + "ms";
                    if (!time && utils.isBadAndroid) {
                        this.indicatorStyle[durationProp] = "0.0001ms";
                        var self = this;
                        rAF(function () {
                            if (self.indicatorStyle[durationProp] === "0.0001ms") {
                                self.indicatorStyle[durationProp] = "0s";
                            }
                        });
                    }
                },
                transitionTimingFunction: function (easing) {
                    this.indicatorStyle[utils.style.transitionTimingFunction] = easing;
                },
                refresh: function () {
                    this.transitionTime();
                    if (this.options.listenX && !this.options.listenY) {
                        this.indicatorStyle.display = this.scroller.hasHorizontalScroll ? "block" : "none";
                    } else if (this.options.listenY && !this.options.listenX) {
                        this.indicatorStyle.display = this.scroller.hasVerticalScroll ? "block" : "none";
                    } else {
                        this.indicatorStyle.display = this.scroller.hasHorizontalScroll || this.scroller.hasVerticalScroll ? "block" : "none";
                    }
                    if (this.scroller.hasHorizontalScroll && this.scroller.hasVerticalScroll) {
                        utils.addClass(this.wrapper, "iScrollBothScrollbars");
                        utils.removeClass(this.wrapper, "iScrollLoneScrollbar");
                        if (this.options.defaultScrollbars && this.options.customStyle) {
                            if (this.options.listenX) {
                                this.wrapper.style.right = "8px";
                            } else {
                                this.wrapper.style.bottom = "8px";
                            }
                        }
                    } else {
                        utils.removeClass(this.wrapper, "iScrollBothScrollbars");
                        utils.addClass(this.wrapper, "iScrollLoneScrollbar");
                        if (this.options.defaultScrollbars && this.options.customStyle) {
                            if (this.options.listenX) {
                                this.wrapper.style.right = "2px";
                            } else {
                                this.wrapper.style.bottom = "2px";
                            }
                        }
                    }
                    var r = this.wrapper.offsetHeight;
                    if (this.options.listenX) {
                        this.wrapperWidth = this.wrapper.clientWidth;
                        if (this.options.resize) {
                            this.indicatorWidth = Math.max(Math.round((this.wrapperWidth * this.wrapperWidth) / (this.scroller.scrollerWidth || this.wrapperWidth || 1)), 8);
                            this.indicatorStyle.width = this.indicatorWidth + "px";
                        } else {
                            this.indicatorWidth = this.indicator.clientWidth;
                        }
                        this.maxPosX = this.wrapperWidth - this.indicatorWidth;
                        if (this.options.shrink == "clip") {
                            this.minBoundaryX = -this.indicatorWidth + 8;
                            this.maxBoundaryX = this.wrapperWidth - 8;
                        } else {
                            this.minBoundaryX = 0;
                            this.maxBoundaryX = this.maxPosX;
                        }
                        this.sizeRatioX = this.options.speedRatioX || (this.scroller.maxScrollX && this.maxPosX / this.scroller.maxScrollX);
                    }
                    if (this.options.listenY) {
                        this.wrapperHeight = this.wrapper.clientHeight;
                        if (this.options.resize) {
                            this.indicatorHeight = Math.max(Math.round((this.wrapperHeight * this.wrapperHeight) / (this.scroller.scrollerHeight || this.wrapperHeight || 1)), 8);
                            this.indicatorStyle.height = this.indicatorHeight + "px";
                        } else {
                            this.indicatorHeight = this.indicator.clientHeight;
                        }
                        this.maxPosY = this.wrapperHeight - this.indicatorHeight;
                        if (this.options.shrink == "clip") {
                            this.minBoundaryY = -this.indicatorHeight + 8;
                            this.maxBoundaryY = this.wrapperHeight - 8;
                        } else {
                            this.minBoundaryY = 0;
                            this.maxBoundaryY = this.maxPosY;
                        }
                        this.maxPosY = this.wrapperHeight - this.indicatorHeight;
                        this.sizeRatioY = this.options.speedRatioY || (this.scroller.maxScrollY && this.maxPosY / this.scroller.maxScrollY);
                    }
                    this.updatePosition();
                },
                updatePosition: function () {
                    var x = (this.options.listenX && Math.round(this.sizeRatioX * this.scroller.x)) || 0,
                        y = (this.options.listenY && Math.round(this.sizeRatioY * this.scroller.y)) || 0;
                    if (!this.options.ignoreBoundaries) {
                        if (x < this.minBoundaryX) {
                            if (this.options.shrink == "scale") {
                                this.width = Math.max(this.indicatorWidth + x, 8);
                                this.indicatorStyle.width = this.width + "px";
                            }
                            x = this.minBoundaryX;
                        } else if (x > this.maxBoundaryX) {
                            if (this.options.shrink == "scale") {
                                this.width = Math.max(this.indicatorWidth - (x - this.maxPosX), 8);
                                this.indicatorStyle.width = this.width + "px";
                                x = this.maxPosX + this.indicatorWidth - this.width;
                            } else {
                                x = this.maxBoundaryX;
                            }
                        } else if (this.options.shrink == "scale" && this.width != this.indicatorWidth) {
                            this.width = this.indicatorWidth;
                            this.indicatorStyle.width = this.width + "px";
                        }
                        if (y < this.minBoundaryY) {
                            if (this.options.shrink == "scale") {
                                this.height = Math.max(this.indicatorHeight + y * 3, 8);
                                this.indicatorStyle.height = this.height + "px";
                            }
                            y = this.minBoundaryY;
                        } else if (y > this.maxBoundaryY) {
                            if (this.options.shrink == "scale") {
                                this.height = Math.max(this.indicatorHeight - (y - this.maxPosY) * 3, 8);
                                this.indicatorStyle.height = this.height + "px";
                                y = this.maxPosY + this.indicatorHeight - this.height;
                            } else {
                                y = this.maxBoundaryY;
                            }
                        } else if (this.options.shrink == "scale" && this.height != this.indicatorHeight) {
                            this.height = this.indicatorHeight;
                            this.indicatorStyle.height = this.height + "px";
                        }
                    }
                    this.x = x;
                    this.y = y;
                    if (this.scroller.options.useTransform) {
                        this.indicatorStyle[utils.style.transform] = "translate(" + x + "px," + y + "px)" + this.scroller.translateZ;
                    } else {
                        this.indicatorStyle.left = x + "px";
                        this.indicatorStyle.top = y + "px";
                    }
                },
                _pos: function (x, y) {
                    if (x < 0) {
                        x = 0;
                    } else if (x > this.maxPosX) {
                        x = this.maxPosX;
                    }
                    if (y < 0) {
                        y = 0;
                    } else if (y > this.maxPosY) {
                        y = this.maxPosY;
                    }
                    x = this.options.listenX ? Math.round(x / this.sizeRatioX) : this.scroller.x;
                    y = this.options.listenY ? Math.round(y / this.sizeRatioY) : this.scroller.y;
                    this.scroller.scrollTo(x, y);
                },
                fade: function (val, hold) {
                    if (hold && !this.visible) {
                        return;
                    }
                    clearTimeout(this.fadeTimeout);
                    this.fadeTimeout = null;
                    var time = val ? 250 : 500,
                        delay = val ? 0 : 300;
                    val = val ? "1" : "0";
                    this.wrapperStyle[utils.style.transitionDuration] = time + "ms";
                    this.fadeTimeout = setTimeout(
                        function (val) {
                            this.wrapperStyle.opacity = val;
                            this.visible = +val;
                        }.bind(this, val),
                        delay
                    );
                },
            };
            IScroll.utils = utils;
            if ("object" != "undefined" && module.exports) {
                module.exports = IScroll;
            } else if (typeof undefined == "function" && undefined.amd) {
                undefined(function () {
                    return IScroll;
                });
            } else {
                window.IScroll = IScroll;
            }
        })(window, document, Math);
    });
    function ChapterLeaf(options) {
        this.$el = $('<div class="leaf" />');
        this.contents = options.contents;
        this.mobile = options.mobile;
        this.locale = options.locale;
        this.index = options.index;
        this.lang = options.lang;
        this.updating = false;
        this.disable = false;
        this.setup();
    }
    ChapterLeaf.prototype = {
        constructor: ChapterLeaf,
        setup: function () {
            this.$el.append(this.getTemplate(this.locale, this.lang));
            var $wrapper = this.$el.find(".leaf-wrap"),
                $holder = this.$el.find(".leaf-holder"),
                $tools = this.getTools(this.locale, this.lang),
                $links = this.getLinks(this.contents.links, this.locale, this.lang),
                $title = this.getTitle(this.contents.title, this.locale, this.lang),
                $body = this.getBody(this.contents.body, this.locale, this.lang);
            $wrapper.append($tools);
            $wrapper.append($links);
            $wrapper.append($title);
            $wrapper.append($body);
            TweenMax.set(this.$el, { x: this.getSize(), force3D: true });
            if (!this.mobile) this.initScroll($body[0]);
            else $holder.css({ webkitOverflowScrolling: "touch", overflow: "auto" });
        },
        update: function (contents) {
            TweenMax.killChildTweensOf(this.$el);
            if (this.disable) return;
            var tweens = [],
                scope = this,
                $wrapper = this.$el.find(".leaf-wrap"),
                $oldlinks = this.$el.find(".leaf-links"),
                $oldtitle = this.$el.find(".leaf-title"),
                $oldbody = this.$el.find(".leaf-body"),
                $newlinks = this.getLinks(contents.links, this.locale, this.lang),
                $newtitle = this.getTitle(contents.title, this.locale, this.lang),
                $newbody = this.getBody(contents.body, this.locale, this.lang),
                $newbar = $newbody.find(".iScrollHorizontalScrollbar");
            scope.updating = true;
            tweens.push(
                new TimelineMax({
                    tweens: [TweenMax.to($oldlinks, 0.5, { autoAlpha: 0, ease: Cubic.easeOut }), TweenMax.to($oldtitle, 0.5, { autoAlpha: 0, ease: Cubic.easeOut }), TweenMax.to($oldbody, 0.5, { autoAlpha: 0, ease: Cubic.easeOut })],
                    stagger: 0,
                    onComplete: function () {
                        scope.$el.find(".leaf-links").each(function () {
                            $(this).remove();
                        });
                        scope.$el.find(".leaf-title").each(function () {
                            $(this).remove();
                        });
                        scope.$el.find(".leaf-body").each(function () {
                            $(this).remove();
                        });
                    },
                })
            );
            tweens.push(
                new TimelineMax({
                    tweens: [
                        TweenMax.allFrom($newlinks.find("li"), 1, { autoAlpha: 0, y: 50, ease: Cubic.easeOut }, 0.2),
                        TweenMax.from($newtitle, 1, { autoAlpha: 0, y: 50, ease: Cubic.easeOut }),
                        TweenMax.allFrom($newbody.find("li"), 1, { autoAlpha: 0, y: 50, ease: Cubic.easeOut }, 0.2),
                        TweenMax.from($newbar, 1, { autoAlpha: 0, y: 50, ease: Cubic.easeOut }),
                    ],
                    stagger: 0.2,
                    onStart: function () {
                        $wrapper.append($newlinks);
                        $wrapper.append($newtitle);
                        $wrapper.append($newbody);
                        scope.updating = false;
                    },
                    onComplete: function () {
                        if (!scope.mobile) scope.initScroll($newbody[0]);
                        scope.initPage();
                    },
                })
            );
            return new TimelineMax({ tweens: tweens, stagger: 0.75 });
        },
        tweenIn: function () {
            var tweens = [],
                $close = this.$el.find(".leaf-tools .close"),
                $prev = this.$el.find(".leaf-tools .prev"),
                $next = this.$el.find(".leaf-tools .next"),
                $links = this.$el.find(".leaf-links li"),
                $title = this.$el.find(".leaf-title"),
                $body = this.$el.find(".leaf-body li"),
                $bar = this.$el.find(".iScrollHorizontalScrollbar");
            tweens.push(TweenMax.to(this.$el, 1, { x: 0, force3D: true, ease: Cubic.easeInOut }));
            tweens.push(
                new TimelineMax({
                    tweens: [
                        TweenMax.allFrom($links, 1, { autoAlpha: 0, y: 50, ease: Cubic.easeOut }, 0.2),
                        TweenMax.from($title, 1, { autoAlpha: 0, y: 50, ease: Cubic.easeOut }),
                        TweenMax.allFrom($body, 1, { autoAlpha: 0, y: 50, ease: Cubic.easeOut }, 0.2),
                        TweenMax.from($bar, 1, { autoAlpha: 0, y: 50, ease: Cubic.easeOut }),
                    ],
                    stagger: 0.2,
                })
            );
            tweens.push(
                new TimelineMax({
                    tweens: [
                        new TimelineMax({
                            tweens: [
                                new TimelineMax({
                                    tweens: [
                                        TweenMax.from($close.find(".cl1 span"), 0.8, { autoAlpha: 0, scaleX: 0, x: 50, ease: Expo.easeOut }),
                                        TweenMax.from($close.find(".cr1 span"), 0.8, { autoAlpha: 0, scaleX: 0, x: 50, ease: Expo.easeOut }),
                                    ],
                                    stagger: 0.1,
                                }),
                                TweenMax.allFrom($close.find(".close-label").data("store"), 0.8, { autoAlpha: 0, y: 20, ease: Expo.easeOut }, 0.1),
                                TweenMax.from($close.find(".close-line"), 0.8, { autoAlpha: 0, y: 40, ease: Expo.easeOut }),
                            ],
                        }),
                        new TimelineMax({
                            tweens: [
                                new TimelineMax({
                                    tweens: [
                                        TweenMax.from($prev.find(".icon"), 0.8, { autoAlpha: 0, y: 40, ease: Expo.easeOut }),
                                        TweenMax.allFrom($prev.find(".prev-label").data("store"), 0.8, { autoAlpha: 0, y: 20, ease: Expo.easeOut }, 0.1),
                                        TweenMax.from($prev.find(".prev-line"), 0.8, { autoAlpha: 0, y: 40, ease: Expo.easeOut }),
                                    ],
                                }),
                                new TimelineMax({
                                    tweens: [
                                        TweenMax.allFrom($next.find(".next-label").data("store"), 0.8, { autoAlpha: 0, y: 20, ease: Expo.easeOut }, 0.1),
                                        TweenMax.from($next.find(".icon"), 0.8, { autoAlpha: 0, y: 40, ease: Expo.easeOut }),
                                        TweenMax.from($next.find(".next-line"), 0.8, { autoAlpha: 0, y: 40, ease: Expo.easeOut }),
                                    ],
                                }),
                            ],
                            stagger: 0.15,
                        }),
                    ],
                    stagger: 0.15,
                })
            );
            return new TimelineMax({ tweens: tweens, stagger: 0.4 });
        },
        tweenOut: function () {
            var tweens = [];
            tweens.push(TweenMax.to(this.$el, 1, { x: this.getSize(), force3D: true, ease: Cubic.easeInOut }));
            return new TimelineMax({ tweens: tweens });
        },
        initPage: function () {
            if (this.disable) return;
            var mobile = this.mobile,
                iscroll$$1 = this.vIscroll;
            this.$el.find(".leaf-body img").each(function (i, img) {
                var $img = $(img),
                    $tmp = $("<img />"),
                    src = $img.data("src");
                $tmp.data({ img: $img })
                    .on("load", function () {
                        TweenMax.to($(this).data("img"), 1, { opacity: 1, ease: Cubic.easeInOut });
                        if (!mobile) iscroll$$1.refresh();
                    })
                    .attr({ src: src });
            });
            $(window).trigger(Events.RESIZE);
        },
        initScroll: function (target) {
            this.vIscroll = new iscroll(target, { interactiveScrollbars: true, scrollbars: "custom", mouseWheel: true, scrollY: true, scrollX: false, bounce: false, click: true });
        },
        getSize: function () {
            return window.innerWidth < 767 ? window.innerWidth : 450;
        },
        getTemplate: function (locale, lang) {
            var $el = $(['<div class="leaf-holder">', '<div class="leaf-wrap">', "</div>", "</div>"].join().replace(/,/g, ""));
            return $el;
        },
        getTools: function (locale, lang) {
            var scope = this,
                $el = $(
                    [
                        '<div class="leaf-tools">',
                        '<div class="close">',
                        '<div class="close-icon">',
                        '<span class="cl1"><span></span></span>',
                        '<span class="cr1"><span></span></span>',
                        '<span class="cl2"><span></span></span>',
                        '<span class="cr2"><span></span></span>',
                        "</div>",
                        '<span class="close-label">',
                        '<span class="timsans-bold">',
                        locale.ui.close[lang],
                        "</span>",
                        "</span>",
                        "</div>",
                        '<div class="prev">',
                        '<img class="icon" src="img/assets/arrow-prev-icon.png" alt="">',
                        '<span class="prev-label">',
                        '<span class="timsans-bold">',
                        locale.ui.prev[lang],
                        "</span>",
                        "</span>",
                        "</div>",
                        '<div class="next active">',
                        '<span class="next-label">',
                        '<span class="timsans-bold">',
                        locale.ui.next[lang],
                        "</span>",
                        "</span>",
                        '<img class="icon" src="img/assets/arrow-next-icon.png" alt="">',
                        "</div>",
                        "</div>",
                    ]
                        .join()
                        .replace(/,/g, "")
                )
                    .on("click", ".close", function () {
                        scope.dispatch(Events.LEAF_CLOSE);
                    })
                    .on("click", ".prev", function () {
                        scope.dispatch(Events.LEAF_PREV);
                    })
                    .on("click", ".next", function () {
                        scope.dispatch(Events.LEAF_NEXT);
                    });
            $el.find(".close-label").splitLetters().append($('<span class="close-line" />'));
            $el.find(".prev-label").splitLetters().append($('<span class="prev-line" />'));
            $el.find(".next-label").splitLetters().append($('<span class="next-line" />'));
            $el.find(".close")
                .on("mouseleave", function () {
                    return new TimelineMax({
                        tweens: [
                            TweenMax.to($el.find(".close-label"), 0.8, { autoAlpha: 1, ease: Expo.easeOut }),
                            new TimelineMax({
                                tweens: [TweenMax.to($el.find(".cl2 span"), 0.8, { x: -30, scaleX: 0, force3D: true, ease: Expo.easeOut }), TweenMax.to($el.find(".cr2 span"), 0.8, { x: 30, scaleX: 0, force3D: true, ease: Expo.easeOut })],
                                stagger: 0.08,
                            }),
                            new TimelineMax({
                                tweens: [TweenMax.to($el.find(".cl1 span"), 0.8, { x: 0, scaleX: 1, force3D: true, ease: Expo.easeOut }), TweenMax.to($el.find(".cr1 span"), 0.8, { x: 0, scaleX: 1, force3D: true, ease: Expo.easeOut })],
                                stagger: 0.08,
                            }),
                        ],
                    });
                })
                .on("mouseenter", function () {
                    return new TimelineMax({
                        tweens: [
                            TweenMax.to($el.find(".close-label"), 0.8, { autoAlpha: 0.4, ease: Expo.easeOut }),
                            new TimelineMax({
                                tweens: [TweenMax.to($el.find(".cl1 span"), 0.8, { x: 30, scaleX: 0, force3D: true, ease: Expo.easeOut }), TweenMax.to($el.find(".cr1 span"), 0.8, { x: -30, scaleX: 0, force3D: true, ease: Expo.easeOut })],
                                stagger: 0.08,
                            }),
                            new TimelineMax({
                                tweens: [TweenMax.to($el.find(".cl2 span"), 0.8, { x: 0, scaleX: 1, force3D: true, ease: Expo.easeOut }), TweenMax.to($el.find(".cr2 span"), 0.8, { x: 0, scaleX: 1, force3D: true, ease: Expo.easeOut })],
                                stagger: 0.08,
                            }),
                        ],
                    });
                });
            $el.find(".prev")
                .on("mouseleave", function () {
                    return new TimelineMax({ tweens: [TweenMax.to($el.find(".prev-label"), 0.8, { autoAlpha: 1, ease: Expo.easeOut }), TweenMax.to($el.find(".prev .icon"), 0.8, { x: 0, ease: Expo.easeOut })] });
                })
                .on("mouseenter", function (e) {
                    if (!$(e.currentTarget).data("active")) return;
                    return new TimelineMax({ tweens: [TweenMax.to($el.find(".prev-label"), 0.8, { autoAlpha: 0.4, ease: Expo.easeOut }), TweenMax.to($el.find(".prev .icon"), 0.8, { x: -5, ease: Expo.easeOut })] });
                });
            $el.find(".next")
                .on("mouseleave", function () {
                    return new TimelineMax({ tweens: [TweenMax.to($el.find(".next-label"), 0.8, { autoAlpha: 1, ease: Expo.easeOut }), TweenMax.to($el.find(".next .icon"), 0.8, { x: 0, ease: Expo.easeOut })] });
                })
                .on("mouseenter", function (e) {
                    if (!$(e.currentTarget).data("active")) return;
                    return new TimelineMax({ tweens: [TweenMax.to($el.find(".next-label"), 0.8, { autoAlpha: 0.4, ease: Expo.easeOut }), TweenMax.to($el.find(".next .icon"), 0.8, { x: 5, ease: Expo.easeOut })] });
                });
            return $el;
        },
        getLinks: function (collection, locale, lang) {
            var $el = $(['<div class="leaf-links">', "<ul></ul>", "</div>"].join().replace(/,/g, ""));
            underscoreMin.each(collection, function (link) {
                $el.find("ul").append(
                    ["<li>", '<img class="link-icon" src="img/assets/link-icon.png" alt="">', '<a class="link-label" href="' + link.href + '" target="_blank">', '<span class="timsans-bold">' + link.label + "</span>", "</a>", "</li>"]
                        .join()
                        .replace(/,/g, "")
                );
            });
            return $el;
        },
        getTitle: function (title, locale, lang) {
            var $el = $(['<h1 class="leaf-title">', '<span class="trajan-pro"></span>', "</h1>"].join().replace(/,/g, ""));
            $el.find("span").html(title);
            return $el;
        },
        getBody: function (collection, locale, lang) {
            var width = 0,
                $el = $(['<div class="leaf-body">', "<ul></ul>", "</div>"].join().replace(/,/g, ""));
            underscoreMin.each(
                collection,
                function (module) {
                    for (var key in module) {
                        var mod = module[key],
                            $item;
                        if (key == "text") {
                            $item = $('<li><span class="timsans-bold">' + mod + "</span></li>");
                        } else if (key == "img") {
                            $item = $('<li><img src="' + mod.src + '" data-src="' + mod.src + '" width="' + mod.width + '" height="' + mod.height + '" alt="" style="opacity:0;" /></li>');
                        }
                        $el.find("ul").append($item);
                    }
                },
                this
            );
            return $el;
        },
        resize: function (stagesize, open) {
            var $body = this.$el.find(".leaf-body");
            if ($body.length > 0) {
                var offset = $body.position().top + 60,
                    height = !this.mobile ? stagesize.h - offset : "auto";
                TweenMax.set($body, { height: height });
            }
        },
        refresh: function () {
            if (!this.mobile) this.vIscroll.refresh();
        },
        destroy: function () {
            this.$el.remove();
            this.contents = null;
            this.closefn = null;
            this.mobile = null;
            this.locale = null;
            this.lang = null;
            this.$el = null;
        },
    };
    Object.assign(ChapterLeaf.prototype, EventDispatcher.prototype);
    THREE.ExplodeModifier = function () { };
    THREE.ExplodeModifier.prototype.modify = function (geometry) {
        var vertices = [];
        for (var i = 0, il = geometry.faces.length; i < il; i++) {
            var n = vertices.length;
            var face = geometry.faces[i];
            var a = face.a;
            var b = face.b;
            var c = face.c;
            var va = geometry.vertices[a];
            var vb = geometry.vertices[b];
            var vc = geometry.vertices[c];
            vertices.push(va.clone());
            vertices.push(vb.clone());
            vertices.push(vc.clone());
            face.a = n;
            face.b = n + 1;
            face.c = n + 2;
        }
        geometry.vertices = vertices;
    };
    THREE.TessellateModifier = function (maxEdgeLength) {
        this.maxEdgeLength = maxEdgeLength;
    };
    THREE.TessellateModifier.prototype.modify = function (geometry) {
        var edge;
        var faces = [];
        var faceVertexUvs = [];
        var maxEdgeLengthSquared = this.maxEdgeLength * this.maxEdgeLength;
        for (var i = 0, il = geometry.faceVertexUvs.length; i < il; i++) {
            faceVertexUvs[i] = [];
        }
        for (var i = 0, il = geometry.faces.length; i < il; i++) {
            var face = geometry.faces[i];
            if (face instanceof THREE.Face3) {
                var a = face.a;
                var b = face.b;
                var c = face.c;
                var va = geometry.vertices[a];
                var vb = geometry.vertices[b];
                var vc = geometry.vertices[c];
                var dab = va.distanceToSquared(vb);
                var dbc = vb.distanceToSquared(vc);
                var dac = va.distanceToSquared(vc);
                if (dab > maxEdgeLengthSquared || dbc > maxEdgeLengthSquared || dac > maxEdgeLengthSquared) {
                    var m = geometry.vertices.length;
                    var triA = face.clone();
                    var triB = face.clone();
                    if (dab >= dbc && dab >= dac) {
                        var vm = va.clone();
                        vm.lerp(vb, 0.5);
                        triA.a = a;
                        triA.b = m;
                        triA.c = c;
                        triB.a = m;
                        triB.b = b;
                        triB.c = c;
                        if (face.vertexNormals.length === 3) {
                            var vnm = face.vertexNormals[0].clone();
                            vnm.lerp(face.vertexNormals[1], 0.5);
                            triA.vertexNormals[1].copy(vnm);
                            triB.vertexNormals[0].copy(vnm);
                        }
                        if (face.vertexColors.length === 3) {
                            var vcm = face.vertexColors[0].clone();
                            vcm.lerp(face.vertexColors[1], 0.5);
                            triA.vertexColors[1].copy(vcm);
                            triB.vertexColors[0].copy(vcm);
                        }
                        edge = 0;
                    } else if (dbc >= dab && dbc >= dac) {
                        var vm = vb.clone();
                        vm.lerp(vc, 0.5);
                        triA.a = a;
                        triA.b = b;
                        triA.c = m;
                        triB.a = m;
                        triB.b = c;
                        triB.c = a;
                        if (face.vertexNormals.length === 3) {
                            var vnm = face.vertexNormals[1].clone();
                            vnm.lerp(face.vertexNormals[2], 0.5);
                            triA.vertexNormals[2].copy(vnm);
                            triB.vertexNormals[0].copy(vnm);
                            triB.vertexNormals[1].copy(face.vertexNormals[2]);
                            triB.vertexNormals[2].copy(face.vertexNormals[0]);
                        }
                        if (face.vertexColors.length === 3) {
                            var vcm = face.vertexColors[1].clone();
                            vcm.lerp(face.vertexColors[2], 0.5);
                            triA.vertexColors[2].copy(vcm);
                            triB.vertexColors[0].copy(vcm);
                            triB.vertexColors[1].copy(face.vertexColors[2]);
                            triB.vertexColors[2].copy(face.vertexColors[0]);
                        }
                        edge = 1;
                    } else {
                        var vm = va.clone();
                        vm.lerp(vc, 0.5);
                        triA.a = a;
                        triA.b = b;
                        triA.c = m;
                        triB.a = m;
                        triB.b = b;
                        triB.c = c;
                        if (face.vertexNormals.length === 3) {
                            var vnm = face.vertexNormals[0].clone();
                            vnm.lerp(face.vertexNormals[2], 0.5);
                            triA.vertexNormals[2].copy(vnm);
                            triB.vertexNormals[0].copy(vnm);
                        }
                        if (face.vertexColors.length === 3) {
                            var vcm = face.vertexColors[0].clone();
                            vcm.lerp(face.vertexColors[2], 0.5);
                            triA.vertexColors[2].copy(vcm);
                            triB.vertexColors[0].copy(vcm);
                        }
                        edge = 2;
                    }
                    faces.push(triA, triB);
                    geometry.vertices.push(vm);
                    for (var j = 0, jl = geometry.faceVertexUvs.length; j < jl; j++) {
                        if (geometry.faceVertexUvs[j].length) {
                            var uvs = geometry.faceVertexUvs[j][i];
                            var uvA = uvs[0];
                            var uvB = uvs[1];
                            var uvC = uvs[2];
                            if (edge === 0) {
                                var uvM = uvA.clone();
                                uvM.lerp(uvB, 0.5);
                                var uvsTriA = [uvA.clone(), uvM.clone(), uvC.clone()];
                                var uvsTriB = [uvM.clone(), uvB.clone(), uvC.clone()];
                            } else if (edge === 1) {
                                var uvM = uvB.clone();
                                uvM.lerp(uvC, 0.5);
                                var uvsTriA = [uvA.clone(), uvB.clone(), uvM.clone()];
                                var uvsTriB = [uvM.clone(), uvC.clone(), uvA.clone()];
                            } else {
                                var uvM = uvA.clone();
                                uvM.lerp(uvC, 0.5);
                                var uvsTriA = [uvA.clone(), uvB.clone(), uvM.clone()];
                                var uvsTriB = [uvM.clone(), uvB.clone(), uvC.clone()];
                            }
                            faceVertexUvs[j].push(uvsTriA, uvsTriB);
                        }
                    }
                } else {
                    faces.push(face);
                    for (var j = 0, jl = geometry.faceVertexUvs.length; j < jl; j++) {
                        faceVertexUvs[j].push(geometry.faceVertexUvs[j][i]);
                    }
                }
            }
        }
        geometry.faces = faces;
        geometry.faceVertexUvs = faceVertexUvs;
    };
    function Statue(options) {
        this.scene = new THREE.Object3D();
        this.shaders = options.shaders;
        this.assets = options.assets;
        this.params = options.params;
        this.intro = options.intro;
        this.setup();
    }
    Statue.prototype.constructor = Statue;
    Statue.prototype = underscoreMin.extend(Object.create({}), {
        setup: function () {
            this.assets.mesh.traverse(
                underscoreMin.bind(function (child) {
                    if (child instanceof THREE.Mesh) this.mesh = child.clone();
                }, this)
            );
            var geometry = this.getGeometry(),
                material = this.getMaterial();
            this.mesh.geometry = geometry;
            this.mesh.material = material;
            this.mesh.layers.set(0);
            this.mesh.position.y = 0.01;
            this.mesh.scale.x = 0.95;
            this.mesh.scale.y = 0.95;
            this.mesh.scale.z = 0.95;
            this.scene.add(this.mesh);
        },
        render: function () {
            this.mesh.material.uniforms.time.value += 0.01;
        },
        tweenIn: function () {
            var material = this.mesh.material,
                noise = this.params.noise,
                expo = this.params.expo,
                ease = Cubic.easeInOut,
                twist = expo[0],
                disp = expo[1],
                duration = 5;
            return new TimelineMax({
                tweens: [
                    new TimelineMax({
                        tweens: [
                            TweenMax.to(material.uniforms.ta, 0, { value: noise[0], ease: ease }),
                            TweenMax.to(material.uniforms.tb, 0, { value: noise[1], ease: ease }),
                            TweenMax.to(material.uniforms.tc, 0, { value: noise[2], ease: ease }),
                            TweenMax.to(material.uniforms.td, duration, { value: noise[3], ease: ease }),
                            TweenMax.to(material.uniforms.te, duration, { value: noise[4], ease: ease }),
                            TweenMax.to(material.uniforms.tf, 0, { value: noise[5], ease: ease }),
                        ],
                    }),
                    new TimelineMax({
                        tweens: [
                            TweenMax.to(material.uniforms.da, 0, { value: disp[0], ease: ease }),
                            TweenMax.to(material.uniforms.db, 0, { value: disp[1], ease: ease }),
                            TweenMax.to(material.uniforms.dc, 0, { value: disp[2], ease: ease }),
                            TweenMax.to(material.uniforms.dd, duration, { value: 0, ease: ease }),
                            TweenMax.to(material.uniforms.de, duration, { value: 0, ease: ease }),
                        ],
                    }),
                    new TimelineMax({
                        tweens: [
                            TweenMax.to(material.uniforms.scaleX, duration, { value: 1, ease: ease }),
                            TweenMax.to(material.uniforms.scaleY, duration, { value: 1, ease: ease }),
                            TweenMax.to(material.uniforms.scaleZ, duration, { value: 1, ease: ease }),
                        ],
                    }),
                ],
            });
        },
        tweenOut: function () {
            var material = this.mesh.material,
                noise = this.params.noise,
                expo = this.params.expo,
                ease = Cubic.easeInOut,
                twist = expo[0],
                disp = expo[1],
                duration = 5;
            return new TimelineMax({
                tweens: [
                    new TimelineMax({
                        tweens: [
                            TweenMax.to(material.uniforms.da, 0, { value: disp[0], ease: ease }),
                            TweenMax.to(material.uniforms.db, 0, { value: disp[1], ease: ease }),
                            TweenMax.to(material.uniforms.dc, 0, { value: disp[2], ease: ease }),
                            TweenMax.to(material.uniforms.dd, duration, { value: disp[3], ease: ease }),
                            TweenMax.to(material.uniforms.de, duration, { value: disp[4], ease: ease }),
                        ],
                    }),
                    new TimelineMax({
                        tweens: [
                            TweenMax.to(material.uniforms.scaleX, duration, { value: 0, ease: ease }),
                            TweenMax.to(material.uniforms.scaleY, duration, { value: 0, ease: ease }),
                            TweenMax.to(material.uniforms.scaleZ, duration, { value: 0, ease: ease }),
                        ],
                    }),
                ],
            });
        },
        spreadOut: function () {
            var material = this.mesh.material,
                noise = this.params.noise,
                expo = this.params.expo,
                ease = Cubic.easeInOut,
                twist = expo[0],
                disp = expo[1],
                duration = 5;
            return new TimelineMax({
                tweens: [
                    new TimelineMax({
                        tweens: [
                            TweenMax.to(material.uniforms.ta, 0, { value: 0.5, ease: ease }),
                            TweenMax.to(material.uniforms.tb, duration, { value: 5, ease: ease }),
                            TweenMax.to(material.uniforms.td, duration, { value: 0.1, ease: ease }),
                            TweenMax.to(material.uniforms.te, duration, { value: 1, ease: ease }),
                        ],
                    }),
                    new TimelineMax({
                        tweens: [
                            TweenMax.to(material.uniforms.da, 0, { value: disp[0], ease: ease }),
                            TweenMax.to(material.uniforms.db, 0, { value: disp[1], ease: ease }),
                            TweenMax.to(material.uniforms.dc, 0, { value: disp[2], ease: ease }),
                            TweenMax.to(material.uniforms.dd, duration, { value: disp[3], ease: ease }),
                            TweenMax.to(material.uniforms.de, duration, { value: disp[4], ease: ease }),
                        ],
                    }),
                    new TimelineMax({ tweens: [] }),
                ],
            });
        },
        getGeometry: function () {
            var geometry = new THREE.Geometry().fromBufferGeometry(this.mesh.geometry),
                tessellateModifier = new THREE.TessellateModifier(8),
                explodeModifier = new THREE.ExplodeModifier();
            geometry.mergeVertices();
            if (this.assets.texture)
                for (var i = 0; i < 12; i++) {
                    tessellateModifier.modify(geometry);
                }
            explodeModifier.modify(geometry);
            var numFaces = geometry.faces.length;
            geometry = new THREE.BufferGeometry().fromGeometry(geometry);
            var positions = geometry.attributes.position,
                displacement = new Float32Array(numFaces * 3 * 3),
                tempcolors = new Float32Array(numFaces * 3 * 3),
                colors = new Float32Array(numFaces * 3 * 3),
                indices = new Float32Array(numFaces * 3),
                offsets = new Float32Array(numFaces * 3),
                vColor = new THREE.Color(16776960),
                hColor = new THREE.Color(16711935),
                index,
                uvs,
                f,
                v,
                y,
                c;
            for (f = 0; f < numFaces; ++f) {
                index = 9 * f;
                y = positions.array[index + 1] / 2.75;
                c = 0.75 + y / 3;
                for (v = 0; v < 3; ++v) {
                    indices[index + 3 * v] = f;
                    indices[index + 3 * v + 1] = f;
                    indices[index + 3 * v + 2] = f;
                    if (y == 0) {
                        indices[index + 3 * v] = 0;
                        indices[index + 3 * v + 1] = 0;
                        indices[index + 3 * v + 2] = 0;
                        offsets[index + 3 * v] = 0.5;
                        offsets[index + 3 * v + 1] = 0.5;
                        offsets[index + 3 * v + 2] = 0.5;
                        colors[index + 3 * v] = hColor.r;
                        colors[index + 3 * v + 1] = hColor.g;
                        colors[index + 3 * v + 2] = hColor.b;
                        displacement[index + 3 * v] = -1;
                        displacement[index + 3 * v + 1] = -1;
                        displacement[index + 3 * v + 2] = -1;
                    } else {
                        y = positions.array[index + 3 * v + 1] / 2.75;
                        offsets[index + 3 * v] = 1 - y;
                        offsets[index + 3 * v + 1] = 1 - y;
                        offsets[index + 3 * v + 2] = 1 - y;
                        colors[index + 3 * v] = vColor.r;
                        colors[index + 3 * v + 1] = vColor.g * (1 - y);
                        colors[index + 3 * v + 2] = vColor.b;
                        displacement[index + 3 * v] = 1;
                        displacement[index + 3 * v + 1] = 1;
                        displacement[index + 3 * v + 2] = 1;
                    }
                    if (!this.assets.texture) {
                        tempcolors[index + 3 * v] = c;
                        tempcolors[index + 3 * v + 1] = c;
                        tempcolors[index + 3 * v + 2] = c;
                    }
                }
            }
            geometry.addAttribute("displacement", new THREE.BufferAttribute(displacement, 3));
            geometry.addAttribute("customColor", new THREE.BufferAttribute(colors, 3));
            geometry.addAttribute("tempColor", new THREE.BufferAttribute(tempcolors, 3));
            geometry.addAttribute("offsets", new THREE.BufferAttribute(offsets, 1));
            geometry.addAttribute("indices", new THREE.BufferAttribute(indices, 1));
            if (geometry.attributes.uv) {
                uvs = geometry.attributes.uv.array;
                geometry.addAttribute("uv2", new THREE.BufferAttribute(uvs, 2));
            }
            return geometry;
        },
        getMaterial: function () {
            var intro = this.intro,
                expo = this.params.expo,
                noise = this.params.noise,
                twist = expo[0],
                disp = expo[1],
                uniforms = THREE.UniformsUtils.merge([
                    THREE.ShaderLib["phong"].uniforms,
                    {
                        color: { value: new THREE.Color(16777215) },
                        emissive: { value: new THREE.Color(1381653) },
                        lightMap: { type: "t", value: null },
                        time: { value: 0 },
                        colorize: { value: 0 },
                        translationX: { value: 0 },
                        translationY: { value: 0 },
                        translationZ: { value: 0 },
                        rotationX: { value: 0 },
                        rotationY: { value: 0 },
                        rotationZ: { value: 0 },
                        scaleX: { value: intro ? 1 : 0 },
                        scaleY: { value: intro ? 1 : 0 },
                        scaleZ: { value: intro ? 1 : 0 },
                        ta: { value: intro ? noise[0] : twist[0] },
                        tb: { value: intro ? noise[1] : twist[1] },
                        tc: { value: intro ? noise[2] : twist[2] },
                        td: { value: intro ? noise[3] : twist[3] },
                        te: { value: intro ? noise[4] : twist[4] },
                        tf: { value: intro ? noise[5] : twist[5] },
                        da: { value: disp[0] },
                        db: { value: disp[1] },
                        dc: { value: disp[2] },
                        dd: { value: intro ? 0 : disp[3] },
                        de: { value: intro ? 0 : disp[4] },
                    },
                ]),
                material = new THREE.ShaderMaterial({ uniforms: uniforms, vertexShader: this.shaders.vs, fragmentShader: this.shaders.fs, lights: true, fog: true });
            if (this.assets.texture) material.uniforms.lightMap.value = this.assets.texture;
            return material;
        },
        destroy: function () {
            this.scene.remove(this.mesh);
            this.scene = null;
            this.mesh = null;
            this.shaders = null;
            this.assets = null;
            this.intro = null;
        },
    });
    function Spline(options) {
        this.scene = new THREE.Object3D();
        this.assets = options.assets;
        this.setup();
    }
    Spline.prototype.constructor = Spline;
    Spline.prototype = underscoreMin.extend(Object.create({}), {
        setup: function () {
            var geometry = new THREE.Geometry(),
                dae = this.assets.scene,
                store = [],
                points,
                vector,
                scale;
            dae.traverse(function (child) {
                if (child.scale.x != 1) scale = child.scale;
                if (child instanceof THREE.Line) points = child.geometry.vertices;
            });
            for (var i = 0; i < points.length; ++i) {
                vector = new THREE.Vector3(points[i].x * scale.x, points[i].y * scale.y, points[i].z * scale.z);
                store.push(vector);
            }
            this.curve = new THREE.CatmullRomCurve3(store);
            var splineLength = store.length,
                splinePoints = this.curve.getPoints(splineLength);
            for (var i = 0; i < splinePoints.length; ++i) {
                geometry.vertices.push(splinePoints[i]);
            }
        },
        destroy: function () {
            this.scene.remove(this.line);
            this.line = null;
            this.scene = null;
            this.curve = null;
            this.assets = null;
        },
    });
    function Slider(options) {
        this.stage = new PIXI.Sprite();
        this.$el = $('<div class="slider" />');
        this.index = (options.index + 1 < 9 ? "0" : "") + (options.index + 2);
        if (this.index == "13") this.index = "";
        this.locale = options.locale;
        this.lang = options.lang;
        this.timeline = null;
        this.snapOut = false;
        this.moved = false;
        this.angle = 0;
        this.setup();
    }
    Slider.prototype.constructor = Slider;
    Slider.prototype = underscoreMin.extend(Object.create({}), {
        setup: function () {
            var dot,
                numDots = 80,
                radius = 168,
                circle = 1.5 * Math.PI,
                angle = circle / numDots;
            this.clock = new PIXI.Sprite();
            for (var i = 0, j = 0; i < circle; i += angle, ++j) {
                dot = new PIXI.Graphics();
                dot.beginFill(10066329, 1);
                dot.drawCircle(0, 0, 1);
                dot.angle = i - Math.PI / 2;
                if (j > 1 && j < numDots - 2) this.clock.addChildAt(dot, 0);
            }
            this.stage.addChild(this.clock);
            this.$el.append(
                $(
                    [
                        '<div class="dragger">',
                        '<svg xmlns="http://www.w3.org/2000/svg" class="waves">',
                        '<circle cx="0" cy="0" r="50" fill="none" stroke="#999999" stroke-width="2" />',
                        '<circle cx="0" cy="0" r="50" fill="none" stroke="#999999" stroke-width="2" />',
                        "</svg>",
                        '<div class="hitarea"></div>',
                        '<div class="circle"></div>',
                        "</div>",
                        '<div class="snapper">',
                        '<svg xmlns="http://www.w3.org/2000/svg" class="waves">',
                        '<circle cx="0" cy="0" r="50" fill="none" stroke="#999999" stroke-width="2" />',
                        '<circle cx="0" cy="0" r="50" fill="none" stroke="#999999" stroke-width="2" />',
                        "</svg>",
                        '<div class="circle"></div>',
                        "</div>",
                        '<div class="tutorial"><span class="timsans-bold">' + this.locale.ui.drag[this.lang] + "</span></div>",
                        '<p><span class="timsans-bold">' + this.index + "</span></p>",
                        '<span class="left line"></span>',
                        '<span class="right line"></span>',
                    ]
                        .join()
                        .replace(/,/g, "")
                )
            );
            TweenMax.set(this.$el.find("p"), { rotation: -90 });
            this.dragTimeline = this.getTimeline(this.$el.find(".dragger svg circle"), 0.35, 0.35, -1);
            this.snapTimeline = this.getTimeline(this.$el.find(".snapper svg circle"), 0.35, 0.15, -1);
            this.move(-Math.PI / 2);
            this.hide();
        },
        getTimeline: function (holder, stagger, delay, repeat) {
            var tweens = [];
            underscoreMin.each(holder, function (wave) {
                transformWave(wave, 0.1, 0);
                tweens.push(
                    TweenMax.to({ scale: 0.1, alpha: 0 }, 2, {
                        ease: Cubic.easeOut,
                        bezier: {
                            curviness: 0,
                            values: [
                                { scale: 0.3, alpha: 0.6 },
                                { scale: 1, alpha: 0 },
                            ],
                        },
                        onUpdate: function () {
                            transformWave(wave, this.target.scale, this.target.alpha);
                        },
                    })
                );
            });
            function transformWave(wave, scale, alpha) {
                var r = parseInt($(wave).attr("r")),
                    a = alpha,
                    s = scale,
                    x = r / s,
                    y = r / s;
                $(wave)
                    .attr("stroke-opacity", a)
                    .attr("transform", "scale(" + s + ") translate(" + x + "," + y + ")");
            }
            return new TimelineMax({ tweens: tweens, stagger: stagger, delay: delay, repeat: repeat, paused: true });
        },
        hide: function () {
            underscoreMin.each(this.clock.children, function (dot) {
                dot.radius = 148;
            });
            TweenMax.set(this.$el.find(".dragger"), { scale: 0 });
            TweenMax.set(this.$el.find(".tutorial span"), { y: 20, force3D: true });
            TweenMax.set(this.$el.find(".left.line"), { scaleX: 0, x: 30, force3D: true });
            TweenMax.set(this.$el.find(".right.line"), { scaleX: 0, x: -30, force3D: true });
            TweenMax.set(this.$el.find("p"), { autoAlpha: 0, x: 20, force3D: true });
            TweenMax.set(this.$el.find(".snapper"), { scale: 0 });
        },
        move: function (angle) {
            this.angle = angle;
            var w = window.innerWidth,
                h = window.innerHeight,
                dx = Math.rotate(w < 768 ? 128 : 168, this.angle).x + w / 2,
                dy = Math.rotate(w < 768 ? 128 : 168, this.angle).y + h / 2,
                sx = Math.rotate(w < 768 ? 128 : 168, Math.PI).x + w / 2,
                sy = Math.rotate(w < 768 ? 128 : 168, Math.PI).y + h / 2;
            TweenMax.set(this.$el.find(".dragger"), { x: dx, y: dy });
            TweenMax.set(this.$el.find(".snapper"), { x: sx, y: sy });
        },
        tweenWavesIn: function (notutorial) {
            var tweens = [];
            tweens.push(TweenMax.to(this.$el.find(".dragger svg"), 0.6, { autoAlpha: 1, ease: Cubic.easeInOut }));
            if (!notutorial) tweens.push(TweenMax.to(this.$el.find(".tutorial span"), 0.8, { y: 0, force3D: true, ease: Cubic.easeOut }));
            return new TimelineMax({
                tweens: tweens,
                onStart: underscoreMin.bind(function () {
                    this.dragTimeline.play();
                }, this),
            });
        },
        tweenWavesOut: function () {
            var tweens = [];
            tweens.push(TweenMax.to(this.$el.find(".dragger svg"), 0.6, { autoAlpha: 0, ease: Cubic.easeInOut }));
            tweens.push(TweenMax.to(this.$el.find(".tutorial span"), 0.8, { y: 20, force3D: true, ease: Cubic.easeInOut }));
            return new TimelineMax({
                tweens: tweens,
                onStart: underscoreMin.bind(function () {
                    this.dragTimeline.pause();
                }, this),
            });
        },
        tweenSnapWavesIn: function () {
            var tweens = [];
            tweens.push(TweenMax.to(this.$el.find(".snapper svg"), 0.6, { autoAlpha: 1, ease: Cubic.easeInOut }));
            return new TimelineMax({
                tweens: tweens,
                onStart: underscoreMin.bind(function () {
                    this.snapTimeline.play();
                }, this),
            });
        },
        tweenSnapWavesOut: function () {
            var tweens = [];
            tweens.push(TweenMax.to(this.$el.find(".snapper svg"), 0.6, { autoAlpha: 0, ease: Cubic.easeInOut }));
            return new TimelineMax({
                tweens: tweens,
                onStart: underscoreMin.bind(function () { }, this),
                onComplete: underscoreMin.bind(function () {
                    this.snapTimeline.progress(0);
                }, this),
            });
        },
        tweenIn: function () {
            var tweens = [],
                clockTweens = [];
            underscoreMin.each(
                this.clock.children,
                function (dot) {
                    clockTweens.push(
                        TweenMax.to({ radius: dot.radius, alpha: dot.alpha, dot: dot }, 1.2, {
                            radius: 168,
                            alpha: 1,
                            ease: Elastic.easeOut,
                            easeParams: [0.6, 0.2],
                            onUpdate: function () {
                                this.target.dot.x = 190 + Math.cos(this.target.dot.angle) * this.target.radius;
                                this.target.dot.y = 190 + Math.sin(this.target.dot.angle) * this.target.radius;
                                this.target.dot.radius = this.target.radius;
                                this.target.dot.alpha = this.target.alpha;
                            },
                        })
                    );
                },
                this
            );
            tweens.push(TweenMax.to(this.$el.find(".snapper"), 1, { scale: 1, ease: Cubic.easeInOut }));
            tweens.push(TweenMax.to(this.$el.find("p"), 0.75, { autoAlpha: 1, x: 0, force3D: true, ease: Cubic.easeInOut }));
            tweens.push(
                new TimelineMax({
                    tweens: [
                        TweenMax.to(this.$el.find(".left.line"), 0.75, { scaleX: 1, x: 0, force3D: true, ease: Cubic.easeInOut }),
                        TweenMax.to(this.$el.find(".right.line"), 0.75, { scaleX: 1, x: 0, force3D: true, ease: Cubic.easeInOut }),
                    ],
                    stagger: 0.25,
                })
            );
            tweens.push(new TimelineMax({ tweens: clockTweens, stagger: 0.0175 }));
            tweens.push(TweenMax.to(this.$el.find(".dragger"), 1, { scale: 1, ease: Cubic.easeInOut }));
            if (!this.moved) tweens.push(TweenMax.to(this.$el.find(".tutorial span"), 0.75, { y: 0, force3D: true, ease: Cubic.easeOut }));
            return new TimelineMax({
                tweens: tweens,
                stagger: 0.25,
                onComplete: underscoreMin.bind(function () {
                    this.dragTimeline.play();
                }, this),
            });
        },
        tweenOut: function () {
            var tweens = [],
                clockTweens = [];
            underscoreMin.each(this.clock.children, function (dot) {
                clockTweens.push(
                    TweenMax.to({ radius: dot.radius, alpha: dot.alpha, dot: dot }, 1.2, {
                        radius: 148,
                        alpha: 0,
                        ease: Elastic.easeIn,
                        easeParams: [0.6, 0.2],
                        onUpdate: function () {
                            this.target.dot.x = 190 + Math.cos(this.target.dot.angle) * this.target.radius;
                            this.target.dot.y = 190 + Math.sin(this.target.dot.angle) * this.target.radius;
                            this.target.dot.radius = this.target.radius;
                            this.target.dot.alpha = this.target.alpha;
                        },
                    })
                );
            });
            tweens.push(new TimelineMax({ tweens: clockTweens, stagger: 0.015 }));
            tweens.push(TweenMax.to(this.$el.find(".dragger"), 1, { scale: 0, ease: Expo.easeInOut }));
            tweens.push(TweenMax.to(this.$el.find(".snapper"), 1, { scale: 0, ease: Expo.easeInOut }));
            tweens.push(TweenMax.to(this.$el.find("p"), 0.75, { autoAlpha: 0, x: -20, force3D: true, ease: Cubic.easeInOut }));
            tweens.push(
                new TimelineMax({
                    tweens: [
                        TweenMax.to(this.$el.find(".left.line"), 0.75, { scaleX: 0, x: -30, force3D: true, ease: Cubic.easeInOut }),
                        TweenMax.to(this.$el.find(".right.line"), 0.75, { scaleX: 0, x: 30, force3D: true, ease: Cubic.easeInOut }),
                    ],
                    stagger: 0.25,
                })
            );
            tweens.push(TweenMax.to(this.$el.find(".tutorial span"), 0.8, { y: 20, force3D: true, ease: Cubic.easeInOut }));
            return new TimelineMax({
                tweens: tweens,
                stagger: 0.15,
                onStart: underscoreMin.bind(function () {
                    this.snapOut = true;
                }, this),
                onComplete: underscoreMin.bind(function () {
                    this.snapOut = false;
                }, this),
            });
        },
        destroy: function () {
            if (this.timeline) this.timeline.kill();
            this.$el.remove();
            this.clock.destroy(true);
            this.stage.destroy(true);
            this.timeline = null;
            this.snapOut = null;
            this.locale = null;
            this.clock = null;
            this.stage = null;
            this.moved = null;
            this.lang = null;
            this.$el = null;
        },
    });
    function Columns(options) {
        this.scene = new THREE.Object3D();
        this.shaders = options.shaders;
        this.flames = options.flames;
        this.assets = options.assets;
        this.items = options.items;
        this.font = options.font;
        this.setup();
    }
    Columns.prototype.constructor = Columns;
    Columns.prototype = underscoreMin.extend(Object.create({}), {
        setup: function () {
            this.assets.mesh.traverse(
                underscoreMin.bind(function (child) {
                    if (child instanceof THREE.Mesh) this.mesh = child.clone();
                }, this)
            );
            underscoreMin.each(
                this.items,
                function (item, i) {
                    var column = new THREE.Object3D(),
                        label = this.getLabel(item.label, i),
                        bbox = this.getBbox(label),
                        mesh = this.getMesh();
                    mesh.scale.y = item.position.y - 0.015;
                    label.position.x += label.geometry.boundingBox.max.y / 2;
                    label.position.y += 0.05;
                    label.rotation.z = Math.PI / 2;
                    label.material.opacity = 0;
                    bbox.position.y = 0.05 + label.geometry.boundingBox.max.x / 2;
                    column.position.x = item.position.x;
                    column.position.y = item.position.y;
                    column.position.z = item.position.z;
                    column.modelId = item.id;
                    column.add(mesh);
                    column.add(label);
                    column.add(bbox);
                    this.scene.add(column);
                },
                this
            );
        },
        tweenIn: function () {
            var tweens = [];
            underscoreMin.each(this.scene.children, function (column) {
                var mesh = column.children[0],
                    label = column.children[1];
                tweens.push(new TimelineMax({ tweens: [TweenMax.to(label.material, 1.2, { opacity: 1, ease: Cubic.easeInOut }), TweenMax.to(mesh.material.uniforms.opacity, 1.2, { value: 1, ease: Cubic.easeInOut })] }));
            });
            return new TimelineMax({ tweens: tweens, stagger: 0.1 });
        },
        tweenOut: function () {
            var tweens = [];
            underscoreMin.each(this.scene.children, function (column) {
                var mesh = column.children[0],
                    label = column.children[1];
                tweens.push(
                    new TimelineMax({ tweens: [new TimelineMax({ tweens: [TweenMax.to(label.material, 1.2, { opacity: 0, ease: Cubic.easeInOut }), TweenMax.to(mesh.material.uniforms.opacity, 1.2, { value: 0, ease: Cubic.easeInOut })] })] })
                );
            });
            return new TimelineMax({ tweens: tweens, stagger: 0.1 });
        },
        getLabel: function (label, index) {
            var text = "0" + (index + 1) + " . " + label,
                textgeo = new THREE.TextGeometry(text.toUpperCase(), { font: this.font, size: 0.04, height: 0.0025, curveSegments: 6 }),
                textmat = new THREE.MeshBasicMaterial({ color: 6710886, transparent: true, wireframe: false });
            textgeo.computeBoundingBox();
            textgeo.computeVertexNormals();
            return new THREE.Mesh(textgeo, textmat);
        },
        getBbox: function (label) {
            var geometry = new THREE.PlaneGeometry(0.1, label.geometry.boundingBox.max.x, 16),
                material = new THREE.MeshLambertMaterial({ color: 6710886, transparent: true, opacity: 0 });
            return new THREE.Mesh(geometry, material);
        },
        getMesh: function () {
            var geometry = this.getGeometry(),
                material = this.getMaterial();
            return new THREE.Mesh(geometry, material);
        },
        getGeometry: function () {
            var geometry = new THREE.Geometry().fromBufferGeometry(this.mesh.geometry);
            geometry.mergeVertices();
            var numFaces = geometry.faces.length;
            geometry = new THREE.BufferGeometry().fromGeometry(geometry);
            var positions = geometry.attributes.position,
                displacement = new Float32Array(numFaces * 3 * 3),
                colors = new Float32Array(numFaces * 3 * 3),
                indices = new Float32Array(numFaces * 3),
                vColor = new THREE.Color(11703629),
                hColor = new THREE.Color(65280),
                index,
                uvs,
                f,
                v,
                y;
            for (f = 0; f < numFaces; ++f) {
                index = 9 * f;
                y = positions.array[index + 1];
                for (v = 0; v < 3; ++v) {
                    colors[index + 3 * v] = vColor.r;
                    colors[index + 3 * v + 1] = vColor.g;
                    colors[index + 3 * v + 2] = vColor.b;
                    indices[index + 3 * v] = f;
                    indices[index + 3 * v + 1] = f;
                    indices[index + 3 * v + 2] = f;
                    displacement[index + 3 * v] = 1;
                    displacement[index + 3 * v + 1] = 1;
                    displacement[index + 3 * v + 2] = 1;
                }
            }
            geometry.addAttribute("displacement", new THREE.BufferAttribute(displacement, 3));
            geometry.addAttribute("customColor", new THREE.BufferAttribute(colors, 3));
            geometry.addAttribute("indices", new THREE.BufferAttribute(indices, 1));
            if (geometry.attributes.uv) {
                uvs = geometry.attributes.uv.array;
                geometry.addAttribute("uv2", new THREE.BufferAttribute(uvs, 2));
            }
            return geometry;
        },
        getMaterial: function () {
            var uniforms = THREE.UniformsUtils.merge([
                THREE.ShaderLib["phong"].uniforms,
                {
                    color: { value: new THREE.Color(16777215) },
                    emissive: { value: new THREE.Color(1381653) },
                    alphamap: { type: "t", value: null },
                    lightMap: { type: "t", value: null },
                    opacity: { value: 0 },
                    time: { value: 0 },
                    colorize: { value: 0 },
                    translationX: { value: 0 },
                    translationY: { value: 0 },
                    translationZ: { value: 0 },
                    rotationX: { value: 0 },
                    rotationY: { value: 0 },
                    rotationZ: { value: 0 },
                    scaleX: { value: 1 },
                    scaleY: { value: 1 },
                    scaleZ: { value: 1 },
                    ta: { value: 0 },
                    tb: { value: 0.1122 },
                    tc: { value: 2.269 },
                    td: { value: 2.5 },
                    te: { value: 0 },
                    tf: { value: 0 },
                    da: { value: 0 },
                    db: { value: 0 },
                    dc: { value: 0 },
                    dd: { value: 0 },
                    de: { value: 0 },
                },
            ]),
                material = new THREE.ShaderMaterial({ uniforms: uniforms, vertexShader: this.shaders.vs, fragmentShader: this.shaders.fs, lights: true, fog: true });
            if (this.assets.texture) material.uniforms.lightMap.value = this.assets.texture;
            if (this.assets.alphamap) material.uniforms.alphaMap.value = this.assets.alphamap;
            material.transparent = true;
            return material;
        },
        destroy: function () {
            underscoreMin.each(
                this.scene.children,
                function (child) {
                    this.scene.remove(child);
                },
                this
            );
            this.scene = null;
            this.mesh = null;
            this.shaders = null;
            this.flames = null;
            this.assets = null;
            this.items = null;
            this.font = null;
        },
    });
    function ChapterHead(options) {
        this.$el = $('<div class="head" />');
        var index = options.index;
        this.index = (index < 9 ? "0" : "") + (index + 1);
        this.mobile = options.mobile;
        this.locale = options.locale;
        this.lang = options.lang;
        this.setup();
    }
    ChapterHead.prototype.constructor = ChapterHead;
    ChapterHead.prototype = underscoreMin.extend(Object.create({}), {
        setup: function () {
            this.$el.append(
                $(["<h2>", '<span class="trajan-pro">' + this.locale.ui.chapter[this.lang] + " " + this.index + "</span>", '\x3c!--<span class="trajan-pro num">' + this.index + "</span>--\x3e", "</h2>"].join().replace(/,/g, ""))
            );
            this.$el.find("h2").splitLetters();
            var $last = this.$el.find(".sl").last();
            this.$el.find(".sl").eq($last.index()).addClass("num");
            this.$el
                .find(".sl")
                .eq($last.index() - 1)
                .addClass("num");
            this.hide();
        },
        hide: function () {
            var store = $.shuffle(this.$el.find("h2").data("store")),
                index,
                $letter,
                y;
            underscoreMin.each(store, function (letter) {
                ($letter = $(letter)), (index = $letter.index()), (y = index < store.length - 2 ? 80 : -80);
                TweenMax.set(letter, { y: y, force3D: true, ease: Cubic.easeInOut });
            });
        },
        tweenIn: function () {
            var store = $.shuffle(this.$el.find("h2").data("store")),
                tweens = [],
                index,
                $letter,
                y;
            underscoreMin.each(store, function (letter) {
                ($letter = $(letter)), (index = $letter.index()), (y = index < store.length - 2 ? 80 : -80);
                tweens.push(TweenMax.to(letter, 1.2, { y: 0, force3D: true, ease: Cubic.easeInOut }));
            });
            return new TimelineMax({ tweens: tweens, stagger: 0.075 });
        },
        tweenOut: function () {
            var store = $.shuffle(this.$el.find("h2").data("store")),
                tweens = [],
                index,
                $letter,
                y;
            underscoreMin.each(store, function (letter) {
                ($letter = $(letter)), (index = $letter.index()), (y = index < store.length - 2 ? 80 : -80);
                tweens.push(TweenMax.to(letter, 1.2, { y: y, force3D: true, ease: Cubic.easeInOut }));
            });
            return new TimelineMax({ tweens: tweens, stagger: 0.075 });
        },
        destroy: function () {
            this.$el.remove();
            this.$el = null;
            this.index = null;
            this.mobile = null;
        },
    });
    function ChapterTitle(options) {
        this.$el = $('<div class="title" />');
        this.text = options.text;
        this.mobile = options.mobile;
        this.setup();
    }
    ChapterTitle.prototype.constructor = ChapterTitle;
    ChapterTitle.prototype = underscoreMin.extend(Object.create({}), {
        setup: function () {
            this.$el.append($('<div class="table"><div class="table-cell"><h1><span class="trajan-pro">' + this.text + "</span></h1></div></div>"));
            this.$el.find("h1")[!this.mobile ? "splitLetters" : "splitRows"]();
            this.hide();
        },
        hide: function () {
            var store = this.$el.find("h1").data("store");
            underscoreMin.each(store, function (letter) {
                TweenMax.set(letter, { y: 60, force3D: true, ease: Cubic.easeInOut });
            });
        },
        tweenIn: function () {
            var store = this.$el.find("h1").data("store"),
                tweens = [];
            underscoreMin.each(store, function (letter) {
                tweens.push(TweenMax.to(letter, 1.2, { y: 0, force3D: true, ease: Cubic.easeInOut }));
            });
            return new TimelineMax({ tweens: tweens, stagger: 0.025 });
        },
        tweenOut: function () {
            var store = this.$el.find("h1").data("store"),
                tweens = [];
            underscoreMin.each(store, function (letter) {
                tweens.push(TweenMax.to(letter, 1.2, { y: -60, force3D: true, ease: Cubic.easeInOut }));
            });
            return new TimelineMax({ tweens: tweens, stagger: 0.025 });
        },
        destroy: function () {
            this.$el.remove();
            this.$el = null;
            this.text = null;
            this.mobile = null;
        },
    });
    function Loader(options) {
        this.stage = new PIXI.Sprite();
        this.$el = $('<div class="loader" />');
        this.progressTimeline = null;
        this.visible = false;
        this.active = false;
        this.setup();
    }
    Loader.prototype.constructor = Loader;
    Loader.prototype = underscoreMin.extend(Object.create({}), {
        setup: function () {
            var dot,
                numDots = 40,
                radius = 90,
                circle = 1.5 * Math.PI,
                angle = circle / numDots;
            this.clock = new PIXI.Sprite();
            for (var i = 0, j = 0; i < circle; i += angle, ++j) {
                dot = new PIXI.Graphics();
                dot.beginFill(10066329, 1);
                dot.drawCircle(0, 0, 1);
                dot.angle = i - Math.PI / 2;
                this.clock.addChild(dot);
            }
            this.stage.addChild(this.clock);
            this.$el.append(
                $(
                    ['<div class="counter">', '<div class="counter-mask">', '<div class="counter-wrap">', '<span class="count timsans-bold">00</span>', '<span class="symbol timsans-bold">%</span>', "</div>", "</div>", "</div>"]
                        .join()
                        .replace(/,/g, "")
                )
            );
            TweenMax.set(this.$el.find(".counter-wrap"), { scale: 0.25, autoAlpha: 0 });
        },
        abort: function () {
            if (this.progressTimeline) this.progressTimeline.kill();
            underscoreMin.each(this.clock.children, function (dot, i) {
                dot.start = false;
                dot.alpha = 0;
            });
        },
        progress: function (progress, delay) {
            var clockTweens = [];
            if (!this.active && !this.visible) TweenMax.to(this.$el.find(".counter-wrap"), 0.75, { scale: 1, autoAlpha: 1, delay: delay, ease: Cubic.easeOut });
            this.active = true;
            this.visible = true;
            this.$el.find(".count").html(Math.round(progress * 100));
            underscoreMin.each(this.clock.children, function (dot, i) {
                if (i < Math.round(progress * 40) && !dot.start) {
                    dot.start = true;
                    clockTweens.push(
                        TweenMax.fromTo(
                            { radius: 90, alpha: 1, dot: dot },
                            2,
                            { radius: 50, alpha: 0 },
                            {
                                radius: 90,
                                alpha: 1,
                                ease: Elastic.easeOut,
                                easeParams: [0.6, 0.2],
                                onUpdate: function () {
                                    var x = 190 + Math.cos(this.target.dot.angle) * this.target.radius,
                                        y = 190 + Math.sin(this.target.dot.angle) * this.target.radius,
                                        alpha = this.target.alpha;
                                    this.target.dot.alpha = alpha;
                                    this.target.dot.x = x;
                                    this.target.dot.y = y;
                                },
                            }
                        )
                    );
                }
            });
            this.progressTimeline = new TimelineMax({
                tweens: clockTweens,
                stagger: 0.02,
                delay: 0.15,
                onComplete: underscoreMin.bind(function () {
                    this.active = progress != 1;
                }, this),
            });
        },
        tweenOut: function (callback) {
            var clockTweens = [];
            this.visible = false;
            underscoreMin.each(this.clock.children, function (dot, i) {
                dot.start = false;
                clockTweens.push(
                    TweenMax.to({ radius: 90, alpha: 1, dot: dot }, 2, {
                        radius: 70,
                        alpha: 0,
                        ease: Elastic.easeInOut,
                        easeParams: [0.6, 0.2],
                        onUpdate: function () {
                            var x = 190 + Math.cos(this.target.dot.angle) * this.target.radius,
                                y = 190 + Math.sin(this.target.dot.angle) * this.target.radius,
                                alpha = this.target.alpha;
                            this.target.dot.alpha = alpha;
                            this.target.dot.x = x;
                            this.target.dot.y = y;
                        },
                    })
                );
            });
            TweenMax.killTweensOf(this.$el.find(".counter-wrap"));
            new TimelineMax({
                tweens: [new TimelineMax({ tweens: clockTweens, stagger: 0.02 }), TweenMax.to(this.$el.find(".counter-wrap"), 0.6, { scale: 0.25, autoAlpha: 0, force3D: true, ease: Cubic.easeInOut })],
                stagger: 1,
                onComplete: callback,
            });
        },
        destroy: function () {
            this.$el.remove();
            this.clock.destroy(true);
            this.stage.destroy(true);
            this.progressTimeline = null;
            this.clock = null;
            this.stage = null;
            this.$el = null;
        },
    });
    function Chapter(options) {
        this.scene = new THREE.Object3D();
        this.stage = new PIXI.Sprite();
        this.dom = $('<div id="chapter-ui-dom" />');
        this.contents = options.contents;
        this.shaders = options.shaders;
        this.assets = options.assets;
        this.mobile = options.mobile;
        this.locale = options.locale;
        this.model = options.model;
        this.intro = options.intro;
        this.index = options.index;
        this.font = options.font;
        this.lang = options.lang;
        this.toggleTimeline = null;
        this.moved = false;
        this.endnear = false;
        this.setup();
    }
    Chapter.prototype = {
        constructor: Chapter,
        setup: function () {
            this.statue = new Statue({ shaders: this.shaders.statue, assets: this.assets.statue, params: this.model.statue, intro: this.intro });
            this.columns = new Columns({ items: this.model.hotspots.items, shaders: this.shaders.hotspots, assets: this.assets.hotspots, font: this.font });
            this.spline = new Spline({ assets: this.assets.splines.scene });
            if (this.assets.splines.intro) {
                this.introspline = new Spline({ assets: this.assets.splines.intro });
                this.scene.add(this.introspline.scene);
            }
            this.head = new ChapterHead({ index: this.index, mobile: this.mobile, locale: this.locale, lang: this.lang });
            this.title = new ChapterTitle({ text: this.model.title, mobile: this.mobile });
            this.slider = new Slider({ index: this.index, locale: this.locale, mobile: this.mobile, lang: this.lang });
            this.loader = new Loader();
            this.scene.add(this.statue.scene);
            this.scene.add(this.spline.scene);
            this.scene.add(this.columns.scene);
            this.stage.addChild(this.slider.stage);
            this.stage.addChild(this.loader.stage);
            this.dom.append(this.head.$el);
            this.dom.append(this.title.$el);
            this.dom.append(this.slider.$el);
            this.dom.append(this.loader.$el);
        },
        start: function () {
            return new TimelineMax({ tweens: [this.slider.tweenIn(), this.title.tweenIn(), this.head.tweenIn()], stagger: 0.25 });
        },
        move: function (angle, auto) {
            var zero = -Math.PI / 2,
                limit = Math.PI - 1.15;
            this.slider.move(angle);
            if (!this.moved && angle > zero) {
                this.toggle(true);
                this.slider.moved = true;
                this.moved = true;
            }
            if (this.moved && angle <= zero && !auto) {
                this.toggle(false);
                this.slider.moved = false;
                this.moved = false;
            }
            if (!this.endnear && angle > limit && !auto) {
                this.blinkSnap(true);
                this.endnear = true;
            }
            if (this.endnear && angle < limit) {
                this.blinkSnap(false);
                this.endnear = false;
            }
        },
        toggle: function (toggle) {
            if (this.toggleTimeline) this.toggleTimeline.kill();
            if (!toggle) this.toggleTimeline = new TimelineMax({ tweens: [this.slider.tweenWavesIn(), this.columns.tweenOut(), this.title.tweenIn()], stagger: 0.1 });
            else this.toggleTimeline = new TimelineMax({ tweens: [this.title.tweenOut(), this.columns.tweenIn(), this.slider.tweenWavesOut()], stagger: 0.1 });
        },
        blinkSnap: function (toggle) {
            if (toggle) this.slider.tweenSnapWavesIn();
            else this.slider.tweenSnapWavesOut();
            this.endnear = toggle;
        },
        blinkDrag: function () {
            this.slider.tweenWavesIn(true);
            this.moved = false;
        },
        setIntersects: function (intersect, click, enterCallback, clickCallback) {
            if (intersect)
                underscoreMin.each(
                    this.columns.scene.children,
                    function (column, i) {
                        var mesh = column.children[0],
                            label = column.children[1],
                            bbox = column.children[2];
                        if (intersect && (intersect.id == mesh.id || intersect.id == label.id || intersect.id == bbox.id)) {
                            if (!click) {
                                if (!column.onfire && this.getHotspotsVisibility()) {
                                    this.selectColumn(i, false);
                                    if (enterCallback) enterCallback.call(null, column.modelId);
                                }
                            } else {
                                this.selectColumn(i, true);
                                clickCallback.call(null, column.modelId);
                            }
                        }
                    },
                    this
                );
            else this.selectColumn(-1, false);
        },
        selectColumn: function (index, active) {
            underscoreMin.each(
                this.columns.scene.children,
                function (column, i) {
                    var mesh = column.children[0],
                        label = column.children[1],
                        bbox = column.children[2];
                    if (!active) {
                        if (i == index && !column.onfire) {
                            column.onfire = true;
                            TweenMax.to(mesh.material.uniforms.color.value, 1.2, { r: 0.6980392156862745, g: 0.5843137254901961, b: 0.30196078431372547, ease: Cubic.easeOut });
                        } else if (column.onfire && !column.active) {
                            column.onfire = false;
                            TweenMax.to(mesh.material.uniforms.color.value, 1, { r: 1, g: 1, b: 1, ease: Cubic.easeOut });
                        }
                    } else {
                        if (i == index && !column.active) {
                            column.active = true;
                            column.onfire = true;
                            TweenMax.to(mesh.material.uniforms.color.value, 1.2, { r: 0.6980392156862745, g: 0.5843137254901961, b: 0.30196078431372547, ease: Cubic.easeOut });
                        } else if (column.active) {
                            column.active = false;
                            column.onfire = false;
                            TweenMax.to(mesh.material.uniforms.color.value, 1, { r: 1, g: 1, b: 1, ease: Cubic.easeOut });
                        }
                    }
                },
                this
            );
        },
        render: function () {
            if (this.statue) this.statue.render();
        },
        tweenIn: function () {
            var tweens = [];
            tweens.push(this.statue.tweenIn());
            tweens.push(new TimelineMax({ tweens: [this.slider.tweenIn(), this.title.tweenIn(), this.head.tweenIn()], stagger: 0.25 }));
            return new TimelineMax({ tweens: tweens, stagger: 2 });
        },
        tweenOut: function () {
            var tweens = [];
            tweens.push(this.statue.tweenOut());
            tweens.push(new TimelineMax({ tweens: [this.columns.tweenOut(), this.slider.tweenOut(), this.title.tweenOut(), this.head.tweenOut()], stagger: 0.25 }));
            return new TimelineMax({ tweens: tweens });
        },
        spreadOut: function () {
            var tweens = [];
            tweens.push(this.statue.spreadOut());
            tweens.push(new TimelineMax({ tweens: [this.columns.tweenOut(), this.title.tweenOut(), this.head.tweenOut()], stagger: 0.25 }));
            return new TimelineMax({ tweens: tweens });
        },
        getHotspotsVisibility: function () {
            var columns = this.columns.scene,
                column = columns.children[0],
                mesh = column.children[0];
            return mesh.material.uniforms.opacity.value > 0;
        },
        getSplinePointAt: function (index, intro) {
            if (index <= 0) index = 0;
            if (index >= 1) index = 1;
            return !intro ? this.spline.curve.getPointAt(index) : this.introspline.curve.getPointAt(index);
        },
        destroy: function () {
            if (this.toggleTimeline) this.toggleTimeline.kill();
            this.scene.remove(this.statue.scene);
            this.scene.remove(this.columns.scene);
            this.scene.remove(this.spline.scene);
            this.stage.removeChild(this.slider.stage);
            this.stage.removeChild(this.loader.stage);
            this.statue.destroy();
            this.columns.destroy();
            this.spline.destroy();
            this.head.destroy();
            this.title.destroy();
            this.slider.destroy();
            this.loader.destroy();
            if (this.introspline) {
                this.introspline.destroy();
                this.introspline = null;
            }
            this.statue = null;
            this.columns = null;
            this.spline = null;
            this.head = null;
            this.title = null;
            this.slider = null;
            this.loader = null;
            this.stage.destroy(true);
            this.dom.remove();
            this.scene = null;
            this.stage = null;
            this.dom = null;
            this.toggleTimeline = null;
            this.contents = null;
            this.shaders = null;
            this.assets = null;
            this.mobile = null;
            this.locale = null;
            this.model = null;
            this.intro = null;
            this.index = null;
            this.font = null;
            this.lang = null;
            this.moved = null;
        },
    };
    Object.assign(Chapter.prototype, EventDispatcher.prototype);
    function CanvasController($scope, $state, $timeout, ShaderParser, ChapterLoader, MobileBrowser, SoundManager) {
        var renderers = {},
            tweener = {},
            scope = this,
            stateMachine,
            finalLoop,
            waitLoop,
            loadLoop,
            leafIndex,
            leafOpen,
            isTween,
            isWait,
            isLoad,
            isDrag,
            chapter,
            oldest,
            loader,
            target,
            mouse,
            index,
            angle,
            intro,
            leaf,
            gui;
        $scope.setup3Dcanvas = function (canvas) {
            renderers.d3 = new Renderer3d({ canvas: canvas });
            checkForRenderers();
        };
        $scope.setup2Dcanvas = function (canvas) {
            renderers.d2 = new Renderer2d({ canvas: canvas });
            checkForRenderers();
        };
        function checkForRenderers() {
            if (renderers.d3 && renderers.d2) setup();
            $(window).trigger(Events.RESIZE);
        }
        function setup() {
            renderers.dom = { chapter: $("#chapter-ui"), ui: $("#app-ui") };
            stateMachine = new StateMachine();
            SoundManager.setup();
            angle = -Math.PI / 2;
            intro = true;
            addLoader();
            addEvents();
            addGui();
        }
        function addLoader() {
            loader = new Loader();
            renderers.d2.append(loader.stage);
            renderers.dom.ui.append(loader.$el);
            $scope.$watch("store.progress", function (progress) {
                loader.progress(progress);
            });
            $scope.$watch("store.loaded", function (loaded) {
                if (loaded)
                    $timeout(function () {
                        loader.tweenOut(function () {
                            renderers.d2.remove(loader.stage);
                            loader.destroy();
                            loader = null;
                            scope.dispatch(Events.READY);
                        });
                    }, 600);
            });
        }
        function addEvents() {
            scope.listen(Events.CHANGE_STATE, onChangeState);
            scope.listen(Events.REMOVE_STATE, onRemoveState);
            scope.listen(Events.START_STATE, onStartState);
            scope.listen(Events.ADD_STATE, onAddState);
            scope.listen(Events.LEAF_PREV, onLeafPrevState);
            scope.listen(Events.LEAF_NEXT, onLeafNextState);
            scope.listen(Events.LEAF_CLOSE, onRemoveLeafState);
            scope.listen(Events.JOURNEY_COMPLETE, onJourneyComplete);
            scope.listen(Events.INPUT_WHEEL, onWheel);
            scope.listen(Events.INPUT_START, onStart);
            scope.listen(Events.INPUT_MOVE, onMove);
            scope.listen(Events.INPUT_END, onEnd);
            scope.listen(Events.RENDER, render);
            scope.listen(Events.RESIZE, resize);
            $scope.$watch("store.intro", reveal);
        }
        function addGui() {
            gui = new dat.GUI();
            var folder = gui.addFolder("Controls");
            folder
                .add(params.debug, "angle", -Math.PI / 2, Math.PI, 0.001)
                .name("Angle")
                .onChange(update);
            gui.close();
        }
        function preload(index, limit) {
            var end = underscoreMin.isUndefined(limit) ? 2 : limit,
                start = underscoreMin.isUndefined(index) ? stateMachine.state.options.index + 2 : index;
            ChapterLoader.load(
                start,
                end,
                function (progress) { },
                function (chunk) {
                    $scope.store.data.models[chunk.key] = chunk.response;
                    console.info(chunk.key, "COMPLETE");
                }
            );
        }
        function reveal(intro) {
            if (intro) renderers.d3.reveal();
        }
        function onWheel(e, delta) {
            if ($scope.store.menuOpen || leafOpen || isTween || isWait || intro || !chapter) return;
            var startWheel = angle,
                endWheel = 0;
            endWheel = startWheel + THREE.Math.degToRad(Math.round(delta * 0.05) * -1);
            tweener.uiangle = tweener.camangle = angle;
            angle = endWheel;
            if (angle <= -Math.PI / 2) angle = -Math.PI / 2;
            if (angle >= Math.PI) angle = Math.PI;
            moveAround({ duration: 0.6, ease: Power3.easeOut, auto: false, onSnap: snap });
        }
        function onStart(e, options) {
            if (!chapter || isTween) return;
            target = options.target;
            isDrag = $(target).parent().hasClass("dragger");
            if (!isDrag && validate()) {
                if (!leafOpen || window.innerWidth > 767) intersects(options.mouse, true, null, onAddLeafState);
            }
        }
        function onMove(e, options) {
            if (!chapter) return;
            target = options.target;
            if (isDrag) {
                options.evt.preventDefault();
                tweener.uiangle = tweener.camangle = angle;
                angle = Math.atan2(options.mouse.y - window.innerHeight / 2, options.mouse.x - window.innerWidth / 2);
                if (angle + Math.PI / 2 < 0 && angle + Math.PI / 2 < -Math.PI / 4) angle = Math.PI;
                if ((angle + Math.PI / 2) / (Math.PI * 1.5) == 1) {
                    isDrag = false;
                    angle = Math.PI;
                    moveAround({ duration: 0, ease: Power3.easeOut, auto: false, onSnap: snap });
                } else if (angle < -Math.PI / 2 - 0.1) {
                    isDrag = false;
                    angle = -Math.PI / 2;
                    moveAround({ duration: 0.6, ease: Power3.easeOut, auto: false });
                } else moveAround({ duration: 0, ease: Power3.easeOut, auto: false });
            } else if (validate()) {
                intersects(options.mouse, false, function (id) { }, null);
            } else {
                $("#application").css({ cursor: "default" });
                chapter.setIntersects(false);
            }
        }
        function onEnd(e, options) {
            if (!chapter) return;
            if (isDrag) isDrag = false;
            else if (validate() && !MobileBrowser.get()) {
            }
        }
        function intersects(coords, click, enterCallback, clickCallback) {
            if (leafOpen) coords.x += 225;
            var intersect = renderers.d3.getIntersects(coords, chapter.columns.scene.children);
            $("#application").css({ cursor: intersect ? "pointer" : "default" });
            chapter.setIntersects(intersect, click, enterCallback, clickCallback);
        }
        function validate() {
            var isNavTarget = target && $(target).parents("#nav").length > 0,
                isHotspotsVisible = chapter.getHotspotsVisibility();
            return !intro && !isWait && !isTween && !isNavTarget && !$scope.store.menuOpen && isHotspotsVisible;
        }
        function moveAround(options) {
            var limit = (angle + Math.PI / 2) / (Math.PI * 1.5) == 1,
                onComplete = options.onComplete,
                onSnap = options.onSnap,
                duration = options.duration,
                easing = options.ease,
                auto = options.auto;
            if (duration == 0) {
                duration = 1.8;
                tweener.uiangle = angle;
                chapter.move(angle, auto);
                if (onSnap && limit) onSnap.call();
            } else {
                TweenMax.to(tweener, duration, {
                    uiangle: angle,
                    ease: easing,
                    onUpdate: function () {
                        chapter.move(this.target.uiangle, auto);
                    },
                    onComplete: function () {
                        if (onSnap && limit) onSnap.call();
                    },
                });
                duration *= 2;
                if (duration >= 4) duration = 4;
            }
            TweenMax.to(tweener, duration, {
                camangle: angle,
                ease: easing,
                onUpdate: function () {
                    renderers.d3.move(this.target.camangle);
                    params.debug.angle = this.target.camangle;
                    gui.updateDisplay();
                },
                onComplete: function () {
                    if (onComplete) onComplete.call();
                },
            });
        }
        function snap() {
            ++index;
            isWait = true;
            $scope.changeChapter({ index: index, snap: true });
            chapter.slider.tweenOut();
        }
        function waitingSnap(state) {
            var wait = true,
                counter = (tweener.camangle + Math.PI / 2) / (Math.PI * 1.5),
                lastIndex = stateMachine.state.options.index,
                currIndex = state.options.index,
                dir = currIndex > lastIndex ? 1 : -1,
                endDrag = dir > 0 ? Math.PI : -Math.PI / 2,
                startDrag = angle,
                distance = dir > 0 ? 1 - counter : counter,
                duration = 4 * distance;
            if (waitLoop) cancelAnimationFrame(waitLoop);
            if (leafOpen) {
                if (leaf && !leaf.active) {
                    onRemoveLeafState();
                    leaf.active = true;
                    waitingSnap(state);
                } else
                    waitLoop = requestAnimationFrame(function () {
                        waitingSnap(state);
                    });
            } else if (counter > 1e-4 && counter < 0.9998) {
                if (!state.options.snap) {
                    tweener.uiangle = tweener.camangle = angle;
                    angle = endDrag;
                    moveAround({
                        duration: duration,
                        ease: Cubic.easeInOut,
                        auto: true,
                        onComplete: function () {
                            state.options.snap = true;
                            waitingSnap(state);
                        },
                    });
                } else
                    waitLoop = requestAnimationFrame(function () {
                        waitingSnap(state);
                    });
            } else if (dir > 0 && counter <= 1e-4) {
                tweener.uiangle = tweener.camangle = angle;
                angle = endDrag;
                moveAround({
                    duration: duration,
                    ease: Cubic.easeInOut,
                    auto: true,
                    onComplete: function () {
                        state.options.snap = true;
                        waitingSnap(state);
                    },
                });
            } else if (chapter.slider.snapOut) {
                waitLoop = requestAnimationFrame(function () {
                    waitingSnap(state);
                });
            } else {
                if (state.params.to.chapter != stateMachine.state.params.to.chapter)
                    $timeout(function () {
                        onChangeState(null, state);
                    });
                wait = false;
            }
            return wait;
        }
        function waitingLoad(state) {
            var wait = true,
                currIndex = state.options.index,
                chunk = ChapterLoader.getChunk(currIndex);
            TweenMax.killTweensOf(tweener);
            if (loadLoop) cancelAnimationFrame(loadLoop);
            if (!chunk) {
                preload(currIndex, 2);
                waitingLoad(state);
            } else if (!chunk.loaded) {
                var loaderDelay = 0.15;
                if (!chapter.moved) {
                    chapter.title.tweenOut();
                    chapter.moved = true;
                    loaderDelay = 1.5;
                }
                chapter.loader.progress(chunk.progress, loaderDelay);
                loadLoop = requestAnimationFrame(function () {
                    waitingLoad(state);
                });
            } else if (chapter.loader.active) {
                if (!chapter.loader.normalized) {
                    chapter.loader.normalized = true;
                    chapter.loader.progress(1);
                }
                loadLoop = requestAnimationFrame(function () {
                    waitingLoad(state);
                });
            } else if (chapter.loader.visible) {
                chapter.loader.tweenOut();
                waitingLoad(state);
            } else {
                if (state.params.to.chapter != stateMachine.state.params.to.chapter)
                    $timeout(function () {
                        onChangeState(null, state);
                    });
                isLoad = false;
                wait = false;
            }
            return wait;
        }
        function onChangeState(e, state) {
            if (!stateMachine.state) {
                SoundManager.play("ambient", true, true);
                stateMachine.setState(state);
                return;
            }
            if (!isLoad && !isTween && !intro) isWait = waitingSnap(state);
            if (isWait || state.params.to.chapter == stateMachine.state.params.to.chapter) return;
            if (!isLoad && !isTween && !intro) isLoad = waitingLoad(state);
            if (isLoad || isTween) return;
            stateMachine.setState(state);
        }
        function onStartState(e, state) {
            intro = false;
            isTween = true;
            return new TimelineMax({
                tweens: [renderers.d3.start(), chapter.start()],
                stagger: 2,
                onStart: function () {
                    $scope.store.start = true;
                    $scope.$apply();
                },
                onComplete: function () {
                    isTween = false;
                    preload();
                },
            });
        }
        function onAddState(e, state) {
            index = $scope.store.intro ? $scope.store.initIndex : parseInt(state.options.index);
            var lang = $scope.store.lang,
                mobile = MobileBrowser.get(),
                font = $scope.store.data.typeface,
                locale = $scope.store.data.locale,
                model = $scope.store.data.book[index],
                assets = $scope.store.data.models[model.key],
                contents = $scope.store.data.contents[index],
                intro = underscoreMin.isUndefined(state.params.from.chapter),
                shaders = { statue: ShaderParser.parse($scope.store.data.shaders.statue, model.statue.shader), hotspots: ShaderParser.parse($scope.store.data.shaders.hotspots, model.hotspots.shader) };
            chapter = new Chapter({ contents: contents, shaders: shaders, assets: assets, mobile: mobile, locale: locale, model: model, index: index, intro: intro, font: font, lang: lang });
            renderers.d3.append(chapter.scene);
            renderers.d2.append(chapter.stage);
            renderers.dom.chapter.append(chapter.dom);
            tweener.uiangle = tweener.camangle = angle = -Math.PI / 2;
            if (intro) return;
            isTween = true;
            new TimelineMax({
                tweens: [renderers.d3.spin(), chapter.tweenIn()],
                delay: 0.25,
                onStart: function () {
                    SoundManager.play("update", true, false);
                    $scope.store.final = false;
                    $scope.$apply();
                },
                onComplete: function () {
                    isTween = false;
                    if (!isWait && state.params.to.chapter != $scope.store.state.params.to.chapter) onChangeState(null, $scope.store.state);
                    else preload();
                },
            });
        }
        function onRemoveState(e, state) {
            oldest = chapter;
            new TimelineMax({
                tweens: [oldest.tweenOut()],
                data: { chapter: oldest },
                delay: 0.25,
                onComplete: function () {
                    renderers.d3.remove(this.data.chapter.scene);
                    renderers.d2.remove(this.data.chapter.stage);
                    this.data.chapter.dom.remove();
                    this.data.chapter.destroy();
                },
            });
        }
        function onAddLeafState(id) {
            if (!chapter.contents) return;
            var contents = underscoreMin.where(chapter.contents, { id: id })[0],
                locale = $scope.store.data.locale,
                mobile = MobileBrowser.get(),
                lang = $scope.store.lang,
                duration = 1;
            leafIndex = underscoreMin.indexOf(chapter.contents, contents);
            if (leaf) duration = Math.abs(leafIndex - leaf.index) * 0.5;
            angle = contents.angle;
            moveAround({ duration: duration, ease: Power3.easeOut, auto: false });
            if (leaf && leafOpen) {
                if (leafIndex != leaf.index) {
                    leaf.index = leafIndex;
                    leaf.update(contents);
                    checkLeafUiState();
                }
                return;
            }
            leaf = new ChapterLeaf({ contents: contents, index: leafIndex, locale: locale, mobile: mobile, lang: lang });
            chapter.dom.append(leaf.$el);
            leafOpen = true;
            isTween = true;
            checkLeafUiState();
            new TimelineMax({
                tweens: [
                    new TimelineMax({ tweens: [chapter.slider.tweenOut(), chapter.head.tweenOut()] }),
                    new TimelineMax({
                        tweens: [TweenMax.to($("#app-3d-canvas"), 1, { x: -225, force3D: true, ease: Cubic.easeInOut }), leaf.tweenIn()],
                        stagger: 0.1,
                        onComplete: function () {
                            isTween = false;
                        },
                    }),
                ],
                stagger: 0.15,
                onComplete: underscoreMin.bind(leaf.initPage, leaf),
            });
            scope.dispatch(Events.LEAF_OPEN, true);
        }
        function onLeafPrevState(e) {
            if (!leaf || !leafOpen) return;
            if (leaf.updating) return;
            var index = leafIndex,
                contents;
            --index;
            if (index < 0) index = 0;
            if (index != leafIndex) {
                leaf.index = index;
                leafIndex = index;
                chapter.selectColumn(index, true);
                contents = chapter.contents[index];
                leaf.update(contents);
                angle = contents.angle;
                moveAround({ duration: 0.8, ease: Power3.easeOut, auto: false });
                checkLeafUiState();
            }
        }
        function onLeafNextState(e) {
            if (!leaf || !leafOpen) return;
            if (leaf.updating) return;
            var index = leafIndex,
                contents;
            ++index;
            if (index > chapter.contents.length - 1) index = chapter.contents.length - 1;
            if (index != leafIndex) {
                leaf.index = index;
                leafIndex = index;
                chapter.selectColumn(index, true);
                contents = chapter.contents[index];
                leaf.update(contents);
                angle = contents.angle;
                moveAround({ duration: 0.8, ease: Power3.easeOut, auto: false });
                checkLeafUiState();
            }
        }
        function checkLeafUiState() {
            $(".leaf-tools .prev")
                .data({ active: leaf.index != 0 })
            [leaf.index != 0 ? "addClass" : "removeClass"]("active");
            $(".leaf-tools .next")
                .data({ active: leaf.index != chapter.contents.length - 1 })
            [leaf.index != chapter.contents.length - 1 ? "addClass" : "removeClass"]("active");
        }
        function onRemoveLeafState() {
            if (!leaf) return;
            isTween = true;
            leafOpen = false;
            leaf.disable = true;
            new TimelineMax({
                tweens: [
                    new TimelineMax({
                        tweens: [leaf.tweenOut(), TweenMax.to($("#app-3d-canvas"), 1, { x: 0, force3D: true, ease: Cubic.easeInOut })],
                        stagger: 0.1,
                        onComplete: function () {
                            if (leaf) {
                                leaf.destroy();
                                leaf = null;
                            }
                            isTween = false;
                        },
                    }),
                    new TimelineMax({ tweens: [chapter.head.tweenIn(), chapter.slider.tweenIn()] }),
                ],
                stagger: 0,
                onStart: function () {
                    scope.dispatch(Events.LEAF_OPEN, false);
                    chapter.selectColumn(-1, true);
                },
                onComplete: function () {
                    chapter.blinkDrag();
                    if (!isWait && stateMachine.state.params.to.chapter != $scope.store.state.params.to.chapter) onChangeState(null, $scope.store.state);
                },
            });
        }
        function onJourneyComplete() {
            isWait = true;
            isTween = true;
            var counter = (tweener.camangle + Math.PI / 2) / (Math.PI * 1.5);
            if (finalLoop) cancelAnimationFrame(finalLoop);
            if (counter > 1e-4 && counter < 0.9998) {
                finalLoop = requestAnimationFrame(onJourneyComplete);
            } else {
                new TimelineMax({
                    tweens: [renderers.d3.spin(), chapter.spreadOut()],
                    data: {},
                    delay: 0.5,
                    onStart: function () {
                        SoundManager.play("update", true, false);
                        $scope.store.final = true;
                        $scope.$apply();
                    },
                    onComplete: function () {
                        isTween = false;
                        isWait = false;
                    },
                });
            }
        }
        function render() {
            if (renderers.d3) renderers.d3.render();
            if (renderers.d2) renderers.d2.render();
            if (chapter) {
                renderers.d3.moveCamera(chapter);
                chapter.render();
            }
        }
        function update(value) {
            angle = value;
            moveAround({ duration: 0.6, ease: Power3.easeOut, auto: false });
        }
        function resize(e, stagesize) {
            renderers.d3.resize(stagesize);
            if (chapter) chapter.slider.move(tweener.uiangle);
            if (leaf) leaf.resize(stagesize, leafOpen);
            TweenMax.set($("#app-3d-canvas"), { x: leafOpen ? -225 : 0 });
        }
    }
    Object.assign(CanvasController.prototype, EventDispatcher.prototype);
    function ShaderParser($q, $http) {
        String.prototype.strpos = function (str) {
            if (Array.isArray(str)) {
                for (var i = 0; i < str.length; i++) {
                    if (this.indexOf(str[i]) > -1) return true;
                }
                return false;
            } else {
                return this.indexOf(str) != -1;
            }
        };
        return {
            parse: function (store, alias) {
                var split = store.split("{@}"),
                    shaders = {};
                split.shift();
                for (var i = 0; i < split.length; i += 2) {
                    var name = split[i];
                    var text = split[i + 1];
                    shaders[name] = text;
                }
                return { vs: shaders[alias + ".vs"], fs: shaders[alias + ".fs"] };
            },
        };
    }
    THREE.OBJLoader = function (manager) {
        this.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;
        this.materials = null;
        this.regexp = {
            vertex_pattern: /^v\s+([\d|\.|\+|\-|e|E]+)\s+([\d|\.|\+|\-|e|E]+)\s+([\d|\.|\+|\-|e|E]+)/,
            normal_pattern: /^vn\s+([\d|\.|\+|\-|e|E]+)\s+([\d|\.|\+|\-|e|E]+)\s+([\d|\.|\+|\-|e|E]+)/,
            uv_pattern: /^vt\s+([\d|\.|\+|\-|e|E]+)\s+([\d|\.|\+|\-|e|E]+)/,
            face_vertex: /^f\s+(-?\d+)\s+(-?\d+)\s+(-?\d+)(?:\s+(-?\d+))?/,
            face_vertex_uv: /^f\s+(-?\d+)\/(-?\d+)\s+(-?\d+)\/(-?\d+)\s+(-?\d+)\/(-?\d+)(?:\s+(-?\d+)\/(-?\d+))?/,
            face_vertex_uv_normal: /^f\s+(-?\d+)\/(-?\d+)\/(-?\d+)\s+(-?\d+)\/(-?\d+)\/(-?\d+)\s+(-?\d+)\/(-?\d+)\/(-?\d+)(?:\s+(-?\d+)\/(-?\d+)\/(-?\d+))?/,
            face_vertex_normal: /^f\s+(-?\d+)\/\/(-?\d+)\s+(-?\d+)\/\/(-?\d+)\s+(-?\d+)\/\/(-?\d+)(?:\s+(-?\d+)\/\/(-?\d+))?/,
            object_pattern: /^[og]\s*(.+)?/,
            smoothing_pattern: /^s\s+(\d+|on|off)/,
            material_library_pattern: /^mtllib /,
            material_use_pattern: /^usemtl /,
        };
    };
    THREE.OBJLoader.prototype = {
        constructor: THREE.OBJLoader,
        load: function (url, onLoad, onProgress, onError) {
            var scope = this;
            var loader = new THREE.FileLoader(scope.manager);
            loader.setPath(this.path);
            loader.load(
                url,
                function (text) {
                    onLoad(scope.parse(text));
                },
                onProgress,
                onError
            );
        },
        setPath: function (value) {
            this.path = value;
        },
        setMaterials: function (materials) {
            this.materials = materials;
        },
        _createParserState: function () {
            var state = {
                objects: [],
                object: {},
                vertices: [],
                normals: [],
                uvs: [],
                materialLibraries: [],
                startObject: function (name, fromDeclaration) {
                    if (this.object && this.object.fromDeclaration === false) {
                        this.object.name = name;
                        this.object.fromDeclaration = fromDeclaration !== false;
                        return;
                    }
                    var previousMaterial = this.object && typeof this.object.currentMaterial === "function" ? this.object.currentMaterial() : undefined;
                    if (this.object && typeof this.object._finalize === "function") {
                        this.object._finalize(true);
                    }
                    this.object = {
                        name: name || "",
                        fromDeclaration: fromDeclaration !== false,
                        geometry: { vertices: [], normals: [], uvs: [] },
                        materials: [],
                        smooth: true,
                        startMaterial: function (name, libraries) {
                            var previous = this._finalize(false);
                            if (previous && (previous.inherited || previous.groupCount <= 0)) {
                                this.materials.splice(previous.index, 1);
                            }
                            var material = {
                                index: this.materials.length,
                                name: name || "",
                                mtllib: Array.isArray(libraries) && libraries.length > 0 ? libraries[libraries.length - 1] : "",
                                smooth: previous !== undefined ? previous.smooth : this.smooth,
                                groupStart: previous !== undefined ? previous.groupEnd : 0,
                                groupEnd: -1,
                                groupCount: -1,
                                inherited: false,
                                clone: function (index) {
                                    var cloned = { index: typeof index === "number" ? index : this.index, name: this.name, mtllib: this.mtllib, smooth: this.smooth, groupStart: 0, groupEnd: -1, groupCount: -1, inherited: false };
                                    cloned.clone = this.clone.bind(cloned);
                                    return cloned;
                                },
                            };
                            this.materials.push(material);
                            return material;
                        },
                        currentMaterial: function () {
                            if (this.materials.length > 0) {
                                return this.materials[this.materials.length - 1];
                            }
                            return undefined;
                        },
                        _finalize: function (end) {
                            var lastMultiMaterial = this.currentMaterial();
                            if (lastMultiMaterial && lastMultiMaterial.groupEnd === -1) {
                                lastMultiMaterial.groupEnd = this.geometry.vertices.length / 3;
                                lastMultiMaterial.groupCount = lastMultiMaterial.groupEnd - lastMultiMaterial.groupStart;
                                lastMultiMaterial.inherited = false;
                            }
                            if (end && this.materials.length > 1) {
                                for (var mi = this.materials.length - 1; mi >= 0; mi--) {
                                    if (this.materials[mi].groupCount <= 0) {
                                        this.materials.splice(mi, 1);
                                    }
                                }
                            }
                            if (end && this.materials.length === 0) {
                                this.materials.push({ name: "", smooth: this.smooth });
                            }
                            return lastMultiMaterial;
                        },
                    };
                    if (previousMaterial && previousMaterial.name && typeof previousMaterial.clone === "function") {
                        var declared = previousMaterial.clone(0);
                        declared.inherited = true;
                        this.object.materials.push(declared);
                    }
                    this.objects.push(this.object);
                },
                finalize: function () {
                    if (this.object && typeof this.object._finalize === "function") {
                        this.object._finalize(true);
                    }
                },
                parseVertexIndex: function (value, len) {
                    var index = parseInt(value, 10);
                    return (index >= 0 ? index - 1 : index + len / 3) * 3;
                },
                parseNormalIndex: function (value, len) {
                    var index = parseInt(value, 10);
                    return (index >= 0 ? index - 1 : index + len / 3) * 3;
                },
                parseUVIndex: function (value, len) {
                    var index = parseInt(value, 10);
                    return (index >= 0 ? index - 1 : index + len / 2) * 2;
                },
                addVertex: function (a, b, c) {
                    var src = this.vertices;
                    var dst = this.object.geometry.vertices;
                    dst.push(src[a + 0]);
                    dst.push(src[a + 1]);
                    dst.push(src[a + 2]);
                    dst.push(src[b + 0]);
                    dst.push(src[b + 1]);
                    dst.push(src[b + 2]);
                    dst.push(src[c + 0]);
                    dst.push(src[c + 1]);
                    dst.push(src[c + 2]);
                },
                addVertexLine: function (a) {
                    var src = this.vertices;
                    var dst = this.object.geometry.vertices;
                    dst.push(src[a + 0]);
                    dst.push(src[a + 1]);
                    dst.push(src[a + 2]);
                },
                addNormal: function (a, b, c) {
                    var src = this.normals;
                    var dst = this.object.geometry.normals;
                    dst.push(src[a + 0]);
                    dst.push(src[a + 1]);
                    dst.push(src[a + 2]);
                    dst.push(src[b + 0]);
                    dst.push(src[b + 1]);
                    dst.push(src[b + 2]);
                    dst.push(src[c + 0]);
                    dst.push(src[c + 1]);
                    dst.push(src[c + 2]);
                },
                addUV: function (a, b, c) {
                    var src = this.uvs;
                    var dst = this.object.geometry.uvs;
                    dst.push(src[a + 0]);
                    dst.push(src[a + 1]);
                    dst.push(src[b + 0]);
                    dst.push(src[b + 1]);
                    dst.push(src[c + 0]);
                    dst.push(src[c + 1]);
                },
                addUVLine: function (a) {
                    var src = this.uvs;
                    var dst = this.object.geometry.uvs;
                    dst.push(src[a + 0]);
                    dst.push(src[a + 1]);
                },
                addFace: function (a, b, c, d, ua, ub, uc, ud, na, nb, nc, nd) {
                    var vLen = this.vertices.length;
                    var ia = this.parseVertexIndex(a, vLen);
                    var ib = this.parseVertexIndex(b, vLen);
                    var ic = this.parseVertexIndex(c, vLen);
                    var id;
                    if (d === undefined) {
                        this.addVertex(ia, ib, ic);
                    } else {
                        id = this.parseVertexIndex(d, vLen);
                        this.addVertex(ia, ib, id);
                        this.addVertex(ib, ic, id);
                    }
                    if (ua !== undefined) {
                        var uvLen = this.uvs.length;
                        ia = this.parseUVIndex(ua, uvLen);
                        ib = this.parseUVIndex(ub, uvLen);
                        ic = this.parseUVIndex(uc, uvLen);
                        if (d === undefined) {
                            this.addUV(ia, ib, ic);
                        } else {
                            id = this.parseUVIndex(ud, uvLen);
                            this.addUV(ia, ib, id);
                            this.addUV(ib, ic, id);
                        }
                    }
                    if (na !== undefined) {
                        var nLen = this.normals.length;
                        ia = this.parseNormalIndex(na, nLen);
                        ib = na === nb ? ia : this.parseNormalIndex(nb, nLen);
                        ic = na === nc ? ia : this.parseNormalIndex(nc, nLen);
                        if (d === undefined) {
                            this.addNormal(ia, ib, ic);
                        } else {
                            id = this.parseNormalIndex(nd, nLen);
                            this.addNormal(ia, ib, id);
                            this.addNormal(ib, ic, id);
                        }
                    }
                },
                addLineGeometry: function (vertices, uvs) {
                    this.object.geometry.type = "Line";
                    var vLen = this.vertices.length;
                    var uvLen = this.uvs.length;
                    for (var vi = 0, l = vertices.length; vi < l; vi++) {
                        this.addVertexLine(this.parseVertexIndex(vertices[vi], vLen));
                    }
                    for (var uvi = 0, l = uvs.length; uvi < l; uvi++) {
                        this.addUVLine(this.parseUVIndex(uvs[uvi], uvLen));
                    }
                },
            };
            state.startObject("", false);
            return state;
        },
        parse: function (text) {
            var state = this._createParserState();
            if (text.indexOf("\r\n") !== -1) {
                text = text.replace(/\r\n/g, "\n");
            }
            if (text.indexOf("\\\n") !== -1) {
                text = text.replace(/\\\n/g, "");
            }
            var lines = text.split("\n");
            var line = "",
                lineFirstChar = "",
                lineSecondChar = "";
            var lineLength = 0;
            var result = [];
            var trimLeft = typeof "".trimLeft === "function";
            for (var i = 0, l = lines.length; i < l; i++) {
                line = lines[i];
                line = trimLeft ? line.trimLeft() : line.trim();
                lineLength = line.length;
                if (lineLength === 0) continue;
                lineFirstChar = line.charAt(0);
                if (lineFirstChar === "#") continue;
                if (lineFirstChar === "v") {
                    lineSecondChar = line.charAt(1);
                    if (lineSecondChar === " " && (result = this.regexp.vertex_pattern.exec(line)) !== null) {
                        state.vertices.push(parseFloat(result[1]), parseFloat(result[2]), parseFloat(result[3]));
                    } else if (lineSecondChar === "n" && (result = this.regexp.normal_pattern.exec(line)) !== null) {
                        state.normals.push(parseFloat(result[1]), parseFloat(result[2]), parseFloat(result[3]));
                    } else if (lineSecondChar === "t" && (result = this.regexp.uv_pattern.exec(line)) !== null) {
                        state.uvs.push(parseFloat(result[1]), parseFloat(result[2]));
                    } else {
                        throw new Error("Unexpected vertex/normal/uv line: '" + line + "'");
                    }
                } else if (lineFirstChar === "f") {
                    if ((result = this.regexp.face_vertex_uv_normal.exec(line)) !== null) {
                        state.addFace(result[1], result[4], result[7], result[10], result[2], result[5], result[8], result[11], result[3], result[6], result[9], result[12]);
                    } else if ((result = this.regexp.face_vertex_uv.exec(line)) !== null) {
                        state.addFace(result[1], result[3], result[5], result[7], result[2], result[4], result[6], result[8]);
                    } else if ((result = this.regexp.face_vertex_normal.exec(line)) !== null) {
                        state.addFace(result[1], result[3], result[5], result[7], undefined, undefined, undefined, undefined, result[2], result[4], result[6], result[8]);
                    } else if ((result = this.regexp.face_vertex.exec(line)) !== null) {
                        state.addFace(result[1], result[2], result[3], result[4]);
                    } else {
                        throw new Error("Unexpected face line: '" + line + "'");
                    }
                } else if (lineFirstChar === "l") {
                    var lineParts = line.substring(1).trim().split(" ");
                    var lineVertices = [],
                        lineUVs = [];
                    if (line.indexOf("/") === -1) {
                        lineVertices = lineParts;
                    } else {
                        for (var li = 0, llen = lineParts.length; li < llen; li++) {
                            var parts = lineParts[li].split("/");
                            if (parts[0] !== "") lineVertices.push(parts[0]);
                            if (parts[1] !== "") lineUVs.push(parts[1]);
                        }
                    }
                    state.addLineGeometry(lineVertices, lineUVs);
                } else if ((result = this.regexp.object_pattern.exec(line)) !== null) {
                    var name = (" " + result[0].substr(1).trim()).substr(1);
                    state.startObject(name);
                } else if (this.regexp.material_use_pattern.test(line)) {
                    state.object.startMaterial(line.substring(7).trim(), state.materialLibraries);
                } else if (this.regexp.material_library_pattern.test(line)) {
                    state.materialLibraries.push(line.substring(7).trim());
                } else if ((result = this.regexp.smoothing_pattern.exec(line)) !== null) {
                    var value = result[1].trim().toLowerCase();
                    state.object.smooth = value === "1" || value === "on";
                    var material = state.object.currentMaterial();
                    if (material) {
                        material.smooth = state.object.smooth;
                    }
                } else {
                    if (line === "\0") continue;
                    throw new Error("Unexpected line: '" + line + "'");
                }
            }
            state.finalize();
            var container = new THREE.Group();
            container.materialLibraries = [].concat(state.materialLibraries);
            for (var i = 0, l = state.objects.length; i < l; i++) {
                var object = state.objects[i];
                var geometry = object.geometry;
                var materials = object.materials;
                var isLine = geometry.type === "Line";
                if (geometry.vertices.length === 0) continue;
                var buffergeometry = new THREE.BufferGeometry();
                buffergeometry.addAttribute("position", new THREE.BufferAttribute(new Float32Array(geometry.vertices), 3));
                if (geometry.normals.length > 0) {
                    buffergeometry.addAttribute("normal", new THREE.BufferAttribute(new Float32Array(geometry.normals), 3));
                } else {
                    buffergeometry.computeVertexNormals();
                }
                if (geometry.uvs.length > 0) {
                    buffergeometry.addAttribute("uv", new THREE.BufferAttribute(new Float32Array(geometry.uvs), 2));
                }
                var createdMaterials = [];
                for (var mi = 0, miLen = materials.length; mi < miLen; mi++) {
                    var sourceMaterial = materials[mi];
                    var material = undefined;
                    if (this.materials !== null) {
                        material = this.materials.create(sourceMaterial.name);
                        if (isLine && material && !(material instanceof THREE.LineBasicMaterial)) {
                            var materialLine = new THREE.LineBasicMaterial();
                            materialLine.copy(material);
                            material = materialLine;
                        }
                    }
                    if (!material) {
                        material = !isLine ? new THREE.MeshPhongMaterial() : new THREE.LineBasicMaterial();
                        material.name = sourceMaterial.name;
                    }
                    material.shading = sourceMaterial.smooth ? THREE.SmoothShading : THREE.FlatShading;
                    createdMaterials.push(material);
                }
                var mesh;
                if (createdMaterials.length > 1) {
                    for (var mi = 0, miLen = materials.length; mi < miLen; mi++) {
                        var sourceMaterial = materials[mi];
                        buffergeometry.addGroup(sourceMaterial.groupStart, sourceMaterial.groupCount, mi);
                    }
                    var multiMaterial = new THREE.MultiMaterial(createdMaterials);
                    mesh = !isLine ? new THREE.Mesh(buffergeometry, multiMaterial) : new THREE.LineSegments(buffergeometry, multiMaterial);
                } else {
                    mesh = !isLine ? new THREE.Mesh(buffergeometry, createdMaterials[0]) : new THREE.LineSegments(buffergeometry, createdMaterials[0]);
                }
                mesh.name = object.name;
                container.add(mesh);
            }
            return container;
        },
    };
    THREE.ColladaLoader = function () {
        var COLLADA = null;
        var scene = null;
        var visualScene;
        var kinematicsModel;
        var readyCallbackFunc = null;
        var sources = {};
        var images = {};
        var animations = {};
        var controllers = {};
        var geometries = {};
        var materials = {};
        var effects = {};
        var cameras = {};
        var lights = {};
        var animData;
        var kinematics;
        var visualScenes;
        var kinematicsModels;
        var baseUrl;
        var morphs;
        var skins;
        var flip_uv = true;
        var preferredShading = THREE.SmoothShading;
        var options = { centerGeometry: false, convertUpAxis: false, subdivideFaces: true, upAxis: "Y", defaultEnvMap: null };
        var colladaUnit = 1;
        var colladaUp = "Y";
        var upConversion = null;
        function load(url, readyCallback, progressCallback, failCallback) {
            var length = 0;
            if (document.implementation && document.implementation.createDocument) {
                var request = new XMLHttpRequest();
                request.onreadystatechange = function () {
                    if (request.readyState === 4) {
                        if (request.status === 0 || request.status === 200) {
                            if (request.response) {
                                readyCallbackFunc = readyCallback;
                                parse(request.response, undefined, url);
                            } else {
                                if (failCallback) {
                                    failCallback({ type: "error", url: url });
                                } else {
                                    console.error("ColladaLoader: Empty or non-existing file (" + url + ")");
                                }
                            }
                        } else {
                            if (failCallback) {
                                failCallback({ type: "error", url: url });
                            } else {
                                console.error("ColladaLoader: Couldn't load \"" + url + '" (' + request.status + ")");
                            }
                        }
                    } else if (request.readyState === 3) {
                        if (progressCallback) {
                            if (length === 0) {
                                length = request.getResponseHeader("Content-Length");
                            }
                            progressCallback({ total: length, loaded: request.responseText.length });
                        }
                    }
                };
                request.open("GET", url, true);
                request.send(null);
            } else {
                alert("Don't know how to parse XML!");
            }
        }
        function parse(text, callBack, url) {
            COLLADA = new DOMParser().parseFromString(text, "text/xml");
            callBack = callBack || readyCallbackFunc;
            if (url !== undefined) {
                var parts = url.split("/");
                parts.pop();
                baseUrl = (parts.length < 1 ? "." : parts.join("/")) + "/";
            }
            parseAsset();
            setUpConversion();
            images = parseLib("library_images image", _Image, "image");
            materials = parseLib("library_materials material", Material, "material");
            effects = parseLib("library_effects effect", Effect, "effect");
            geometries = parseLib("library_geometries geometry", Geometry, "geometry");
            cameras = parseLib("library_cameras camera", Camera, "camera");
            lights = parseLib("library_lights light", Light, "light");
            controllers = parseLib("library_controllers controller", Controller, "controller");
            animations = parseLib("library_animations animation", Animation, "animation");
            visualScenes = parseLib("library_visual_scenes visual_scene", VisualScene, "visual_scene");
            kinematicsModels = parseLib("library_kinematics_models kinematics_model", KinematicsModel, "kinematics_model");
            morphs = [];
            skins = [];
            visualScene = parseScene();
            scene = new THREE.Group();
            for (var i = 0; i < visualScene.nodes.length; i++) {
                scene.add(createSceneGraph(visualScene.nodes[i]));
            }
            scene.scale.multiplyScalar(colladaUnit);
            createAnimations();
            kinematicsModel = parseKinematicsModel();
            createKinematics();
            var result = {
                scene: scene,
                morphs: morphs,
                skins: skins,
                animations: animData,
                kinematics: kinematics,
                dae: {
                    images: images,
                    materials: materials,
                    cameras: cameras,
                    lights: lights,
                    effects: effects,
                    geometries: geometries,
                    controllers: controllers,
                    animations: animations,
                    visualScenes: visualScenes,
                    visualScene: visualScene,
                    scene: visualScene,
                    kinematicsModels: kinematicsModels,
                    kinematicsModel: kinematicsModel,
                },
            };
            if (callBack) {
                callBack(result);
            }
            return result;
        }
        function setPreferredShading(shading) {
            preferredShading = shading;
        }
        function parseAsset() {
            var elements = COLLADA.querySelectorAll("asset");
            var element = elements[0];
            if (element && element.childNodes) {
                for (var i = 0; i < element.childNodes.length; i++) {
                    var child = element.childNodes[i];
                    switch (child.nodeName) {
                        case "unit":
                            var meter = child.getAttribute("meter");
                            if (meter) {
                                colladaUnit = parseFloat(meter);
                            }
                            break;
                        case "up_axis":
                            colladaUp = child.textContent.charAt(0);
                            break;
                    }
                }
            }
        }
        function parseLib(q, classSpec, prefix) {
            var elements = COLLADA.querySelectorAll(q);
            var lib = {};
            var i = 0;
            var elementsLength = elements.length;
            for (var j = 0; j < elementsLength; j++) {
                var element = elements[j];
                var daeElement = new classSpec().parse(element);
                if (!daeElement.id || daeElement.id.length === 0) daeElement.id = prefix + i++;
                lib[daeElement.id] = daeElement;
            }
            return lib;
        }
        function parseScene() {
            var sceneElement = COLLADA.querySelectorAll("scene instance_visual_scene")[0];
            if (sceneElement) {
                var url = sceneElement.getAttribute("url").replace(/^#/, "");
                return visualScenes[url.length > 0 ? url : "visual_scene0"];
            } else {
                return null;
            }
        }
        function parseKinematicsModel() {
            var kinematicsModelElement = COLLADA.querySelectorAll("instance_kinematics_model")[0];
            if (kinematicsModelElement) {
                var url = kinematicsModelElement.getAttribute("url").replace(/^#/, "");
                return kinematicsModels[url.length > 0 ? url : "kinematics_model0"];
            } else {
                return null;
            }
        }
        function createAnimations() {
            animData = [];
            recurseHierarchy(scene);
        }
        function recurseHierarchy(node) {
            var n = visualScene.getChildById(node.colladaId, true),
                newData = null;
            if (n && n.keys) {
                newData = { fps: 60, hierarchy: [{ node: n, keys: n.keys, sids: n.sids }], node: node, name: "animation_" + node.name, length: 0 };
                animData.push(newData);
                for (var i = 0, il = n.keys.length; i < il; i++) {
                    newData.length = Math.max(newData.length, n.keys[i].time);
                }
            } else {
                newData = { hierarchy: [{ keys: [], sids: [] }] };
            }
            for (var i = 0, il = node.children.length; i < il; i++) {
                var d = recurseHierarchy(node.children[i]);
                for (var j = 0, jl = d.hierarchy.length; j < jl; j++) {
                    newData.hierarchy.push({ keys: [], sids: [] });
                }
            }
            return newData;
        }
        function calcAnimationBounds() {
            var start = 1e6;
            var end = -start;
            var frames = 0;
            var ID;
            for (var id in animations) {
                var animation = animations[id];
                ID = ID || animation.id;
                for (var i = 0; i < animation.sampler.length; i++) {
                    var sampler = animation.sampler[i];
                    sampler.create();
                    start = Math.min(start, sampler.startTime);
                    end = Math.max(end, sampler.endTime);
                    frames = Math.max(frames, sampler.input.length);
                }
            }
            return { start: start, end: end, frames: frames, ID: ID };
        }
        function createMorph(geometry, ctrl) {
            var morphCtrl = ctrl instanceof InstanceController ? controllers[ctrl.url] : ctrl;
            if (!morphCtrl || !morphCtrl.morph) {
                console.log("could not find morph controller!");
                return;
            }
            var morph = morphCtrl.morph;
            for (var i = 0; i < morph.targets.length; i++) {
                var target_id = morph.targets[i];
                var daeGeometry = geometries[target_id];
                if (!daeGeometry.mesh || !daeGeometry.mesh.primitives || !daeGeometry.mesh.primitives.length) {
                    continue;
                }
                var target = daeGeometry.mesh.primitives[0].geometry;
                if (target.vertices.length === geometry.vertices.length) {
                    geometry.morphTargets.push({ name: "target_1", vertices: target.vertices });
                }
            }
            geometry.morphTargets.push({ name: "target_Z", vertices: geometry.vertices });
        }
        function setupSkeleton(node, bones, frame, parent) {
            node.world = node.world || new THREE.Matrix4();
            node.localworld = node.localworld || new THREE.Matrix4();
            node.world.copy(node.matrix);
            node.localworld.copy(node.matrix);
            if (node.channels && node.channels.length) {
                var channel = node.channels[0];
                var m = channel.sampler.output[frame];
                if (m instanceof THREE.Matrix4) {
                    node.world.copy(m);
                    node.localworld.copy(m);
                    if (frame === 0) node.matrix.copy(m);
                }
            }
            if (parent) {
                node.world.multiplyMatrices(parent, node.world);
            }
            bones.push(node);
            for (var i = 0; i < node.nodes.length; i++) {
                setupSkeleton(node.nodes[i], bones, frame, node.world);
            }
        }
        function setupSkinningMatrices(bones, skin) {
            for (var i = 0; i < bones.length; i++) {
                var bone = bones[i];
                var found = -1;
                if (bone.type != "JOINT") continue;
                for (var j = 0; j < skin.joints.length; j++) {
                    if (bone.sid === skin.joints[j]) {
                        found = j;
                        break;
                    }
                }
                if (found >= 0) {
                    var inv = skin.invBindMatrices[found];
                    bone.invBindMatrix = inv;
                    bone.skinningMatrix = new THREE.Matrix4();
                    bone.skinningMatrix.multiplyMatrices(bone.world, inv);
                    bone.animatrix = new THREE.Matrix4();
                    bone.animatrix.copy(bone.localworld);
                    bone.weights = [];
                    for (var j = 0; j < skin.weights.length; j++) {
                        for (var k = 0; k < skin.weights[j].length; k++) {
                            var w = skin.weights[j][k];
                            if (w.joint === found) {
                                bone.weights.push(w);
                            }
                        }
                    }
                } else {
                    console.warn("ColladaLoader: Could not find joint '" + bone.sid + "'.");
                    bone.skinningMatrix = new THREE.Matrix4();
                    bone.weights = [];
                }
            }
        }
        function flattenSkeleton(skeleton) {
            var list = [];
            var walk = function (parentid, node, list) {
                var bone = {};
                bone.name = node.sid;
                bone.parent = parentid;
                bone.matrix = node.matrix;
                var data = [new THREE.Vector3(), new THREE.Quaternion(), new THREE.Vector3()];
                bone.matrix.decompose(data[0], data[1], data[2]);
                bone.pos = [data[0].x, data[0].y, data[0].z];
                bone.scl = [data[2].x, data[2].y, data[2].z];
                bone.rotq = [data[1].x, data[1].y, data[1].z, data[1].w];
                list.push(bone);
                for (var i in node.nodes) {
                    walk(node.sid, node.nodes[i], list);
                }
            };
            walk(-1, skeleton, list);
            return list;
        }
        function skinToBindPose(geometry, skeleton, skinController) {
            var bones = [];
            setupSkeleton(skeleton, bones, -1);
            setupSkinningMatrices(bones, skinController.skin);
            var v = new THREE.Vector3();
            var skinned = [];
            for (var i = 0; i < geometry.vertices.length; i++) {
                skinned.push(new THREE.Vector3());
            }
            for (i = 0; i < bones.length; i++) {
                if (bones[i].type != "JOINT") continue;
                for (var j = 0; j < bones[i].weights.length; j++) {
                    var w = bones[i].weights[j];
                    var vidx = w.index;
                    var weight = w.weight;
                    var o = geometry.vertices[vidx];
                    var s = skinned[vidx];
                    v.x = o.x;
                    v.y = o.y;
                    v.z = o.z;
                    v.applyMatrix4(bones[i].skinningMatrix);
                    s.x += v.x * weight;
                    s.y += v.y * weight;
                    s.z += v.z * weight;
                }
            }
            for (var i = 0; i < geometry.vertices.length; i++) {
                geometry.vertices[i] = skinned[i];
            }
        }
        function applySkin(geometry, instanceCtrl, frame) {
            var skinController = controllers[instanceCtrl.url];
            frame = frame !== undefined ? frame : 40;
            if (!skinController || !skinController.skin) {
                console.log("ColladaLoader: Could not find skin controller.");
                return;
            }
            if (!instanceCtrl.skeleton || !instanceCtrl.skeleton.length) {
                console.log("ColladaLoader: Could not find the skeleton for the skin. ");
                return;
            }
            var animationBounds = calcAnimationBounds();
            var skeleton = visualScene.getChildById(instanceCtrl.skeleton[0], true) || visualScene.getChildBySid(instanceCtrl.skeleton[0], true);
            var bonelist = flattenSkeleton(skeleton);
            var joints = skinController.skin.joints;
            var sortedbones = [];
            for (var i = 0; i < joints.length; i++) {
                for (var j = 0; j < bonelist.length; j++) {
                    if (bonelist[j].name === joints[i]) {
                        sortedbones[i] = bonelist[j];
                    }
                }
            }
            for (var i = 0; i < sortedbones.length; i++) {
                for (var j = 0; j < sortedbones.length; j++) {
                    if (sortedbones[i].parent === sortedbones[j].name) {
                        sortedbones[i].parent = j;
                    }
                }
            }
            var i, j, w, vidx, weight;
            var v = new THREE.Vector3(),
                o,
                s;
            for (i = 0; i < geometry.vertices.length; i++) {
                geometry.vertices[i].applyMatrix4(skinController.skin.bindShapeMatrix);
            }
            var skinIndices = [];
            var skinWeights = [];
            var weights = skinController.skin.weights;
            for (var i = 0; i < weights.length; i++) {
                var indicies = new THREE.Vector4(weights[i][0] ? weights[i][0].joint : 0, weights[i][1] ? weights[i][1].joint : 0, weights[i][2] ? weights[i][2].joint : 0, weights[i][3] ? weights[i][3].joint : 0);
                var weight = new THREE.Vector4(weights[i][0] ? weights[i][0].weight : 0, weights[i][1] ? weights[i][1].weight : 0, weights[i][2] ? weights[i][2].weight : 0, weights[i][3] ? weights[i][3].weight : 0);
                skinIndices.push(indicies);
                skinWeights.push(weight);
            }
            geometry.skinIndices = skinIndices;
            geometry.skinWeights = skinWeights;
            geometry.bones = sortedbones;
            var animationdata = { name: animationBounds.ID, fps: 30, length: animationBounds.frames / 30, hierarchy: [] };
            for (var j = 0; j < sortedbones.length; j++) {
                animationdata.hierarchy.push({ parent: sortedbones[j].parent, name: sortedbones[j].name, keys: [] });
            }
            console.log("ColladaLoader:", animationBounds.ID + " has " + sortedbones.length + " bones.");
            skinToBindPose(geometry, skeleton, skinController);
            for (frame = 0; frame < animationBounds.frames; frame++) {
                var bones = [];
                var skinned = [];
                setupSkeleton(skeleton, bones, frame);
                setupSkinningMatrices(bones, skinController.skin);
                for (var i = 0; i < bones.length; i++) {
                    for (var j = 0; j < animationdata.hierarchy.length; j++) {
                        if (animationdata.hierarchy[j].name === bones[i].sid) {
                            var key = {};
                            key.time = frame / 30;
                            key.matrix = bones[i].animatrix;
                            if (frame === 0) bones[i].matrix = key.matrix;
                            var data = [new THREE.Vector3(), new THREE.Quaternion(), new THREE.Vector3()];
                            key.matrix.decompose(data[0], data[1], data[2]);
                            key.pos = [data[0].x, data[0].y, data[0].z];
                            key.scl = [data[2].x, data[2].y, data[2].z];
                            key.rot = data[1];
                            animationdata.hierarchy[j].keys.push(key);
                        }
                    }
                }
                geometry.animation = animationdata;
            }
        }
        function createKinematics() {
            if (kinematicsModel && kinematicsModel.joints.length === 0) {
                kinematics = undefined;
                return;
            }
            var jointMap = {};
            var _addToMap = function (jointIndex, parentVisualElement) {
                var parentVisualElementId = parentVisualElement.getAttribute("id");
                var colladaNode = visualScene.getChildById(parentVisualElementId, true);
                var joint = kinematicsModel.joints[jointIndex];
                scene.traverse(function (node) {
                    if (node.colladaId == parentVisualElementId) {
                        jointMap[jointIndex] = { node: node, transforms: colladaNode.transforms, joint: joint, position: joint.zeroPosition };
                    }
                });
            };
            kinematics = {
                joints: kinematicsModel && kinematicsModel.joints,
                getJointValue: function (jointIndex) {
                    var jointData = jointMap[jointIndex];
                    if (jointData) {
                        return jointData.position;
                    } else {
                        console.log("getJointValue: joint " + jointIndex + " doesn't exist");
                    }
                },
                setJointValue: function (jointIndex, value) {
                    var jointData = jointMap[jointIndex];
                    if (jointData) {
                        var joint = jointData.joint;
                        if (value > joint.limits.max || value < joint.limits.min) {
                            console.log("setJointValue: joint " + jointIndex + " value " + value + " outside of limits (min: " + joint.limits.min + ", max: " + joint.limits.max + ")");
                        } else if (joint.static) {
                            console.log("setJointValue: joint " + jointIndex + " is static");
                        } else {
                            var threejsNode = jointData.node;
                            var axis = joint.axis;
                            var transforms = jointData.transforms;
                            var matrix = new THREE.Matrix4();
                            for (i = 0; i < transforms.length; i++) {
                                var transform = transforms[i];
                                if (transform.sid && transform.sid.indexOf("joint" + jointIndex) !== -1) {
                                    switch (joint.type) {
                                        case "revolute":
                                            matrix.multiply(m1.makeRotationAxis(axis, THREE.Math.degToRad(value)));
                                            break;
                                        case "prismatic":
                                            matrix.multiply(m1.makeTranslation(axis.x * value, axis.y * value, axis.z * value));
                                            break;
                                        default:
                                            console.warn("setJointValue: unknown joint type: " + joint.type);
                                            break;
                                    }
                                } else {
                                    var m1 = new THREE.Matrix4();
                                    switch (transform.type) {
                                        case "matrix":
                                            matrix.multiply(transform.obj);
                                            break;
                                        case "translate":
                                            matrix.multiply(m1.makeTranslation(transform.obj.x, transform.obj.y, transform.obj.z));
                                            break;
                                        case "rotate":
                                            matrix.multiply(m1.makeRotationAxis(transform.obj, transform.angle));
                                            break;
                                    }
                                }
                            }
                            var elementsFloat32Arr = matrix.elements;
                            var elements = Array.prototype.slice.call(elementsFloat32Arr);
                            var elementsRowMajor = [
                                elements[0],
                                elements[4],
                                elements[8],
                                elements[12],
                                elements[1],
                                elements[5],
                                elements[9],
                                elements[13],
                                elements[2],
                                elements[6],
                                elements[10],
                                elements[14],
                                elements[3],
                                elements[7],
                                elements[11],
                                elements[15],
                            ];
                            threejsNode.matrix.set.apply(threejsNode.matrix, elementsRowMajor);
                            threejsNode.matrix.decompose(threejsNode.position, threejsNode.quaternion, threejsNode.scale);
                        }
                    } else {
                        console.log("setJointValue: joint " + jointIndex + " doesn't exist");
                    }
                },
            };
            var element = COLLADA.querySelector("scene instance_kinematics_scene");
            if (element) {
                for (var i = 0; i < element.childNodes.length; i++) {
                    var child = element.childNodes[i];
                    if (child.nodeType != 1) continue;
                    switch (child.nodeName) {
                        case "bind_joint_axis":
                            var visualTarget = child.getAttribute("target").split("/").pop();
                            var axis = child.querySelector("axis param").textContent;
                            var jointIndex = parseInt(axis.split("joint").pop().split(".")[0]);
                            var visualTargetElement = COLLADA.querySelector('[sid="' + visualTarget + '"]');
                            if (visualTargetElement) {
                                var parentVisualElement = visualTargetElement.parentElement;
                                _addToMap(jointIndex, parentVisualElement);
                            }
                            break;
                        default:
                            break;
                    }
                }
            }
        }
        function createSceneGraph(node, parent) {
            var obj = new THREE.Object3D();
            var skinned = false;
            var skinController;
            var morphController;
            var i, j;
            for (i = 0; i < node.controllers.length; i++) {
                var controller = controllers[node.controllers[i].url];
                switch (controller.type) {
                    case "skin":
                        if (geometries[controller.skin.source]) {
                            var inst_geom = new InstanceGeometry();
                            inst_geom.url = controller.skin.source;
                            inst_geom.instance_material = node.controllers[i].instance_material;
                            node.geometries.push(inst_geom);
                            skinned = true;
                            skinController = node.controllers[i];
                        } else if (controllers[controller.skin.source]) {
                            var second = controllers[controller.skin.source];
                            morphController = second;
                            if (second.morph && geometries[second.morph.source]) {
                                var inst_geom = new InstanceGeometry();
                                inst_geom.url = second.morph.source;
                                inst_geom.instance_material = node.controllers[i].instance_material;
                                node.geometries.push(inst_geom);
                            }
                        }
                        break;
                    case "morph":
                        if (geometries[controller.morph.source]) {
                            var inst_geom = new InstanceGeometry();
                            inst_geom.url = controller.morph.source;
                            inst_geom.instance_material = node.controllers[i].instance_material;
                            node.geometries.push(inst_geom);
                            morphController = node.controllers[i];
                        }
                        console.log("ColladaLoader: Morph-controller partially supported.");
                    default:
                        break;
                }
            }
            var double_sided_materials = {};
            for (i = 0; i < node.geometries.length; i++) {
                var instance_geometry = node.geometries[i];
                var instance_materials = instance_geometry.instance_material;
                var geometry = geometries[instance_geometry.url];
                var used_materials = {};
                var used_materials_array = [];
                var num_materials = 0;
                var first_material;
                if (geometry) {
                    if (!geometry.mesh || !geometry.mesh.primitives) continue;
                    if (obj.name.length === 0) {
                        obj.name = geometry.id;
                    }
                    if (instance_materials) {
                        for (j = 0; j < instance_materials.length; j++) {
                            var instance_material = instance_materials[j];
                            var mat = materials[instance_material.target];
                            var effect_id = mat.instance_effect.url;
                            var shader = effects[effect_id].shader;
                            var material3js = shader.material;
                            if (geometry.doubleSided) {
                                if (!(instance_material.symbol in double_sided_materials)) {
                                    var _copied_material = material3js.clone();
                                    _copied_material.side = THREE.DoubleSide;
                                    double_sided_materials[instance_material.symbol] = _copied_material;
                                }
                                material3js = double_sided_materials[instance_material.symbol];
                            }
                            material3js.opacity = !material3js.opacity ? 1 : material3js.opacity;
                            used_materials[instance_material.symbol] = num_materials;
                            used_materials_array.push(material3js);
                            first_material = material3js;
                            first_material.name = mat.name === null || mat.name === "" ? mat.id : mat.name;
                            num_materials++;
                        }
                    }
                    var mesh;
                    var material = first_material || new THREE.MeshLambertMaterial({ color: 14540253, side: geometry.doubleSided ? THREE.DoubleSide : THREE.FrontSide });
                    var geom = geometry.mesh.geometry3js;
                    if (num_materials > 1) {
                        material = new THREE.MultiMaterial(used_materials_array);
                        for (j = 0; j < geom.faces.length; j++) {
                            var face = geom.faces[j];
                            face.materialIndex = used_materials[face.daeMaterial];
                        }
                    }
                    if (skinController !== undefined) {
                        applySkin(geom, skinController);
                        if (geom.morphTargets.length > 0) {
                            material.morphTargets = true;
                            material.skinning = false;
                        } else {
                            material.morphTargets = false;
                            material.skinning = true;
                        }
                        mesh = new THREE.SkinnedMesh(geom, material, false);
                        mesh.name = "skin_" + skins.length;
                        skins.push(mesh);
                    } else if (morphController !== undefined) {
                        createMorph(geom, morphController);
                        material.morphTargets = true;
                        mesh = new THREE.Mesh(geom, material);
                        mesh.name = "morph_" + morphs.length;
                        morphs.push(mesh);
                    } else {
                        if (geom.isLineStrip === true) {
                            mesh = new THREE.Line(geom);
                        } else {
                            mesh = new THREE.Mesh(geom, material);
                        }
                    }
                    obj.add(mesh);
                }
            }
            for (i = 0; i < node.cameras.length; i++) {
                var instance_camera = node.cameras[i];
                var cparams = cameras[instance_camera.url];
                var cam = new THREE.PerspectiveCamera(cparams.yfov, parseFloat(cparams.aspect_ratio), parseFloat(cparams.znear), parseFloat(cparams.zfar));
                obj.add(cam);
            }
            for (i = 0; i < node.lights.length; i++) {
                var light = null;
                var instance_light = node.lights[i];
                var lparams = lights[instance_light.url];
                if (lparams && lparams.technique) {
                    var color = lparams.color.getHex();
                    var intensity = lparams.intensity;
                    var distance = lparams.distance;
                    var angle = lparams.falloff_angle;
                    switch (lparams.technique) {
                        case "directional":
                            light = new THREE.DirectionalLight(color, intensity, distance);
                            light.position.set(0, 0, 1);
                            break;
                        case "point":
                            light = new THREE.PointLight(color, intensity, distance);
                            break;
                        case "spot":
                            light = new THREE.SpotLight(color, intensity, distance, angle);
                            light.position.set(0, 0, 1);
                            break;
                        case "ambient":
                            light = new THREE.AmbientLight(color);
                            break;
                    }
                }
                if (light) {
                    obj.add(light);
                }
            }
            obj.name = node.name || node.id || "";
            obj.colladaId = node.id || "";
            obj.layer = node.layer || "";
            obj.matrix = node.matrix;
            obj.matrix.decompose(obj.position, obj.quaternion, obj.scale);
            if (options.centerGeometry && obj.geometry) {
                var delta = obj.geometry.center();
                delta.multiply(obj.scale);
                delta.applyQuaternion(obj.quaternion);
                obj.position.sub(delta);
            }
            for (i = 0; i < node.nodes.length; i++) {
                obj.add(createSceneGraph(node.nodes[i], node));
            }
            return obj;
        }
        function getLibraryNode(id) {
            var nodes = COLLADA.querySelectorAll("library_nodes node");
            for (var i = 0; i < nodes.length; i++) {
                var attObj = nodes[i].attributes.getNamedItem("id");
                if (attObj && attObj.value === id) {
                    return nodes[i];
                }
            }
            return undefined;
        }
        function getChannelsForNode(node) {
            var channels = [];
            var startTime = 1e6;
            var endTime = -1e6;
            for (var id in animations) {
                var animation = animations[id];
                for (var i = 0; i < animation.channel.length; i++) {
                    var channel = animation.channel[i];
                    var sampler = animation.sampler[i];
                    var id = channel.target.split("/")[0];
                    if (id == node.id) {
                        sampler.create();
                        channel.sampler = sampler;
                        startTime = Math.min(startTime, sampler.startTime);
                        endTime = Math.max(endTime, sampler.endTime);
                        channels.push(channel);
                    }
                }
            }
            if (channels.length) {
                node.startTime = startTime;
                node.endTime = endTime;
            }
            return channels;
        }
        function bakeAnimations(node) {
            if (node.channels && node.channels.length) {
                var keys = [],
                    sids = [];
                for (var i = 0, il = node.channels.length; i < il; i++) {
                    var channel = node.channels[i],
                        fullSid = channel.fullSid,
                        sampler = channel.sampler,
                        input = sampler.input,
                        transform = node.getTransformBySid(channel.sid),
                        member;
                    if (channel.arrIndices) {
                        member = [];
                        for (var j = 0, jl = channel.arrIndices.length; j < jl; j++) {
                            member[j] = getConvertedIndex(channel.arrIndices[j]);
                        }
                    } else {
                        member = getConvertedMember(channel.member);
                    }
                    if (transform) {
                        if (sids.indexOf(fullSid) === -1) {
                            sids.push(fullSid);
                        }
                        for (var j = 0, jl = input.length; j < jl; j++) {
                            var time = input[j],
                                data = sampler.getData(transform.type, j, member),
                                key = findKey(keys, time);
                            if (!key) {
                                key = new Key(time);
                                var timeNdx = findTimeNdx(keys, time);
                                keys.splice(timeNdx === -1 ? keys.length : timeNdx, 0, key);
                            }
                            key.addTarget(fullSid, transform, member, data);
                        }
                    } else {
                        console.log('Could not find transform "' + channel.sid + '" in node ' + node.id);
                    }
                }
                for (var i = 0; i < sids.length; i++) {
                    var sid = sids[i];
                    for (var j = 0; j < keys.length; j++) {
                        var key = keys[j];
                        if (!key.hasTarget(sid)) {
                            interpolateKeys(keys, key, j, sid);
                        }
                    }
                }
                node.keys = keys;
                node.sids = sids;
            }
        }
        function findKey(keys, time) {
            var retVal = null;
            for (var i = 0, il = keys.length; i < il && retVal === null; i++) {
                var key = keys[i];
                if (key.time === time) {
                    retVal = key;
                } else if (key.time > time) {
                    break;
                }
            }
            return retVal;
        }
        function findTimeNdx(keys, time) {
            var ndx = -1;
            for (var i = 0, il = keys.length; i < il && ndx === -1; i++) {
                var key = keys[i];
                if (key.time >= time) {
                    ndx = i;
                }
            }
            return ndx;
        }
        function interpolateKeys(keys, key, ndx, fullSid) {
            var prevKey = getPrevKeyWith(keys, fullSid, ndx ? ndx - 1 : 0),
                nextKey = getNextKeyWith(keys, fullSid, ndx + 1);
            if (prevKey && nextKey) {
                var scale = (key.time - prevKey.time) / (nextKey.time - prevKey.time),
                    prevTarget = prevKey.getTarget(fullSid),
                    nextData = nextKey.getTarget(fullSid).data,
                    prevData = prevTarget.data,
                    data;
                if (prevTarget.type === "matrix") {
                    data = prevData;
                } else if (prevData.length) {
                    data = [];
                    for (var i = 0; i < prevData.length; ++i) {
                        data[i] = prevData[i] + (nextData[i] - prevData[i]) * scale;
                    }
                } else {
                    data = prevData + (nextData - prevData) * scale;
                }
                key.addTarget(fullSid, prevTarget.transform, prevTarget.member, data);
            }
        }
        function getNextKeyWith(keys, fullSid, ndx) {
            for (; ndx < keys.length; ndx++) {
                var key = keys[ndx];
                if (key.hasTarget(fullSid)) {
                    return key;
                }
            }
            return null;
        }
        function getPrevKeyWith(keys, fullSid, ndx) {
            ndx = ndx >= 0 ? ndx : ndx + keys.length;
            for (; ndx >= 0; ndx--) {
                var key = keys[ndx];
                if (key.hasTarget(fullSid)) {
                    return key;
                }
            }
            return null;
        }
        function _Image() {
            this.id = "";
            this.init_from = "";
        }
        _Image.prototype.parse = function (element) {
            this.id = element.getAttribute("id");
            for (var i = 0; i < element.childNodes.length; i++) {
                var child = element.childNodes[i];
                if (child.nodeName === "init_from") {
                    this.init_from = child.textContent;
                }
            }
            return this;
        };
        function Controller() {
            this.id = "";
            this.name = "";
            this.type = "";
            this.skin = null;
            this.morph = null;
        }
        Controller.prototype.parse = function (element) {
            this.id = element.getAttribute("id");
            this.name = element.getAttribute("name");
            this.type = "none";
            for (var i = 0; i < element.childNodes.length; i++) {
                var child = element.childNodes[i];
                switch (child.nodeName) {
                    case "skin":
                        this.skin = new Skin().parse(child);
                        this.type = child.nodeName;
                        break;
                    case "morph":
                        this.morph = new Morph().parse(child);
                        this.type = child.nodeName;
                        break;
                    default:
                        break;
                }
            }
            return this;
        };
        function Morph() {
            this.method = null;
            this.source = null;
            this.targets = null;
            this.weights = null;
        }
        Morph.prototype.parse = function (element) {
            var sources = {};
            var inputs = [];
            var i;
            this.method = element.getAttribute("method");
            this.source = element.getAttribute("source").replace(/^#/, "");
            for (i = 0; i < element.childNodes.length; i++) {
                var child = element.childNodes[i];
                if (child.nodeType != 1) continue;
                switch (child.nodeName) {
                    case "source":
                        var source = new Source().parse(child);
                        sources[source.id] = source;
                        break;
                    case "targets":
                        inputs = this.parseInputs(child);
                        break;
                    default:
                        console.log(child.nodeName);
                        break;
                }
            }
            for (i = 0; i < inputs.length; i++) {
                var input = inputs[i];
                var source = sources[input.source];
                switch (input.semantic) {
                    case "MORPH_TARGET":
                        this.targets = source.read();
                        break;
                    case "MORPH_WEIGHT":
                        this.weights = source.read();
                        break;
                    default:
                        break;
                }
            }
            return this;
        };
        Morph.prototype.parseInputs = function (element) {
            var inputs = [];
            for (var i = 0; i < element.childNodes.length; i++) {
                var child = element.childNodes[i];
                if (child.nodeType != 1) continue;
                switch (child.nodeName) {
                    case "input":
                        inputs.push(new Input().parse(child));
                        break;
                    default:
                        break;
                }
            }
            return inputs;
        };
        function Skin() {
            this.source = "";
            this.bindShapeMatrix = null;
            this.invBindMatrices = [];
            this.joints = [];
            this.weights = [];
        }
        Skin.prototype.parse = function (element) {
            var sources = {};
            var joints, weights;
            this.source = element.getAttribute("source").replace(/^#/, "");
            this.invBindMatrices = [];
            this.joints = [];
            this.weights = [];
            for (var i = 0; i < element.childNodes.length; i++) {
                var child = element.childNodes[i];
                if (child.nodeType != 1) continue;
                switch (child.nodeName) {
                    case "bind_shape_matrix":
                        var f = _floats(child.textContent);
                        this.bindShapeMatrix = getConvertedMat4(f);
                        break;
                    case "source":
                        var src = new Source().parse(child);
                        sources[src.id] = src;
                        break;
                    case "joints":
                        joints = child;
                        break;
                    case "vertex_weights":
                        weights = child;
                        break;
                    default:
                        console.log(child.nodeName);
                        break;
                }
            }
            this.parseJoints(joints, sources);
            this.parseWeights(weights, sources);
            return this;
        };
        Skin.prototype.parseJoints = function (element, sources) {
            for (var i = 0; i < element.childNodes.length; i++) {
                var child = element.childNodes[i];
                if (child.nodeType != 1) continue;
                switch (child.nodeName) {
                    case "input":
                        var input = new Input().parse(child);
                        var source = sources[input.source];
                        if (input.semantic === "JOINT") {
                            this.joints = source.read();
                        } else if (input.semantic === "INV_BIND_MATRIX") {
                            this.invBindMatrices = source.read();
                        }
                        break;
                    default:
                        break;
                }
            }
        };
        Skin.prototype.parseWeights = function (element, sources) {
            var v,
                vcount,
                inputs = [];
            for (var i = 0; i < element.childNodes.length; i++) {
                var child = element.childNodes[i];
                if (child.nodeType != 1) continue;
                switch (child.nodeName) {
                    case "input":
                        inputs.push(new Input().parse(child));
                        break;
                    case "v":
                        v = _ints(child.textContent);
                        break;
                    case "vcount":
                        vcount = _ints(child.textContent);
                        break;
                    default:
                        break;
                }
            }
            var index = 0;
            for (var i = 0; i < vcount.length; i++) {
                var numBones = vcount[i];
                var vertex_weights = [];
                for (var j = 0; j < numBones; j++) {
                    var influence = {};
                    for (var k = 0; k < inputs.length; k++) {
                        var input = inputs[k];
                        var value = v[index + input.offset];
                        switch (input.semantic) {
                            case "JOINT":
                                influence.joint = value;
                                break;
                            case "WEIGHT":
                                influence.weight = sources[input.source].data[value];
                                break;
                            default:
                                break;
                        }
                    }
                    vertex_weights.push(influence);
                    index += inputs.length;
                }
                for (var j = 0; j < vertex_weights.length; j++) {
                    vertex_weights[j].index = i;
                }
                this.weights.push(vertex_weights);
            }
        };
        function VisualScene() {
            this.id = "";
            this.name = "";
            this.nodes = [];
            this.scene = new THREE.Group();
        }
        VisualScene.prototype.getChildById = function (id, recursive) {
            for (var i = 0; i < this.nodes.length; i++) {
                var node = this.nodes[i].getChildById(id, recursive);
                if (node) {
                    return node;
                }
            }
            return null;
        };
        VisualScene.prototype.getChildBySid = function (sid, recursive) {
            for (var i = 0; i < this.nodes.length; i++) {
                var node = this.nodes[i].getChildBySid(sid, recursive);
                if (node) {
                    return node;
                }
            }
            return null;
        };
        VisualScene.prototype.parse = function (element) {
            this.id = element.getAttribute("id");
            this.name = element.getAttribute("name");
            this.nodes = [];
            for (var i = 0; i < element.childNodes.length; i++) {
                var child = element.childNodes[i];
                if (child.nodeType != 1) continue;
                switch (child.nodeName) {
                    case "node":
                        this.nodes.push(new Node().parse(child));
                        break;
                    default:
                        break;
                }
            }
            return this;
        };
        function Node() {
            this.id = "";
            this.name = "";
            this.sid = "";
            this.nodes = [];
            this.controllers = [];
            this.transforms = [];
            this.geometries = [];
            this.channels = [];
            this.matrix = new THREE.Matrix4();
        }
        Node.prototype.getChannelForTransform = function (transformSid) {
            for (var i = 0; i < this.channels.length; i++) {
                var channel = this.channels[i];
                var parts = channel.target.split("/");
                var id = parts.shift();
                var sid = parts.shift();
                var dotSyntax = sid.indexOf(".") >= 0;
                var arrSyntax = sid.indexOf("(") >= 0;
                var arrIndices;
                var member;
                if (dotSyntax) {
                    parts = sid.split(".");
                    sid = parts.shift();
                    member = parts.shift();
                } else if (arrSyntax) {
                    arrIndices = sid.split("(");
                    sid = arrIndices.shift();
                    for (var j = 0; j < arrIndices.length; j++) {
                        arrIndices[j] = parseInt(arrIndices[j].replace(/\)/, ""));
                    }
                }
                if (sid === transformSid) {
                    channel.info = { sid: sid, dotSyntax: dotSyntax, arrSyntax: arrSyntax, arrIndices: arrIndices };
                    return channel;
                }
            }
            return null;
        };
        Node.prototype.getChildById = function (id, recursive) {
            if (this.id === id) {
                return this;
            }
            if (recursive) {
                for (var i = 0; i < this.nodes.length; i++) {
                    var n = this.nodes[i].getChildById(id, recursive);
                    if (n) {
                        return n;
                    }
                }
            }
            return null;
        };
        Node.prototype.getChildBySid = function (sid, recursive) {
            if (this.sid === sid) {
                return this;
            }
            if (recursive) {
                for (var i = 0; i < this.nodes.length; i++) {
                    var n = this.nodes[i].getChildBySid(sid, recursive);
                    if (n) {
                        return n;
                    }
                }
            }
            return null;
        };
        Node.prototype.getTransformBySid = function (sid) {
            for (var i = 0; i < this.transforms.length; i++) {
                if (this.transforms[i].sid === sid) return this.transforms[i];
            }
            return null;
        };
        Node.prototype.parse = function (element) {
            var url;
            this.id = element.getAttribute("id");
            this.sid = element.getAttribute("sid");
            this.name = element.getAttribute("name");
            this.type = element.getAttribute("type");
            this.layer = element.getAttribute("layer");
            this.type = this.type === "JOINT" ? this.type : "NODE";
            this.nodes = [];
            this.transforms = [];
            this.geometries = [];
            this.cameras = [];
            this.lights = [];
            this.controllers = [];
            this.matrix = new THREE.Matrix4();
            for (var i = 0; i < element.childNodes.length; i++) {
                var child = element.childNodes[i];
                if (child.nodeType != 1) continue;
                switch (child.nodeName) {
                    case "node":
                        this.nodes.push(new Node().parse(child));
                        break;
                    case "instance_camera":
                        this.cameras.push(new InstanceCamera().parse(child));
                        break;
                    case "instance_controller":
                        this.controllers.push(new InstanceController().parse(child));
                        break;
                    case "instance_geometry":
                        this.geometries.push(new InstanceGeometry().parse(child));
                        break;
                    case "instance_light":
                        this.lights.push(new InstanceLight().parse(child));
                        break;
                    case "instance_node":
                        url = child.getAttribute("url").replace(/^#/, "");
                        var iNode = getLibraryNode(url);
                        if (iNode) {
                            this.nodes.push(new Node().parse(iNode));
                        }
                        break;
                    case "rotate":
                    case "translate":
                    case "scale":
                    case "matrix":
                    case "lookat":
                    case "skew":
                        this.transforms.push(new Transform().parse(child));
                        break;
                    case "extra":
                        break;
                    default:
                        console.log(child.nodeName);
                        break;
                }
            }
            this.channels = getChannelsForNode(this);
            bakeAnimations(this);
            this.updateMatrix();
            return this;
        };
        Node.prototype.updateMatrix = function () {
            this.matrix.identity();
            for (var i = 0; i < this.transforms.length; i++) {
                this.transforms[i].apply(this.matrix);
            }
        };
        function Transform() {
            this.sid = "";
            this.type = "";
            this.data = [];
            this.obj = null;
        }
        Transform.prototype.parse = function (element) {
            this.sid = element.getAttribute("sid");
            this.type = element.nodeName;
            this.data = _floats(element.textContent);
            this.convert();
            return this;
        };
        Transform.prototype.convert = function () {
            switch (this.type) {
                case "matrix":
                    this.obj = getConvertedMat4(this.data);
                    break;
                case "rotate":
                    this.angle = THREE.Math.degToRad(this.data[3]);
                case "translate":
                    fixCoords(this.data, -1);
                    this.obj = new THREE.Vector3(this.data[0], this.data[1], this.data[2]);
                    break;
                case "scale":
                    fixCoords(this.data, 1);
                    this.obj = new THREE.Vector3(this.data[0], this.data[1], this.data[2]);
                    break;
                default:
                    console.log("Can not convert Transform of type " + this.type);
                    break;
            }
        };
        Transform.prototype.apply = (function () {
            var m1 = new THREE.Matrix4();
            return function (matrix) {
                switch (this.type) {
                    case "matrix":
                        matrix.multiply(this.obj);
                        break;
                    case "translate":
                        matrix.multiply(m1.makeTranslation(this.obj.x, this.obj.y, this.obj.z));
                        break;
                    case "rotate":
                        matrix.multiply(m1.makeRotationAxis(this.obj, this.angle));
                        break;
                    case "scale":
                        matrix.scale(this.obj);
                        break;
                }
            };
        })();
        Transform.prototype.update = function (data, member) {
            var members = ["X", "Y", "Z", "ANGLE"];
            switch (this.type) {
                case "matrix":
                    if (!member) {
                        this.obj.copy(data);
                    } else if (member.length === 1) {
                        switch (member[0]) {
                            case 0:
                                this.obj.n11 = data[0];
                                this.obj.n21 = data[1];
                                this.obj.n31 = data[2];
                                this.obj.n41 = data[3];
                                break;
                            case 1:
                                this.obj.n12 = data[0];
                                this.obj.n22 = data[1];
                                this.obj.n32 = data[2];
                                this.obj.n42 = data[3];
                                break;
                            case 2:
                                this.obj.n13 = data[0];
                                this.obj.n23 = data[1];
                                this.obj.n33 = data[2];
                                this.obj.n43 = data[3];
                                break;
                            case 3:
                                this.obj.n14 = data[0];
                                this.obj.n24 = data[1];
                                this.obj.n34 = data[2];
                                this.obj.n44 = data[3];
                                break;
                        }
                    } else if (member.length === 2) {
                        var propName = "n" + (member[0] + 1) + (member[1] + 1);
                        this.obj[propName] = data;
                    } else {
                        console.log("Incorrect addressing of matrix in transform.");
                    }
                    break;
                case "translate":
                case "scale":
                    if (Object.prototype.toString.call(member) === "[object Array]") {
                        member = members[member[0]];
                    }
                    switch (member) {
                        case "X":
                            this.obj.x = data;
                            break;
                        case "Y":
                            this.obj.y = data;
                            break;
                        case "Z":
                            this.obj.z = data;
                            break;
                        default:
                            this.obj.x = data[0];
                            this.obj.y = data[1];
                            this.obj.z = data[2];
                            break;
                    }
                    break;
                case "rotate":
                    if (Object.prototype.toString.call(member) === "[object Array]") {
                        member = members[member[0]];
                    }
                    switch (member) {
                        case "X":
                            this.obj.x = data;
                            break;
                        case "Y":
                            this.obj.y = data;
                            break;
                        case "Z":
                            this.obj.z = data;
                            break;
                        case "ANGLE":
                            this.angle = THREE.Math.degToRad(data);
                            break;
                        default:
                            this.obj.x = data[0];
                            this.obj.y = data[1];
                            this.obj.z = data[2];
                            this.angle = THREE.Math.degToRad(data[3]);
                            break;
                    }
                    break;
            }
        };
        function InstanceController() {
            this.url = "";
            this.skeleton = [];
            this.instance_material = [];
        }
        InstanceController.prototype.parse = function (element) {
            this.url = element.getAttribute("url").replace(/^#/, "");
            this.skeleton = [];
            this.instance_material = [];
            for (var i = 0; i < element.childNodes.length; i++) {
                var child = element.childNodes[i];
                if (child.nodeType !== 1) continue;
                switch (child.nodeName) {
                    case "skeleton":
                        this.skeleton.push(child.textContent.replace(/^#/, ""));
                        break;
                    case "bind_material":
                        var instances = child.querySelectorAll("instance_material");
                        for (var j = 0; j < instances.length; j++) {
                            var instance = instances[j];
                            this.instance_material.push(new InstanceMaterial().parse(instance));
                        }
                        break;
                    case "extra":
                        break;
                    default:
                        break;
                }
            }
            return this;
        };
        function InstanceMaterial() {
            this.symbol = "";
            this.target = "";
        }
        InstanceMaterial.prototype.parse = function (element) {
            this.symbol = element.getAttribute("symbol");
            this.target = element.getAttribute("target").replace(/^#/, "");
            return this;
        };
        function InstanceGeometry() {
            this.url = "";
            this.instance_material = [];
        }
        InstanceGeometry.prototype.parse = function (element) {
            this.url = element.getAttribute("url").replace(/^#/, "");
            this.instance_material = [];
            for (var i = 0; i < element.childNodes.length; i++) {
                var child = element.childNodes[i];
                if (child.nodeType != 1) continue;
                if (child.nodeName === "bind_material") {
                    var instances = child.querySelectorAll("instance_material");
                    for (var j = 0; j < instances.length; j++) {
                        var instance = instances[j];
                        this.instance_material.push(new InstanceMaterial().parse(instance));
                    }
                    break;
                }
            }
            return this;
        };
        function Geometry() {
            this.id = "";
            this.mesh = null;
        }
        Geometry.prototype.parse = function (element) {
            this.id = element.getAttribute("id");
            extractDoubleSided(this, element);
            for (var i = 0; i < element.childNodes.length; i++) {
                var child = element.childNodes[i];
                switch (child.nodeName) {
                    case "mesh":
                        this.mesh = new Mesh(this).parse(child);
                        break;
                    case "extra":
                        break;
                    default:
                        break;
                }
            }
            return this;
        };
        function Mesh(geometry) {
            this.geometry = geometry.id;
            this.primitives = [];
            this.vertices = null;
            this.geometry3js = null;
        }
        Mesh.prototype.parse = function (element) {
            this.primitives = [];
            for (var i = 0; i < element.childNodes.length; i++) {
                var child = element.childNodes[i];
                switch (child.nodeName) {
                    case "source":
                        _source(child);
                        break;
                    case "vertices":
                        this.vertices = new Vertices().parse(child);
                        break;
                    case "linestrips":
                        this.primitives.push(new LineStrips().parse(child));
                        break;
                    case "triangles":
                        this.primitives.push(new Triangles().parse(child));
                        break;
                    case "polygons":
                        this.primitives.push(new Polygons().parse(child));
                        break;
                    case "polylist":
                        this.primitives.push(new Polylist().parse(child));
                        break;
                    default:
                        break;
                }
            }
            this.geometry3js = new THREE.Geometry();
            if (this.vertices === null) {
                return this;
            }
            var vertexData = sources[this.vertices.input["POSITION"].source].data;
            for (var i = 0; i < vertexData.length; i += 3) {
                this.geometry3js.vertices.push(getConvertedVec3(vertexData, i).clone());
            }
            for (var i = 0; i < this.primitives.length; i++) {
                var primitive = this.primitives[i];
                primitive.setVertices(this.vertices);
                this.handlePrimitive(primitive, this.geometry3js);
            }
            if (this.geometry3js.calcNormals) {
                this.geometry3js.computeVertexNormals();
                delete this.geometry3js.calcNormals;
            }
            return this;
        };
        Mesh.prototype.handlePrimitive = function (primitive, geom) {
            if (primitive instanceof LineStrips) {
                geom.isLineStrip = true;
                return;
            }
            var j,
                k,
                pList = primitive.p,
                inputs = primitive.inputs;
            var input, index, idx32;
            var source, numParams;
            var vcIndex = 0,
                vcount = 3,
                maxOffset = 0;
            var texture_sets = [];
            for (j = 0; j < inputs.length; j++) {
                input = inputs[j];
                var offset = input.offset + 1;
                maxOffset = maxOffset < offset ? offset : maxOffset;
                switch (input.semantic) {
                    case "TEXCOORD":
                        texture_sets.push(input.set);
                        break;
                }
            }
            for (var pCount = 0; pCount < pList.length; ++pCount) {
                var p = pList[pCount],
                    i = 0;
                while (i < p.length) {
                    var vs = [];
                    var ns = [];
                    var ts = null;
                    var cs = [];
                    if (primitive.vcount) {
                        vcount = primitive.vcount.length ? primitive.vcount[vcIndex++] : primitive.vcount;
                    } else {
                        vcount = p.length / maxOffset;
                    }
                    for (j = 0; j < vcount; j++) {
                        for (k = 0; k < inputs.length; k++) {
                            input = inputs[k];
                            source = sources[input.source];
                            index = p[i + j * maxOffset + input.offset];
                            numParams = source.accessor.params.length;
                            idx32 = index * numParams;
                            switch (input.semantic) {
                                case "VERTEX":
                                    vs.push(index);
                                    break;
                                case "NORMAL":
                                    ns.push(getConvertedVec3(source.data, idx32));
                                    break;
                                case "TEXCOORD":
                                    ts = ts || {};
                                    if (ts[input.set] === undefined) ts[input.set] = [];
                                    ts[input.set].push(new THREE.Vector2(source.data[idx32], source.data[idx32 + 1]));
                                    break;
                                case "COLOR":
                                    cs.push(new THREE.Color().setRGB(source.data[idx32], source.data[idx32 + 1], source.data[idx32 + 2]));
                                    break;
                                default:
                                    break;
                            }
                        }
                    }
                    if (ns.length === 0) {
                        input = this.vertices.input.NORMAL;
                        if (input) {
                            source = sources[input.source];
                            numParams = source.accessor.params.length;
                            for (var ndx = 0, len = vs.length; ndx < len; ndx++) {
                                ns.push(getConvertedVec3(source.data, vs[ndx] * numParams));
                            }
                        } else {
                            geom.calcNormals = true;
                        }
                    }
                    if (!ts) {
                        ts = {};
                        input = this.vertices.input.TEXCOORD;
                        if (input) {
                            texture_sets.push(input.set);
                            source = sources[input.source];
                            numParams = source.accessor.params.length;
                            for (var ndx = 0, len = vs.length; ndx < len; ndx++) {
                                idx32 = vs[ndx] * numParams;
                                if (ts[input.set] === undefined) ts[input.set] = [];
                                ts[input.set].push(new THREE.Vector2(source.data[idx32], 1 - source.data[idx32 + 1]));
                            }
                        }
                    }
                    if (cs.length === 0) {
                        input = this.vertices.input.COLOR;
                        if (input) {
                            source = sources[input.source];
                            numParams = source.accessor.params.length;
                            for (var ndx = 0, len = vs.length; ndx < len; ndx++) {
                                idx32 = vs[ndx] * numParams;
                                cs.push(new THREE.Color().setRGB(source.data[idx32], source.data[idx32 + 1], source.data[idx32 + 2]));
                            }
                        }
                    }
                    var face = null,
                        faces = [],
                        uv,
                        uvArr;
                    if (vcount === 3) {
                        faces.push(new THREE.Face3(vs[0], vs[1], vs[2], ns, cs.length ? cs : new THREE.Color()));
                    } else if (vcount === 4) {
                        faces.push(new THREE.Face3(vs[0], vs[1], vs[3], ns.length ? [ns[0].clone(), ns[1].clone(), ns[3].clone()] : [], cs.length ? [cs[0], cs[1], cs[3]] : new THREE.Color()));
                        faces.push(new THREE.Face3(vs[1], vs[2], vs[3], ns.length ? [ns[1].clone(), ns[2].clone(), ns[3].clone()] : [], cs.length ? [cs[1], cs[2], cs[3]] : new THREE.Color()));
                    } else if (vcount > 4 && options.subdivideFaces) {
                        var clr = cs.length ? cs : new THREE.Color(),
                            vec1,
                            vec2,
                            vec3,
                            v1,
                            v2,
                            norm;
                        for (k = 1; k < vcount - 1;) {
                            faces.push(new THREE.Face3(vs[0], vs[k], vs[k + 1], ns.length ? [ns[0].clone(), ns[k++].clone(), ns[k].clone()] : [], clr));
                        }
                    }
                    if (faces.length) {
                        for (var ndx = 0, len = faces.length; ndx < len; ndx++) {
                            face = faces[ndx];
                            face.daeMaterial = primitive.material;
                            geom.faces.push(face);
                            for (k = 0; k < texture_sets.length; k++) {
                                uv = ts[texture_sets[k]];
                                if (vcount > 4) {
                                    uvArr = [uv[0], uv[ndx + 1], uv[ndx + 2]];
                                } else if (vcount === 4) {
                                    if (ndx === 0) {
                                        uvArr = [uv[0], uv[1], uv[3]];
                                    } else {
                                        uvArr = [uv[1].clone(), uv[2], uv[3].clone()];
                                    }
                                } else {
                                    uvArr = [uv[0], uv[1], uv[2]];
                                }
                                if (geom.faceVertexUvs[k] === undefined) {
                                    geom.faceVertexUvs[k] = [];
                                }
                                geom.faceVertexUvs[k].push(uvArr);
                            }
                        }
                    } else {
                        console.log("dropped face with vcount " + vcount + " for geometry with id: " + geom.id);
                    }
                    i += maxOffset * vcount;
                }
            }
        };
        function Polygons() {
            this.material = "";
            this.count = 0;
            this.inputs = [];
            this.vcount = null;
            this.p = [];
            this.geometry = new THREE.Geometry();
        }
        Polygons.prototype.setVertices = function (vertices) {
            for (var i = 0; i < this.inputs.length; i++) {
                if (this.inputs[i].source === vertices.id) {
                    this.inputs[i].source = vertices.input["POSITION"].source;
                }
            }
        };
        Polygons.prototype.parse = function (element) {
            this.material = element.getAttribute("material");
            this.count = _attr_as_int(element, "count", 0);
            for (var i = 0; i < element.childNodes.length; i++) {
                var child = element.childNodes[i];
                switch (child.nodeName) {
                    case "input":
                        this.inputs.push(new Input().parse(element.childNodes[i]));
                        break;
                    case "vcount":
                        this.vcount = _ints(child.textContent);
                        break;
                    case "p":
                        this.p.push(_ints(child.textContent));
                        break;
                    case "ph":
                        console.warn("polygon holes not yet supported!");
                        break;
                    default:
                        break;
                }
            }
            return this;
        };
        function Polylist() {
            Polygons.call(this);
            this.vcount = [];
        }
        Polylist.prototype = Object.create(Polygons.prototype);
        Polylist.prototype.constructor = Polylist;
        function LineStrips() {
            Polygons.call(this);
            this.vcount = 1;
        }
        LineStrips.prototype = Object.create(Polygons.prototype);
        LineStrips.prototype.constructor = LineStrips;
        function Triangles() {
            Polygons.call(this);
            this.vcount = 3;
        }
        Triangles.prototype = Object.create(Polygons.prototype);
        Triangles.prototype.constructor = Triangles;
        function Accessor() {
            this.source = "";
            this.count = 0;
            this.stride = 0;
            this.params = [];
        }
        Accessor.prototype.parse = function (element) {
            this.params = [];
            this.source = element.getAttribute("source");
            this.count = _attr_as_int(element, "count", 0);
            this.stride = _attr_as_int(element, "stride", 0);
            for (var i = 0; i < element.childNodes.length; i++) {
                var child = element.childNodes[i];
                if (child.nodeName === "param") {
                    var param = {};
                    param["name"] = child.getAttribute("name");
                    param["type"] = child.getAttribute("type");
                    this.params.push(param);
                }
            }
            return this;
        };
        function Vertices() {
            this.input = {};
        }
        Vertices.prototype.parse = function (element) {
            this.id = element.getAttribute("id");
            for (var i = 0; i < element.childNodes.length; i++) {
                if (element.childNodes[i].nodeName === "input") {
                    var input = new Input().parse(element.childNodes[i]);
                    this.input[input.semantic] = input;
                }
            }
            return this;
        };
        function Input() {
            this.semantic = "";
            this.offset = 0;
            this.source = "";
            this.set = 0;
        }
        Input.prototype.parse = function (element) {
            this.semantic = element.getAttribute("semantic");
            this.source = element.getAttribute("source").replace(/^#/, "");
            this.set = _attr_as_int(element, "set", -1);
            this.offset = _attr_as_int(element, "offset", 0);
            if (this.semantic === "TEXCOORD" && this.set < 0) {
                this.set = 0;
            }
            return this;
        };
        function Source(id) {
            this.id = id;
            this.type = null;
        }
        Source.prototype.parse = function (element) {
            this.id = element.getAttribute("id");
            for (var i = 0; i < element.childNodes.length; i++) {
                var child = element.childNodes[i];
                switch (child.nodeName) {
                    case "bool_array":
                        this.data = _bools(child.textContent);
                        this.type = child.nodeName;
                        break;
                    case "float_array":
                        this.data = _floats(child.textContent);
                        this.type = child.nodeName;
                        break;
                    case "int_array":
                        this.data = _ints(child.textContent);
                        this.type = child.nodeName;
                        break;
                    case "IDREF_array":
                    case "Name_array":
                        this.data = _strings(child.textContent);
                        this.type = child.nodeName;
                        break;
                    case "technique_common":
                        for (var j = 0; j < child.childNodes.length; j++) {
                            if (child.childNodes[j].nodeName === "accessor") {
                                this.accessor = new Accessor().parse(child.childNodes[j]);
                                break;
                            }
                        }
                        break;
                    default:
                        break;
                }
            }
            return this;
        };
        Source.prototype.read = function () {
            var result = [];
            var param = this.accessor.params[0];
            switch (param.type) {
                case "IDREF":
                case "Name":
                case "name":
                case "float":
                    return this.data;
                case "float4x4":
                    for (var j = 0; j < this.data.length; j += 16) {
                        var s = this.data.slice(j, j + 16);
                        var m = getConvertedMat4(s);
                        result.push(m);
                    }
                    break;
                default:
                    console.log("ColladaLoader: Source: Read dont know how to read " + param.type + ".");
                    break;
            }
            return result;
        };
        function Material() {
            this.id = "";
            this.name = "";
            this.instance_effect = null;
        }
        Material.prototype.parse = function (element) {
            this.id = element.getAttribute("id");
            this.name = element.getAttribute("name");
            for (var i = 0; i < element.childNodes.length; i++) {
                if (element.childNodes[i].nodeName === "instance_effect") {
                    this.instance_effect = new InstanceEffect().parse(element.childNodes[i]);
                    break;
                }
            }
            return this;
        };
        function ColorOrTexture() {
            this.color = new THREE.Color();
            this.color.setRGB(Math.random(), Math.random(), Math.random());
            this.color.a = 1;
            this.texture = null;
            this.texcoord = null;
            this.texOpts = null;
        }
        ColorOrTexture.prototype.isColor = function () {
            return this.texture === null;
        };
        ColorOrTexture.prototype.isTexture = function () {
            return this.texture != null;
        };
        ColorOrTexture.prototype.parse = function (element) {
            if (element.nodeName === "transparent") {
                this.opaque = element.getAttribute("opaque");
            }
            for (var i = 0; i < element.childNodes.length; i++) {
                var child = element.childNodes[i];
                if (child.nodeType != 1) continue;
                switch (child.nodeName) {
                    case "color":
                        var rgba = _floats(child.textContent);
                        this.color = new THREE.Color();
                        this.color.setRGB(rgba[0], rgba[1], rgba[2]);
                        this.color.a = rgba[3];
                        break;
                    case "texture":
                        this.texture = child.getAttribute("texture");
                        this.texcoord = child.getAttribute("texcoord");
                        this.texOpts = { offsetU: 0, offsetV: 0, repeatU: 1, repeatV: 1, wrapU: 1, wrapV: 1 };
                        this.parseTexture(child);
                        break;
                    default:
                        break;
                }
            }
            return this;
        };
        ColorOrTexture.prototype.parseTexture = function (element) {
            if (!element.childNodes) return this;
            if (element.childNodes[1] && element.childNodes[1].nodeName === "extra") {
                element = element.childNodes[1];
                if (element.childNodes[1] && element.childNodes[1].nodeName === "technique") {
                    element = element.childNodes[1];
                }
            }
            for (var i = 0; i < element.childNodes.length; i++) {
                var child = element.childNodes[i];
                switch (child.nodeName) {
                    case "offsetU":
                    case "offsetV":
                    case "repeatU":
                    case "repeatV":
                        this.texOpts[child.nodeName] = parseFloat(child.textContent);
                        break;
                    case "wrapU":
                    case "wrapV":
                        if (child.textContent.toUpperCase() === "TRUE") {
                            this.texOpts[child.nodeName] = 1;
                        } else {
                            this.texOpts[child.nodeName] = parseInt(child.textContent);
                        }
                        break;
                    default:
                        this.texOpts[child.nodeName] = child.textContent;
                        break;
                }
            }
            return this;
        };
        function Shader(type, effect) {
            this.type = type;
            this.effect = effect;
            this.material = null;
        }
        Shader.prototype.parse = function (element) {
            for (var i = 0; i < element.childNodes.length; i++) {
                var child = element.childNodes[i];
                if (child.nodeType != 1) continue;
                switch (child.nodeName) {
                    case "emission":
                    case "diffuse":
                    case "specular":
                    case "transparent":
                        this[child.nodeName] = new ColorOrTexture().parse(child);
                        break;
                    case "bump":
                        var bumpType = child.getAttribute("bumptype");
                        if (bumpType) {
                            if (bumpType.toLowerCase() === "heightfield") {
                                this["bump"] = new ColorOrTexture().parse(child);
                            } else if (bumpType.toLowerCase() === "normalmap") {
                                this["normal"] = new ColorOrTexture().parse(child);
                            } else {
                                console.error("Shader.prototype.parse: Invalid value for attribute 'bumptype' (" + bumpType + ") - valid bumptypes are 'HEIGHTFIELD' and 'NORMALMAP' - defaulting to 'HEIGHTFIELD'");
                                this["bump"] = new ColorOrTexture().parse(child);
                            }
                        } else {
                            console.warn("Shader.prototype.parse: Attribute 'bumptype' missing from bump node - defaulting to 'HEIGHTFIELD'");
                            this["bump"] = new ColorOrTexture().parse(child);
                        }
                        break;
                    case "shininess":
                    case "reflectivity":
                    case "index_of_refraction":
                    case "transparency":
                        var f = child.querySelectorAll("float");
                        if (f.length > 0) this[child.nodeName] = parseFloat(f[0].textContent);
                        break;
                    default:
                        break;
                }
            }
            this.create();
            return this;
        };
        Shader.prototype.create = function () {
            var props = {};
            var transparent = false;
            if (this["transparency"] !== undefined && this["transparent"] !== undefined) {
                var transparentColor = this["transparent"];
                var transparencyLevel = ((this.transparent.color.r + this.transparent.color.g + this.transparent.color.b) / 3) * this.transparency;
                if (transparencyLevel > 0) {
                    transparent = true;
                    props["transparent"] = true;
                    props["opacity"] = 1 - transparencyLevel;
                }
            }
            var keys = { diffuse: "map", ambient: "lightMap", specular: "specularMap", emission: "emissionMap", bump: "bumpMap", normal: "normalMap" };
            for (var prop in this) {
                switch (prop) {
                    case "ambient":
                    case "emission":
                    case "diffuse":
                    case "specular":
                    case "bump":
                    case "normal":
                        var cot = this[prop];
                        if (cot instanceof ColorOrTexture) {
                            if (cot.isTexture()) {
                                var samplerId = cot.texture;
                                var surfaceId = this.effect.sampler[samplerId];
                                if (surfaceId !== undefined && surfaceId.source !== undefined) {
                                    var surface = this.effect.surface[surfaceId.source];
                                    if (surface !== undefined) {
                                        var image = images[surface.init_from];
                                        if (image) {
                                            var url = baseUrl + image.init_from;
                                            var texture;
                                            var loader = THREE.Loader.Handlers.get(url);
                                            if (loader !== null) {
                                                texture = loader.load(url);
                                            } else {
                                                texture = new THREE.Texture();
                                                loadTextureImage(texture, url);
                                            }
                                            texture.wrapS = cot.texOpts.wrapU ? THREE.RepeatWrapping : THREE.ClampToEdgeWrapping;
                                            texture.wrapT = cot.texOpts.wrapV ? THREE.RepeatWrapping : THREE.ClampToEdgeWrapping;
                                            texture.offset.x = cot.texOpts.offsetU;
                                            texture.offset.y = cot.texOpts.offsetV;
                                            texture.repeat.x = cot.texOpts.repeatU;
                                            texture.repeat.y = cot.texOpts.repeatV;
                                            props[keys[prop]] = texture;
                                            if (prop === "emission") props["emissive"] = 16777215;
                                        }
                                    }
                                }
                            } else if (prop === "diffuse" || !transparent) {
                                if (prop === "emission") {
                                    props["emissive"] = cot.color.getHex();
                                } else {
                                    props[prop] = cot.color.getHex();
                                }
                            }
                        }
                        break;
                    case "shininess":
                        props[prop] = this[prop];
                        break;
                    case "reflectivity":
                        props[prop] = this[prop];
                        if (props[prop] > 0) props["envMap"] = options.defaultEnvMap;
                        props["combine"] = THREE.MixOperation;
                        break;
                    case "index_of_refraction":
                        props["refractionRatio"] = this[prop];
                        if (this[prop] !== 1) props["envMap"] = options.defaultEnvMap;
                        break;
                    case "transparency":
                        break;
                    default:
                        break;
                }
            }
            props["shading"] = preferredShading;
            props["side"] = this.effect.doubleSided ? THREE.DoubleSide : THREE.FrontSide;
            if (props.diffuse !== undefined) {
                props.color = props.diffuse;
                delete props.diffuse;
            }
            switch (this.type) {
                case "constant":
                    if (props.emissive != undefined) props.color = props.emissive;
                    this.material = new THREE.MeshBasicMaterial(props);
                    break;
                case "phong":
                case "blinn":
                    this.material = new THREE.MeshPhongMaterial(props);
                    break;
                case "lambert":
                default:
                    this.material = new THREE.MeshLambertMaterial(props);
                    break;
            }
            return this.material;
        };
        function Surface(effect) {
            this.effect = effect;
            this.init_from = null;
            this.format = null;
        }
        Surface.prototype.parse = function (element) {
            for (var i = 0; i < element.childNodes.length; i++) {
                var child = element.childNodes[i];
                if (child.nodeType != 1) continue;
                switch (child.nodeName) {
                    case "init_from":
                        this.init_from = child.textContent;
                        break;
                    case "format":
                        this.format = child.textContent;
                        break;
                    default:
                        console.log("unhandled Surface prop: " + child.nodeName);
                        break;
                }
            }
            return this;
        };
        function Sampler2D(effect) {
            this.effect = effect;
            this.source = null;
            this.wrap_s = null;
            this.wrap_t = null;
            this.minfilter = null;
            this.magfilter = null;
            this.mipfilter = null;
        }
        Sampler2D.prototype.parse = function (element) {
            for (var i = 0; i < element.childNodes.length; i++) {
                var child = element.childNodes[i];
                if (child.nodeType != 1) continue;
                switch (child.nodeName) {
                    case "source":
                        this.source = child.textContent;
                        break;
                    case "minfilter":
                        this.minfilter = child.textContent;
                        break;
                    case "magfilter":
                        this.magfilter = child.textContent;
                        break;
                    case "mipfilter":
                        this.mipfilter = child.textContent;
                        break;
                    case "wrap_s":
                        this.wrap_s = child.textContent;
                        break;
                    case "wrap_t":
                        this.wrap_t = child.textContent;
                        break;
                    default:
                        console.log("unhandled Sampler2D prop: " + child.nodeName);
                        break;
                }
            }
            return this;
        };
        function Effect() {
            this.id = "";
            this.name = "";
            this.shader = null;
            this.surface = {};
            this.sampler = {};
        }
        Effect.prototype.create = function () {
            if (this.shader === null) {
                return null;
            }
        };
        Effect.prototype.parse = function (element) {
            this.id = element.getAttribute("id");
            this.name = element.getAttribute("name");
            extractDoubleSided(this, element);
            this.shader = null;
            for (var i = 0; i < element.childNodes.length; i++) {
                var child = element.childNodes[i];
                if (child.nodeType != 1) continue;
                switch (child.nodeName) {
                    case "profile_COMMON":
                        this.parseTechnique(this.parseProfileCOMMON(child));
                        break;
                    default:
                        break;
                }
            }
            return this;
        };
        Effect.prototype.parseNewparam = function (element) {
            var sid = element.getAttribute("sid");
            for (var i = 0; i < element.childNodes.length; i++) {
                var child = element.childNodes[i];
                if (child.nodeType != 1) continue;
                switch (child.nodeName) {
                    case "surface":
                        this.surface[sid] = new Surface(this).parse(child);
                        break;
                    case "sampler2D":
                        this.sampler[sid] = new Sampler2D(this).parse(child);
                        break;
                    case "extra":
                        break;
                    default:
                        console.log(child.nodeName);
                        break;
                }
            }
        };
        Effect.prototype.parseProfileCOMMON = function (element) {
            var technique;
            for (var i = 0; i < element.childNodes.length; i++) {
                var child = element.childNodes[i];
                if (child.nodeType != 1) continue;
                switch (child.nodeName) {
                    case "profile_COMMON":
                        this.parseProfileCOMMON(child);
                        break;
                    case "technique":
                        technique = child;
                        break;
                    case "newparam":
                        this.parseNewparam(child);
                        break;
                    case "image":
                        var _image = new _Image().parse(child);
                        images[_image.id] = _image;
                        break;
                    case "extra":
                        break;
                    default:
                        console.log(child.nodeName);
                        break;
                }
            }
            return technique;
        };
        Effect.prototype.parseTechnique = function (element) {
            for (var i = 0; i < element.childNodes.length; i++) {
                var child = element.childNodes[i];
                if (child.nodeType != 1) continue;
                switch (child.nodeName) {
                    case "constant":
                    case "lambert":
                    case "blinn":
                    case "phong":
                        this.shader = new Shader(child.nodeName, this).parse(child);
                        break;
                    case "extra":
                        this.parseExtra(child);
                        break;
                    default:
                        break;
                }
            }
        };
        Effect.prototype.parseExtra = function (element) {
            for (var i = 0; i < element.childNodes.length; i++) {
                var child = element.childNodes[i];
                if (child.nodeType != 1) continue;
                switch (child.nodeName) {
                    case "technique":
                        this.parseExtraTechnique(child);
                        break;
                    default:
                        break;
                }
            }
        };
        Effect.prototype.parseExtraTechnique = function (element) {
            for (var i = 0; i < element.childNodes.length; i++) {
                var child = element.childNodes[i];
                if (child.nodeType != 1) continue;
                switch (child.nodeName) {
                    case "bump":
                        this.shader.parse(element);
                        break;
                    default:
                        break;
                }
            }
        };
        function InstanceEffect() {
            this.url = "";
        }
        InstanceEffect.prototype.parse = function (element) {
            this.url = element.getAttribute("url").replace(/^#/, "");
            return this;
        };
        function Animation() {
            this.id = "";
            this.name = "";
            this.source = {};
            this.sampler = [];
            this.channel = [];
        }
        Animation.prototype.parse = function (element) {
            this.id = element.getAttribute("id");
            this.name = element.getAttribute("name");
            this.source = {};
            for (var i = 0; i < element.childNodes.length; i++) {
                var child = element.childNodes[i];
                if (child.nodeType != 1) continue;
                switch (child.nodeName) {
                    case "animation":
                        var anim = new Animation().parse(child);
                        for (var src in anim.source) {
                            this.source[src] = anim.source[src];
                        }
                        for (var j = 0; j < anim.channel.length; j++) {
                            this.channel.push(anim.channel[j]);
                            this.sampler.push(anim.sampler[j]);
                        }
                        break;
                    case "source":
                        var src = new Source().parse(child);
                        this.source[src.id] = src;
                        break;
                    case "sampler":
                        this.sampler.push(new Sampler(this).parse(child));
                        break;
                    case "channel":
                        this.channel.push(new Channel(this).parse(child));
                        break;
                    default:
                        break;
                }
            }
            return this;
        };
        function Channel(animation) {
            this.animation = animation;
            this.source = "";
            this.target = "";
            this.fullSid = null;
            this.sid = null;
            this.dotSyntax = null;
            this.arrSyntax = null;
            this.arrIndices = null;
            this.member = null;
        }
        Channel.prototype.parse = function (element) {
            this.source = element.getAttribute("source").replace(/^#/, "");
            this.target = element.getAttribute("target");
            var parts = this.target.split("/");
            var id = parts.shift();
            var sid = parts.shift();
            var dotSyntax = sid.indexOf(".") >= 0;
            var arrSyntax = sid.indexOf("(") >= 0;
            if (dotSyntax) {
                parts = sid.split(".");
                this.sid = parts.shift();
                this.member = parts.shift();
            } else if (arrSyntax) {
                var arrIndices = sid.split("(");
                this.sid = arrIndices.shift();
                for (var j = 0; j < arrIndices.length; j++) {
                    arrIndices[j] = parseInt(arrIndices[j].replace(/\)/, ""));
                }
                this.arrIndices = arrIndices;
            } else {
                this.sid = sid;
            }
            this.fullSid = sid;
            this.dotSyntax = dotSyntax;
            this.arrSyntax = arrSyntax;
            return this;
        };
        function Sampler(animation) {
            this.id = "";
            this.animation = animation;
            this.inputs = [];
            this.input = null;
            this.output = null;
            this.strideOut = null;
            this.interpolation = null;
            this.startTime = null;
            this.endTime = null;
            this.duration = 0;
        }
        Sampler.prototype.parse = function (element) {
            this.id = element.getAttribute("id");
            this.inputs = [];
            for (var i = 0; i < element.childNodes.length; i++) {
                var child = element.childNodes[i];
                if (child.nodeType != 1) continue;
                switch (child.nodeName) {
                    case "input":
                        this.inputs.push(new Input().parse(child));
                        break;
                    default:
                        break;
                }
            }
            return this;
        };
        Sampler.prototype.create = function () {
            for (var i = 0; i < this.inputs.length; i++) {
                var input = this.inputs[i];
                var source = this.animation.source[input.source];
                switch (input.semantic) {
                    case "INPUT":
                        this.input = source.read();
                        break;
                    case "OUTPUT":
                        this.output = source.read();
                        this.strideOut = source.accessor.stride;
                        break;
                    case "INTERPOLATION":
                        this.interpolation = source.read();
                        break;
                    case "IN_TANGENT":
                        break;
                    case "OUT_TANGENT":
                        break;
                    default:
                        console.log(input.semantic);
                        break;
                }
            }
            this.startTime = 0;
            this.endTime = 0;
            this.duration = 0;
            if (this.input.length) {
                this.startTime = 1e8;
                this.endTime = -1e8;
                for (var i = 0; i < this.input.length; i++) {
                    this.startTime = Math.min(this.startTime, this.input[i]);
                    this.endTime = Math.max(this.endTime, this.input[i]);
                }
                this.duration = this.endTime - this.startTime;
            }
        };
        Sampler.prototype.getData = function (type, ndx, member) {
            var data;
            if (type === "matrix" && this.strideOut === 16) {
                data = this.output[ndx];
            } else if (this.strideOut > 1) {
                data = [];
                ndx *= this.strideOut;
                for (var i = 0; i < this.strideOut; ++i) {
                    data[i] = this.output[ndx + i];
                }
                if (this.strideOut === 3) {
                    switch (type) {
                        case "rotate":
                        case "translate":
                            fixCoords(data, -1);
                            break;
                        case "scale":
                            fixCoords(data, 1);
                            break;
                    }
                } else if (this.strideOut === 4 && type === "matrix") {
                    fixCoords(data, -1);
                }
            } else {
                data = this.output[ndx];
                if (member && type === "translate") {
                    data = getConvertedTranslation(member, data);
                }
            }
            return data;
        };
        function Key(time) {
            this.targets = [];
            this.time = time;
        }
        Key.prototype.addTarget = function (fullSid, transform, member, data) {
            this.targets.push({ sid: fullSid, member: member, transform: transform, data: data });
        };
        Key.prototype.apply = function (opt_sid) {
            for (var i = 0; i < this.targets.length; ++i) {
                var target = this.targets[i];
                if (!opt_sid || target.sid === opt_sid) {
                    target.transform.update(target.data, target.member);
                }
            }
        };
        Key.prototype.getTarget = function (fullSid) {
            for (var i = 0; i < this.targets.length; ++i) {
                if (this.targets[i].sid === fullSid) {
                    return this.targets[i];
                }
            }
            return null;
        };
        Key.prototype.hasTarget = function (fullSid) {
            for (var i = 0; i < this.targets.length; ++i) {
                if (this.targets[i].sid === fullSid) {
                    return true;
                }
            }
            return false;
        };
        Key.prototype.interpolate = function (nextKey, time) {
            for (var i = 0, l = this.targets.length; i < l; i++) {
                var target = this.targets[i],
                    nextTarget = nextKey.getTarget(target.sid),
                    data;
                if (target.transform.type !== "matrix" && nextTarget) {
                    var scale = (time - this.time) / (nextKey.time - this.time),
                        nextData = nextTarget.data,
                        prevData = target.data;
                    if (scale < 0) scale = 0;
                    if (scale > 1) scale = 1;
                    if (prevData.length) {
                        data = [];
                        for (var j = 0; j < prevData.length; ++j) {
                            data[j] = prevData[j] + (nextData[j] - prevData[j]) * scale;
                        }
                    } else {
                        data = prevData + (nextData - prevData) * scale;
                    }
                } else {
                    data = target.data;
                }
                target.transform.update(data, target.member);
            }
        };
        function Camera() {
            this.id = "";
            this.name = "";
            this.technique = "";
        }
        Camera.prototype.parse = function (element) {
            this.id = element.getAttribute("id");
            this.name = element.getAttribute("name");
            for (var i = 0; i < element.childNodes.length; i++) {
                var child = element.childNodes[i];
                if (child.nodeType != 1) continue;
                switch (child.nodeName) {
                    case "optics":
                        this.parseOptics(child);
                        break;
                    default:
                        break;
                }
            }
            return this;
        };
        Camera.prototype.parseOptics = function (element) {
            for (var i = 0; i < element.childNodes.length; i++) {
                if (element.childNodes[i].nodeName === "technique_common") {
                    var technique = element.childNodes[i];
                    for (var j = 0; j < technique.childNodes.length; j++) {
                        this.technique = technique.childNodes[j].nodeName;
                        if (this.technique === "perspective") {
                            var perspective = technique.childNodes[j];
                            for (var k = 0; k < perspective.childNodes.length; k++) {
                                var param = perspective.childNodes[k];
                                switch (param.nodeName) {
                                    case "yfov":
                                        this.yfov = param.textContent;
                                        break;
                                    case "xfov":
                                        this.xfov = param.textContent;
                                        break;
                                    case "znear":
                                        this.znear = param.textContent;
                                        break;
                                    case "zfar":
                                        this.zfar = param.textContent;
                                        break;
                                    case "aspect_ratio":
                                        this.aspect_ratio = param.textContent;
                                        break;
                                }
                            }
                        } else if (this.technique === "orthographic") {
                            var orthographic = technique.childNodes[j];
                            for (var k = 0; k < orthographic.childNodes.length; k++) {
                                var param = orthographic.childNodes[k];
                                switch (param.nodeName) {
                                    case "xmag":
                                        this.xmag = param.textContent;
                                        break;
                                    case "ymag":
                                        this.ymag = param.textContent;
                                        break;
                                    case "znear":
                                        this.znear = param.textContent;
                                        break;
                                    case "zfar":
                                        this.zfar = param.textContent;
                                        break;
                                    case "aspect_ratio":
                                        this.aspect_ratio = param.textContent;
                                        break;
                                }
                            }
                        }
                    }
                }
            }
            return this;
        };
        function InstanceCamera() {
            this.url = "";
        }
        InstanceCamera.prototype.parse = function (element) {
            this.url = element.getAttribute("url").replace(/^#/, "");
            return this;
        };
        function Light() {
            this.id = "";
            this.name = "";
            this.technique = "";
        }
        Light.prototype.parse = function (element) {
            this.id = element.getAttribute("id");
            this.name = element.getAttribute("name");
            for (var i = 0; i < element.childNodes.length; i++) {
                var child = element.childNodes[i];
                if (child.nodeType != 1) continue;
                switch (child.nodeName) {
                    case "technique_common":
                        this.parseCommon(child);
                        break;
                    case "technique":
                        this.parseTechnique(child);
                        break;
                    default:
                        break;
                }
            }
            return this;
        };
        Light.prototype.parseCommon = function (element) {
            for (var i = 0; i < element.childNodes.length; i++) {
                switch (element.childNodes[i].nodeName) {
                    case "directional":
                    case "point":
                    case "spot":
                    case "ambient":
                        this.technique = element.childNodes[i].nodeName;
                        var light = element.childNodes[i];
                        for (var j = 0; j < light.childNodes.length; j++) {
                            var child = light.childNodes[j];
                            switch (child.nodeName) {
                                case "color":
                                    var rgba = _floats(child.textContent);
                                    this.color = new THREE.Color(0);
                                    this.color.setRGB(rgba[0], rgba[1], rgba[2]);
                                    this.color.a = rgba[3];
                                    break;
                                case "falloff_angle":
                                    this.falloff_angle = parseFloat(child.textContent);
                                    break;
                                case "quadratic_attenuation":
                                    var f = parseFloat(child.textContent);
                                    this.distance = f ? Math.sqrt(1 / f) : 0;
                            }
                        }
                }
            }
            return this;
        };
        Light.prototype.parseTechnique = function (element) {
            this.profile = element.getAttribute("profile");
            for (var i = 0; i < element.childNodes.length; i++) {
                var child = element.childNodes[i];
                switch (child.nodeName) {
                    case "intensity":
                        this.intensity = parseFloat(child.textContent);
                        break;
                }
            }
            return this;
        };
        function InstanceLight() {
            this.url = "";
        }
        InstanceLight.prototype.parse = function (element) {
            this.url = element.getAttribute("url").replace(/^#/, "");
            return this;
        };
        function KinematicsModel() {
            this.id = "";
            this.name = "";
            this.joints = [];
            this.links = [];
        }
        KinematicsModel.prototype.parse = function (element) {
            this.id = element.getAttribute("id");
            this.name = element.getAttribute("name");
            this.joints = [];
            this.links = [];
            for (var i = 0; i < element.childNodes.length; i++) {
                var child = element.childNodes[i];
                if (child.nodeType != 1) continue;
                switch (child.nodeName) {
                    case "technique_common":
                        this.parseCommon(child);
                        break;
                    default:
                        break;
                }
            }
            return this;
        };
        KinematicsModel.prototype.parseCommon = function (element) {
            for (var i = 0; i < element.childNodes.length; i++) {
                var child = element.childNodes[i];
                if (child.nodeType != 1) continue;
                switch (element.childNodes[i].nodeName) {
                    case "joint":
                        this.joints.push(new Joint().parse(child));
                        break;
                    case "link":
                        this.links.push(new Link().parse(child));
                        break;
                    default:
                        break;
                }
            }
            return this;
        };
        function Joint() {
            this.sid = "";
            this.name = "";
            this.axis = new THREE.Vector3();
            this.limits = { min: 0, max: 0 };
            this.type = "";
            this.static = false;
            this.zeroPosition = 0;
            this.middlePosition = 0;
        }
        Joint.prototype.parse = function (element) {
            this.sid = element.getAttribute("sid");
            this.name = element.getAttribute("name");
            this.axis = new THREE.Vector3();
            this.limits = { min: 0, max: 0 };
            this.type = "";
            this.static = false;
            this.zeroPosition = 0;
            this.middlePosition = 0;
            var axisElement = element.querySelector("axis");
            var _axis = _floats(axisElement.textContent);
            this.axis = getConvertedVec3(_axis, 0);
            var min = element.querySelector("limits min") ? parseFloat(element.querySelector("limits min").textContent) : -360;
            var max = element.querySelector("limits max") ? parseFloat(element.querySelector("limits max").textContent) : 360;
            this.limits = { min: min, max: max };
            var jointTypes = ["prismatic", "revolute"];
            for (var i = 0; i < jointTypes.length; i++) {
                var type = jointTypes[i];
                var jointElement = element.querySelector(type);
                if (jointElement) {
                    this.type = type;
                }
            }
            if (this.limits.min >= this.limits.max) {
                this.static = true;
            }
            this.middlePosition = (this.limits.min + this.limits.max) / 2;
            return this;
        };
        function Link() {
            this.sid = "";
            this.name = "";
            this.transforms = [];
            this.attachments = [];
        }
        Link.prototype.parse = function (element) {
            this.sid = element.getAttribute("sid");
            this.name = element.getAttribute("name");
            this.transforms = [];
            this.attachments = [];
            for (var i = 0; i < element.childNodes.length; i++) {
                var child = element.childNodes[i];
                if (child.nodeType != 1) continue;
                switch (child.nodeName) {
                    case "attachment_full":
                        this.attachments.push(new Attachment().parse(child));
                        break;
                    case "rotate":
                    case "translate":
                    case "matrix":
                        this.transforms.push(new Transform().parse(child));
                        break;
                    default:
                        break;
                }
            }
            return this;
        };
        function Attachment() {
            this.joint = "";
            this.transforms = [];
            this.links = [];
        }
        Attachment.prototype.parse = function (element) {
            this.joint = element.getAttribute("joint").split("/").pop();
            this.links = [];
            for (var i = 0; i < element.childNodes.length; i++) {
                var child = element.childNodes[i];
                if (child.nodeType != 1) continue;
                switch (child.nodeName) {
                    case "link":
                        this.links.push(new Link().parse(child));
                        break;
                    case "rotate":
                    case "translate":
                    case "matrix":
                        this.transforms.push(new Transform().parse(child));
                        break;
                    default:
                        break;
                }
            }
            return this;
        };
        function _source(element) {
            var id = element.getAttribute("id");
            if (sources[id] != undefined) {
                return sources[id];
            }
            sources[id] = new Source(id).parse(element);
            return sources[id];
        }
        function _bools(str) {
            var raw = _strings(str);
            var data = [];
            for (var i = 0, l = raw.length; i < l; i++) {
                data.push(raw[i] === "true" || raw[i] === "1" ? true : false);
            }
            return data;
        }
        function _floats(str) {
            var raw = _strings(str);
            var data = [];
            for (var i = 0, l = raw.length; i < l; i++) {
                data.push(parseFloat(raw[i]));
            }
            return data;
        }
        function _ints(str) {
            var raw = _strings(str);
            var data = [];
            for (var i = 0, l = raw.length; i < l; i++) {
                data.push(parseInt(raw[i], 10));
            }
            return data;
        }
        function _strings(str) {
            return str.length > 0 ? _trimString(str).split(/\s+/) : [];
        }
        function _trimString(str) {
            return str.replace(/^\s+/, "").replace(/\s+$/, "");
        }
        function _attr_as_int(element, name, defaultValue) {
            if (element.hasAttribute(name)) {
                return parseInt(element.getAttribute(name), 10);
            } else {
                return defaultValue;
            }
        }
        function loadTextureImage(texture, url) {
            var loader = new THREE.ImageLoader();
            loader.load(url, function (image) {
                texture.image = image;
                texture.needsUpdate = true;
            });
        }
        function extractDoubleSided(obj, element) {
            obj.doubleSided = false;
            var node = element.querySelectorAll("extra double_sided")[0];
            if (node) {
                if (node && parseInt(node.textContent, 10) === 1) {
                    obj.doubleSided = true;
                }
            }
        }
        function setUpConversion() {
            if (options.convertUpAxis !== true || colladaUp === options.upAxis) {
                upConversion = null;
            } else {
                switch (colladaUp) {
                    case "X":
                        upConversion = options.upAxis === "Y" ? "XtoY" : "XtoZ";
                        break;
                    case "Y":
                        upConversion = options.upAxis === "X" ? "YtoX" : "YtoZ";
                        break;
                    case "Z":
                        upConversion = options.upAxis === "X" ? "ZtoX" : "ZtoY";
                        break;
                }
            }
        }
        function fixCoords(data, sign) {
            if (options.convertUpAxis !== true || colladaUp === options.upAxis) {
                return;
            }
            switch (upConversion) {
                case "XtoY":
                    var tmp = data[0];
                    data[0] = sign * data[1];
                    data[1] = tmp;
                    break;
                case "XtoZ":
                    var tmp = data[2];
                    data[2] = data[1];
                    data[1] = data[0];
                    data[0] = tmp;
                    break;
                case "YtoX":
                    var tmp = data[0];
                    data[0] = data[1];
                    data[1] = sign * tmp;
                    break;
                case "YtoZ":
                    var tmp = data[1];
                    data[1] = sign * data[2];
                    data[2] = tmp;
                    break;
                case "ZtoX":
                    var tmp = data[0];
                    data[0] = data[1];
                    data[1] = data[2];
                    data[2] = tmp;
                    break;
                case "ZtoY":
                    var tmp = data[1];
                    data[1] = data[2];
                    data[2] = sign * tmp;
                    break;
            }
        }
        function getConvertedTranslation(axis, data) {
            if (options.convertUpAxis !== true || colladaUp === options.upAxis) {
                return data;
            }
            switch (axis) {
                case "X":
                    data = upConversion === "XtoY" ? data * -1 : data;
                    break;
                case "Y":
                    data = upConversion === "YtoZ" || upConversion === "YtoX" ? data * -1 : data;
                    break;
                case "Z":
                    data = upConversion === "ZtoY" ? data * -1 : data;
                    break;
                default:
                    break;
            }
            return data;
        }
        function getConvertedVec3(data, offset) {
            var arr = [data[offset], data[offset + 1], data[offset + 2]];
            fixCoords(arr, -1);
            return new THREE.Vector3(arr[0], arr[1], arr[2]);
        }
        function getConvertedMat4(data) {
            if (options.convertUpAxis) {
                var arr = [data[0], data[4], data[8]];
                fixCoords(arr, -1);
                data[0] = arr[0];
                data[4] = arr[1];
                data[8] = arr[2];
                arr = [data[1], data[5], data[9]];
                fixCoords(arr, -1);
                data[1] = arr[0];
                data[5] = arr[1];
                data[9] = arr[2];
                arr = [data[2], data[6], data[10]];
                fixCoords(arr, -1);
                data[2] = arr[0];
                data[6] = arr[1];
                data[10] = arr[2];
                arr = [data[0], data[1], data[2]];
                fixCoords(arr, -1);
                data[0] = arr[0];
                data[1] = arr[1];
                data[2] = arr[2];
                arr = [data[4], data[5], data[6]];
                fixCoords(arr, -1);
                data[4] = arr[0];
                data[5] = arr[1];
                data[6] = arr[2];
                arr = [data[8], data[9], data[10]];
                fixCoords(arr, -1);
                data[8] = arr[0];
                data[9] = arr[1];
                data[10] = arr[2];
                arr = [data[3], data[7], data[11]];
                fixCoords(arr, -1);
                data[3] = arr[0];
                data[7] = arr[1];
                data[11] = arr[2];
            }
            return new THREE.Matrix4().set(data[0], data[1], data[2], data[3], data[4], data[5], data[6], data[7], data[8], data[9], data[10], data[11], data[12], data[13], data[14], data[15]);
        }
        function getConvertedIndex(index) {
            if (index > -1 && index < 3) {
                var members = ["X", "Y", "Z"],
                    indices = { X: 0, Y: 1, Z: 2 };
                index = getConvertedMember(members[index]);
                index = indices[index];
            }
            return index;
        }
        function getConvertedMember(member) {
            if (options.convertUpAxis) {
                switch (member) {
                    case "X":
                        switch (upConversion) {
                            case "XtoY":
                            case "XtoZ":
                            case "YtoX":
                                member = "Y";
                                break;
                            case "ZtoX":
                                member = "Z";
                                break;
                        }
                        break;
                    case "Y":
                        switch (upConversion) {
                            case "XtoY":
                            case "YtoX":
                            case "ZtoX":
                                member = "X";
                                break;
                            case "XtoZ":
                            case "YtoZ":
                            case "ZtoY":
                                member = "Z";
                                break;
                        }
                        break;
                    case "Z":
                        switch (upConversion) {
                            case "XtoZ":
                                member = "X";
                                break;
                            case "YtoZ":
                            case "ZtoX":
                            case "ZtoY":
                                member = "Y";
                                break;
                        }
                        break;
                }
            }
            return member;
        }
        return { load: load, parse: parse, setPreferredShading: setPreferredShading, applySkin: applySkin, geometries: geometries, options: options };
    };
    function ChapterLoader($http, $q, $timeout) {
        var length,
            deferred,
            fileload,
            progress,
            total = 0,
            store = [],
            onProgress,
            onFileLoad,
            loader = {},
            session = [],
            loading = false;
        function loadChapter(index) {
            var chapter = store[index],
                chunkLoader = loader[index];
            chunkLoader.count = 0;
            chunkLoader.length = 0;
            chunkLoader.progress = 0;
            chunkLoader.loaded = false;
            chunkLoader.key = chapter.key;
            chunkLoader.response["statue"] = {};
            if (chapter.statue.mesh) {
                chunkLoader.loaders.statue_mesh = new THREE.OBJLoader();
                chunkLoader.loaders.statue_mesh.load(
                    chapter.statue.mesh,
                    function (obj) {
                        chunkLoader.response["statue"].mesh = obj;
                        chunkComplete(chunkLoader);
                    },
                    function (e) {
                        if (!chunkLoader.loaders.statue_mesh.xhr) chunkLoader.loaders.statue_mesh.xhr = e.currentTarget;
                        chunkLoader.loaders.statue_mesh.progress = e.loaded / e.total;
                        chunkProgress(chunkLoader);
                    }
                );
                ++chunkLoader.length;
            }
            if (chapter.statue.texture) {
                chunkLoader.loaders.statue_texture = new THREE.TextureLoader();
                chunkLoader.loaders.statue_texture.load(
                    chapter.statue.texture,
                    function (texture) {
                        chunkLoader.response["statue"].texture = texture;
                        chunkComplete(chunkLoader);
                    },
                    function (e) {
                        if (!chunkLoader.loaders.statue_texture.xhr) chunkLoader.loaders.statue_texture.xhr = e.currentTarget;
                        chunkLoader.loaders.statue_texture.progress = e.loaded / e.total;
                        chunkProgress(chunkLoader);
                    }
                );
                ++chunkLoader.length;
            }
            chunkLoader.response["hotspots"] = {};
            if (chapter.hotspots.mesh) {
                chunkLoader.loaders.hotspots_mesh = new THREE.OBJLoader();
                chunkLoader.loaders.hotspots_mesh.load(
                    chapter.hotspots.mesh,
                    function (obj) {
                        chunkLoader.response["hotspots"].mesh = obj;
                        chunkComplete(chunkLoader);
                    },
                    function (e) {
                        if (!chunkLoader.loaders.hotspots_mesh.xhr) chunkLoader.loaders.hotspots_mesh.xhr = e.currentTarget;
                        chunkLoader.loaders.hotspots_mesh.progress = e.loaded / e.total;
                        chunkProgress(chunkLoader);
                    }
                );
                ++chunkLoader.length;
            }
            if (chapter.hotspots.texture) {
                chunkLoader.loaders.hotspots_texture = new THREE.TextureLoader();
                chunkLoader.loaders.hotspots_texture.load(
                    chapter.hotspots.texture,
                    function (texture) {
                        chunkLoader.response["hotspots"].texture = texture;
                        chunkComplete(chunkLoader);
                    },
                    function (e) {
                        if (!chunkLoader.loaders.hotspots_texture.xhr) chunkLoader.loaders.hotspots_texture.xhr = e.currentTarget;
                        chunkLoader.loaders.hotspots_texture.progress = e.loaded / e.total;
                        chunkProgress(chunkLoader);
                    }
                );
                ++chunkLoader.length;
            }
            if (chapter.hotspots.alphamap) {
                chunkLoader.loaders.hotspots_alphamap = new THREE.TextureLoader();
                chunkLoader.loaders.hotspots_alphamap.load(
                    chapter.hotspots.alphamap,
                    function (alphamap) {
                        chunkLoader.response["hotspots"].alphamap = alphamap;
                        chunkComplete(chunkLoader);
                    },
                    function (e) {
                        if (!chunkLoader.loaders.hotspots_alphamap.xhr) chunkLoader.loaders.hotspots_alphamap.xhr = e.currentTarget;
                        chunkLoader.loaders.hotspots_alphamap.progress = e.loaded / e.total;
                        chunkProgress(chunkLoader);
                    }
                );
                ++chunkLoader.length;
            }
            if (chapter.hotspots.firetex) {
            }
            chunkLoader.response["splines"] = {};
            if (chapter.splines.scene) {
                chunkLoader.loaders.scene_spline = new THREE.ColladaLoader();
                chunkLoader.loaders.scene_spline.options.convertUpAxis = true;
                chunkLoader.loaders.scene_spline.load(
                    chapter.splines.scene,
                    function (collada) {
                        chunkLoader.response["splines"].scene = collada;
                        chunkLoader.loaders.scene_spline.progress = 1;
                        chunkProgress(chunkLoader);
                        chunkComplete(chunkLoader);
                    },
                    function (e) {
                        if (!chunkLoader.loaders.scene_spline.xhr) chunkLoader.loaders.scene_spline.xhr = e.currentTarget;
                        chunkLoader.loaders.scene_spline.progress = e.loaded / parseInt(e.total);
                        chunkProgress(chunkLoader);
                    }
                );
                ++chunkLoader.length;
            }
            if (chapter.splines.intro) {
                chunkLoader.loaders.intro_spline = new THREE.ColladaLoader();
                chunkLoader.loaders.intro_spline.options.convertUpAxis = true;
                chunkLoader.loaders.intro_spline.load(
                    chapter.splines.intro,
                    function (collada) {
                        chunkLoader.response["splines"].intro = collada;
                        chunkLoader.loaders.intro_spline.progress = 1;
                        chunkProgress(chunkLoader);
                        chunkComplete(chunkLoader);
                    },
                    function (e) {
                        if (!chunkLoader.loaders.intro_spline.xhr) chunkLoader.loaders.intro_spline.xhr = e.currentTarget;
                        chunkLoader.loaders.intro_spline.progress = e.loaded / e.total;
                        chunkProgress(chunkLoader);
                    }
                );
                ++chunkLoader.length;
            }
        }
        function chunkProgress(chunk) {
            chunk.progress = 0;
            var chapterProgress = 0;
            underscoreMin.each(chunk.loaders, function (loader) {
                chunk.progress += (loader.progress || 0) / chunk.length;
            });
            underscoreMin.each(session, function (chapter) {
                chapterProgress += chapter.progress / length;
            });
            if (onProgress) onProgress.call(null, Math.round(chapterProgress * 100) / 100);
        }
        function chunkComplete(chunk) {
            ++chunk.count;
            if (chunk.count == chunk.length) {
                chunk.loaded = true;
                ++fileload;
                if (onFileLoad) onFileLoad.call(null, chunk);
                if (fileload == length) {
                    deferred.resolve();
                    loading = false;
                }
            }
        }
        this.loading = function () {
            return loading;
        };
        this.getChunk = function (index) {
            var chunk = loader[index];
            return chunk;
        };
        this.load = function (index, limit, onprogress, onfileload) {
            this.close();
            fileload = 0;
            progress = 0;
            session = [];
            length = limit;
            loading = true;
            deferred = $q.defer();
            onProgress = onprogress;
            onFileLoad = onfileload;
            if (index >= store.length - 1) length = 1;
            for (var i = 0; i < length; ++i, ++index) {
                if (index < store.length && !loader[index]) {
                    loader[index] = { index: index, loaders: {}, response: {} };
                    session.push(loader[index]);
                    loadChapter(index);
                    ++total;
                }
            }
            return deferred.promise;
        };
        this.close = function () {
            if (!loading) return;
            loading = false;
            onProgress = undefined;
            onFileLoad = undefined;
            underscoreMin.each(session, function (chapter) {
                underscoreMin.each(chapter.loaders, function (loader) {
                    if (loader.xhr) loader.xhr.abort();
                });
                delete loader[chapter.index];
            });
        };
        this.store = function (array) {
            store = array;
        };
    }
    function CookieService() {
        var expireDays = 365,
            cookieEntry = "";
        return {
            get: function () {
                var expireDate = new Date();
                expireDate.setTime(expireDate.getTime() + expireDays * 864e5);
                expireDate = expireDate.toGMTString();
                cookieEntry = "cb-enabled={value}; expires=" + expireDate + "; path=/";
                var i,
                    cookieValue = "",
                    aCookie,
                    aCookies = document.cookie.split("; ");
                for (i = 0; i < aCookies.length; ++i) {
                    aCookie = aCookies[i].split("=");
                    if (aCookie[0] == "cb-enabled") {
                        cookieValue = aCookie[1];
                    }
                }
                if (cookieValue == "") {
                    cookieValue = "enabled";
                    document.cookie = cookieEntry.replace("{value}", "enabled");
                }
                return cookieValue == "accepted";
            },
            set: function () {
                document.cookie = cookieEntry.replace("{value}", "accepted");
                return this.get();
            },
        };
    }
    function SoundManager(MobileBrowser) {
        var muted = false;
        var store = { ambient: { src: "audio/wind.mp3", volume: 0.9 }, update: { src: "audio/update.mp3", volume: 1 }, fire: { src: "audio/fire.mp3", volume: 1 } };
        function setup() {
            var element;
            underscoreMin.each(store, function (audio) {
                element = $('<audio preload="auto" />')[0];
                element.src = audio.src + "?v=" + Date.now();
                element.volume = 0;
                audio.player = element;
            });
        }
        function play(sound, force, loop) {
            if (MobileBrowser.get()) return false;
            var player = store[sound].player;
            player.loop = loop;
            if (player.paused || force) {
                player.currentTime = 0;
                player.volume = muted ? 0 : store[sound].volume;
                player.play();
            }
        }
        function stop(sound) {
            var player = store[sound].player;
            if (!player.paused) {
                player.pause();
                player.volume = 0;
            }
        }
        function toggle() {
            if (MobileBrowser.get()) return false;
            muted = !muted;
            underscoreMin.each(store, function (audio) {
                if (!audio.player.paused) TweenMax.to(audio.player, 1, { volume: muted ? 0 : audio.volume, ease: Linear.easeNone });
            });
        }
        return { toggle: toggle, setup: setup, play: play, stop: stop };
    }
    function DataLoader($http, $q, $timeout) {
        var loader, deferred, response;
        var CONFIG_IT_API = "json/config-it.json",
            CONFIG_EN_API = "json/config-en.json",
            CONTENTS_IT_API = "json/contents-it.json",
            CONTENTS_EN_API = "json/contents-en.json";
        var manifest = [
            { id: "config_it", datatype: "json", src: CONFIG_IT_API },
            { id: "config_en", datatype: "json", src: CONFIG_EN_API },
            { id: "contents_it", datatype: "json", src: CONTENTS_IT_API },
            { id: "contents_en", datatype: "json", src: CONTENTS_EN_API },
            { id: "statue_shaders", datatype: "text", src: "js/shaders/statue.vs" },
            { id: "hotspots_shaders", datatype: "text", src: "js/shaders/hotspots.vs" },
            { id: "fb_icon", datatype: "assets", src: "img/assets/fb-icon.png" },
            { id: "gp_icon", datatype: "assets", src: "img/assets/gp-icon.png" },
            { id: "tw_icon", datatype: "assets", src: "img/assets/tw-icon.png" },
            { id: "tim_logo", datatype: "assets", src: "img/assets/tim-logo.png" },
            { id: "menu_back", datatype: "assets", src: "img/assets/menu-back.jpg" },
            { id: "link_icon", datatype: "assets", src: "img/assets/link-icon.png" },
            { id: "close_icon", datatype: "assets", src: "img/assets/close-icon.png" },
            { id: "audio_icon", datatype: "assets", src: "img/assets/audio-icon.png" },
            { id: "restart_icon", datatype: "assets", src: "img/assets/restart-icon.png" },
            { id: "arrow_prev_icon", datatype: "assets", src: "img/assets/arrow-prev-icon.png" },
            { id: "arrow_next_icon", datatype: "assets", src: "img/assets/arrow-next-icon.png" },
            { id: "capitale_logo", datatype: "assets", src: "img/assets/capitale-logo.png" },
            { id: "menu_top_arrow", datatype: "assets", src: "img/assets/menu-top-arrow.png" },
            { id: "menu_bot_arrow", datatype: "assets", src: "img/assets/menu-bot-arrow.png" },
        ];
        function getAssets(manifest, loader) {
            var assets = {};
            underscoreMin.each(manifest, function (item) {
                if (item.datatype == "assets") assets[item.id] = loader.getResult(item.id);
            });
            return assets;
        }
        return {
            load: function (progressCallback) {
                response = {};
                deferred = $q.defer();
                loader = new createjs.LoadQueue(false);
                loader.on("progress", function (e) {
                    if (progressCallback)
                        $timeout(function () {
                            progressCallback.call(null, Math.round(e.progress * 100) / 100);
                        });
                });
                loader.on("complete", function (e) {
                    response.book = { it: e.target.getResult("config_it").book, en: e.target.getResult("config_en").book };
                    response.params = { it: e.target.getResult("config_it").params, en: e.target.getResult("config_en").params };
                    response.locale = { it: e.target.getResult("config_it").locale, en: e.target.getResult("config_en").locale };
                    response.contents = { it: e.target.getResult("contents_it"), en: e.target.getResult("contents_en") };
                    response.shaders = { temp: e.target.getResult("temp_shaders"), statue: e.target.getResult("statue_shaders"), flames: e.target.getResult("flames_shaders"), hotspots: e.target.getResult("hotspots_shaders") };
                    response.assets = getAssets(manifest, e.target);
                    var fontLoader = new THREE.FontLoader();
                    fontLoader.load("json/luis.typeface.json", function (font) {
                        response.typeface = font;
                        $timeout(function () {
                            deferred.resolve(response);
                        }, 1e3);
                    });
                });
                loader.loadManifest(manifest);
                return deferred.promise;
            },
        };
    }
    function App3dCanvas() {
        return {
            template: '<canvas id="app-3d-canvas"></canvas>',
            replace: true,
            restrict: "E",
            link: function ($scope, $element, attrs, controller) {
                TweenMax.set($element, { x: 0 });
                $scope.setup3Dcanvas($element[0]);
            },
        };
    }
    function App2dCanvas() {
        return {
            template: '<canvas id="app-2d-canvas"></canvas>',
            replace: true,
            restrict: "E",
            link: function ($scope, $element, attrs, controller) {
                $scope.setup2Dcanvas($element[0]);
            },
        };
    }
    function AppChapter() {
        return {
            template: ['<div id="chapter-ui" class="" ng-class="{active:store.intro}"></div>'].join().replace(/,/g, ""),
            replace: true,
            restrict: "E",
            link: function ($scope, $element, attrs, controller) {
                return;
            },
        };
    }
    function Controller($scope, $state) {
        $scope.start = function () {
            $scope.changeChapter({ index: $scope.store.initIndex, snap: false });
        };
        this.listen(Events.INPUT_KEY, function (e, code) {
            if (code == 13) $scope.start();
        });
    }
    Controller.prototype = { constructor: Controller };
    Object.assign(Controller.prototype, EventDispatcher.prototype);
    function AppIntro(MobileBrowser) {
        return {
            controller: Controller,
            template: [
                '<div id="intro" class="intro-tween" >',
                '<div class="table">',
                '<div class="table-cell">',
                '<h2><span class="trajan-pro"></span></h2>',
                '<h1><span class="trajan-pro"></span></h1>',
                '<p><span class="timsans-bold"></span></p>',
                '<a class="cta" href="#" ng-click="start()"><span class="timsans-bold"></span></a>',
                "</div>",
                "</div>",
                "</div>",
            ]
                .join()
                .replace(/,/g, ""),
            replace: true,
            restrict: "E",
            link: function ($scope, $element, attrs, controller) {
                var mobile = MobileBrowser.get(),
                    locale = $scope.store.data.locale,
                    lang = $scope.store.lang;
                $element.find("h2").find("span").html(locale.intro.h2[lang]).end().splitLetters();
                $element.find("h1").find("span").html(locale.intro.h1[lang]).end().splitLetters();
                $element.find("p").find("span").html(locale.intro.p[lang]).end().splitLetters();
                $element.find("a").find("span").html(locale.intro.cta[lang]);
            },
        };
    }
    function Controller$1($scope, $state) {
        $scope.restart = function () {
            $scope.changeChapter({ index: 0, snap: false });
        };
        this.listen(Events.INPUT_KEY, function (e, code) {
            if (code == 13) $scope.restart();
        });
    }
    Controller$1.prototype = { constructor: Controller$1 };
    Object.assign(Controller$1.prototype, EventDispatcher.prototype);
    function AppFinal(MobileBrowser) {
        return {
            controller: Controller$1,
            template: [
                '<div id="final" class="final-tween" >',
                '<div class="back"></div>',
                '<div class="table">',
                '<div class="table-cell">',
                '<h1><span class="trajan-pro"></span></h1>',
                '<a class="cta website" href="http://www.mausoleodiaugusto.it/" target="_blank"><span class="timsans-bold"></span></a>',
                '<a class="cta restart" href="#" ng-click="restart()"> <img ng-src="{{ store.data.assets.restart_icon.src }}" alt="" /> <span class="timsans-bold"></span></a>',
                "</div>",
                "</div>",
                "</div>",
            ]
                .join()
                .replace(/,/g, ""),
            replace: true,
            restrict: "E",
            link: function ($scope, $element, attrs, controller) {
                var $el = $($element[0]),
                    mobile = MobileBrowser.get(),
                    locale = $scope.store.data.locale,
                    lang = $scope.store.lang;
                $el.find("h1").find("span").html(locale.final.h1[lang]).end().splitLetters();
                $el.find("a").eq(0).find("span").html(locale.ui.website[lang]);
                $el.find("a").eq(1).find("span").html(locale.final.cta[lang]);
            },
        };
    }
    function Controller$2($scope, $state, $timeout, MobileBrowser) {
        this.listen(Events.CHANGE_STATE, this.onChangeState, this);
        this.listen(Events.MENU_OPEN, this.onMenuOpen, this);
        this.listen(Events.RESIZE, this.resize, this);
        this.listen(Events.INPUT_WHEEL, this.onWheel, this);
        this.listen(Events.INPUT_START, this.onStart, this);
        this.listen(Events.INPUT_MOVE, this.onMove, this);
        this.listen(Events.INPUT_END, this.onEnd, this);
        $scope.prevChapter = underscoreMin.bind(this.prevChapter, this);
        $scope.nextChapter = underscoreMin.bind(this.nextChapter, this);
        $scope.gotoChapter = underscoreMin.bind(this.gotoChapter, this);
        $scope.selectRow = underscoreMin.bind(this.selectRow, this);
        this.$scope = $scope;
    }
    Controller$2.prototype = {
        constructor: Controller$2,
        setup: function ($element) {
            this.$el = $element;
            this.point = { x: 0, y: 0 };
            this.start = { x: 0, y: 0 };
            this.dist = { x: 0, y: 0 };
            this.drag = { x: 0, y: 0 };
            this.isBottomlock = false;
            this.isToplock = true;
            this.isDrag = false;
            this.isMove = false;
            this.open = false;
            this.startime = 0;
            this.timer = 0;
            this.count = 0;
            this.background = { img: null, bbox: 500, snap: 0, drag: 0 };
            this.scroller = {
                top: { chapter: null, title: null, bbox: 134, csnap: 0, tsnap: 0, drag: 0 },
                middle: { chapter: null, title: null, bbox: 114, csnap: 0, tsnap: 0, drag: 0 },
                bottom: { chapter: null, title: null, bbox: 134, csnap: 0, tsnap: 0, snap: 0 },
            };
            this.scroller.top.chapter = this.$el.find(".chapters-top ul");
            this.scroller.middle.chapter = this.$el.find(".chapters-middle ul");
            this.scroller.bottom.chapter = this.$el.find(".chapters-bottom ul");
            this.scroller.top.title = this.$el.find(".titles-top ul");
            this.scroller.middle.title = this.$el.find(".titles-middle ul");
            this.scroller.bottom.title = this.$el.find(".titles-bottom ul");
            this.background.img = this.$el.find("#menu-background img");
            this.limit = 11 * this.scroller.middle.bbox;
            this.move();
        },
        onWheel: function (e, delta) {
            if (!this.open) return;
            this.drag.y += delta * 0.35;
            this.isDrag = false;
            this.move();
            if (this.timer) clearTimeout(this.timer);
            this.timer = setTimeout(underscoreMin.bind(this.snap, this), 60);
        },
        onStart: function (e, options) {
            if (!this.open) return;
            this.startime = Date.now();
            this.point.x = options.mouse.x;
            this.point.y = options.mouse.y;
            this.start.x = this.drag.x;
            this.start.y = this.drag.y;
            this.isDrag = true;
            this.isMove = false;
        },
        onMove: function (e, options) {
            if (!this.isDrag) return;
            options.evt.preventDefault();
            this.dist.x = options.mouse.x - this.point.x;
            this.dist.y = options.mouse.y - this.point.y;
            if ((this.isToplock && this.dist.y > 0) || (this.isBottomlock && this.dist.y < 0)) this.dist.y /= 15;
            else this.dist.y *= 2;
            this.drag.x = this.start.x + this.dist.x;
            this.drag.y = this.start.y + this.dist.y;
            this.isMove = Math.abs(this.dist.y) > 0;
            this.move();
        },
        onEnd: function (e, mouse) {
            if (!this.open) return;
            this.isDrag = false;
            this.snap();
        },
        snap: function () {
            this.drag.y = Math.round(this.drag.y / this.scroller.middle.bbox) * this.scroller.middle.bbox;
            if (this.drag.y > 0) this.drag.y = 0;
            if (this.drag.y < -this.limit) this.drag.y = -this.limit;
            this.count = Math.floor(Math.abs(this.drag.y) / this.scroller.middle.bbox);
            this.isBottomlock = this.drag.y == -this.limit;
            this.isToplock = this.drag.y == 0;
            this.move();
        },
        move: function () {
            this.update();
            this.translate();
        },
        update: function () {
            var ratio1 = this.background.bbox / this.scroller.middle.bbox,
                ratio2 = this.scroller.top.bbox / this.scroller.middle.bbox,
                marginTop = window.innerHeight / 2 - this.scroller.top.bbox / 2,
                marginBottom = (this.scroller.top.bbox - this.scroller.middle.bbox) / 2 - this.scroller.top.bbox;
            this.background.drag = this.drag.y * ratio1;
            this.background.snap = this.background.drag;
            this.scroller.middle.drag = this.drag.y;
            this.scroller.top.drag = this.drag.y * ratio2 + marginTop;
            this.scroller.bottom.drag = this.drag.y * ratio2 + marginBottom;
            this.scroller.top.csnap = this.scroller.top.drag;
            this.scroller.middle.csnap = this.scroller.middle.drag;
            this.scroller.bottom.csnap = this.scroller.bottom.drag;
            this.scroller.top.tsnap = this.scroller.top.drag;
            this.scroller.middle.tsnap = this.scroller.middle.drag;
            this.scroller.bottom.tsnap = this.scroller.bottom.drag;
        },
        translate: function () {
            var deceleration = 0.002,
                distance = this.drag.y - this.start.y,
                time = Date.now() - this.startime,
                speed = Math.abs(distance) / time,
                duration = speed / deceleration / 1e3;
            if (duration > 1.2) duration = 1.2;
            TweenMax.to(this.background.img, duration + 1.25, { y: this.background.snap, ease: Expo.easeOut, force3D: true });
            TweenMax.to(this.scroller.top.chapter, duration + 1.25, { y: this.scroller.top.csnap, ease: Expo.easeOut, force3D: true });
            TweenMax.to(this.scroller.middle.chapter, duration + 0.75, { y: this.scroller.middle.csnap, ease: Expo.easeOut, force3D: true });
            TweenMax.to(this.scroller.bottom.chapter, duration + 1.25, { y: this.scroller.bottom.csnap, ease: Expo.easeOut, force3D: true });
            TweenMax.to(this.scroller.top.title, duration + 1.25, { y: this.scroller.top.tsnap, ease: Expo.easeOut, force3D: true });
            TweenMax.to(this.scroller.middle.title, duration + 0.75, { y: this.scroller.middle.tsnap, ease: Expo.easeOut, force3D: true });
            TweenMax.to(this.scroller.bottom.title, duration + 1.25, { y: this.scroller.bottom.tsnap, ease: Expo.easeOut, force3D: true });
        },
        onChangeState: function (e, state) {
            this.state = state;
        },
        onMenuOpen: function (e, open) {
            this.open = open;
            if (this.open) this.setCount(this.$scope.store.state.options.index);
            $(window).trigger(Events.RESIZE);
        },
        setCount: function (value) {
            this.count = value;
            this.drag.y = -this.scroller.middle.bbox * this.count;
            this.move();
        },
        selectRow: function (e) {
            if (this.isMove) return;
            this.setCount($(e.currentTarget).index());
        },
        prevChapter: function (e) {
            if (this.isMove) return;
            var prev = this.count;
            --prev;
            if (prev <= 0) prev = 0;
            this.setCount(prev);
        },
        nextChapter: function (e) {
            if (this.isMove) return;
            var next = this.count;
            ++next;
            if (next >= this.$scope.store.data.book.length - 1) next = this.$scope.store.data.book.length - 1;
            this.setCount(next);
        },
        gotoChapter: function (e) {
            if (this.isMove) return;
            var index = $(e.currentTarget).index();
            this.$scope.toggleMenu();
            TweenMax.delayedCall(
                1,
                underscoreMin.bind(function () {
                    this.$scope.changeChapter({ index: index, snap: false });
                }, this)
            );
        },
        resize: function (e, stagesize) {
            this.$el.find("#menu-prev").css({ right: (stagesize.x - 57) / 2 });
            this.$el.find("#menu-next").css({ right: (stagesize.x - 57) / 2 });
        },
    };
    Object.assign(Controller$2.prototype, EventDispatcher.prototype);
    function AppMenu() {
        return {
            controller: Controller$2,
            template: [
                '<div id="menu" class="menu-tween" ng-class="{ open:store.menuOpen }">',
                '<div id="menu-holder">',
                '<div id="menu-wrapper">',
                '<div id="menu-background">',
                '<div id="background-mask">',
                '<img ng-src="{{ store.data.assets.menu_back.src }}" alt="" />',
                "</div>",
                "</div>",
                '<div id="menu-middle-line"></div>',
                '<div id="menu-center-line"></div>',
                '<div id="menu-prev"><div class="holder"><img ng-src="{{ store.data.assets.menu_top_arrow.src }}" alt="" ng-click="prevChapter($event)" /></div></div>',
                '<div id="menu-next"><div class="holder"><img ng-src="{{ store.data.assets.menu_bot_arrow.src }}" alt="" ng-click="nextChapter($event)" /></div></div>',
                '<div id="menu-scroller">',
                '<div class="chapters-top">',
                "<ul>",
                '<li ng-repeat="chapter in store.data.book track by $index" ng-click="selectRow($event)">',
                '<div class="lside">',
                '<div class="table">',
                '<div class="table-cell">',
                '<h2><span class="trajan-pro"><span class="label">{{ store.data.locale.ui.chapter[store.lang] }}</span> <span class="label num"><span ng-if="$index < 9">0</span>{{ ( $index + 1 ) }}</span> </span></h2>',
                "</div>",
                "</div>",
                "</div>",
                '<div class="rside">',
                '<div class="table">',
                '<div class="table-cell">',
                '<h2><span class="timsans-bold" ng-bind-html="chapter.title"> </span></h2>',
                "</div>",
                "</div>",
                "</div>",
                "</li>",
                "</ul>",
                "</div>",
                '<div class="chapters-middle">',
                "<ul>",
                '<li ng-repeat="chapter in store.data.book track by $index" ng-click="gotoChapter($event)">',
                '<div class="lside">',
                '<div class="table">',
                '<div class="table-cell">',
                '<h2><span class="trajan-pro"><span class="label">{{ store.data.locale.ui.chapter[store.lang] }}</span> <span class="label num"><span ng-if="$index < 9">0</span>{{ ( $index + 1 ) }}</span> </span></h2>',
                "</div>",
                "</div>",
                "</div>",
                '<div class="rside">',
                '<div class="table">',
                '<div class="table-cell">',
                '<h2><span class="timsans-bold" ng-bind-html="chapter.title"> </span></h2>',
                "</div>",
                "</div>",
                "</div>",
                "</li>",
                "</ul>",
                "</div>",
                '<div class="chapters-bottom">',
                "<ul>",
                '<li ng-repeat="chapter in store.data.book track by $index" ng-click="selectRow($event)">',
                '<div class="lside">',
                '<div class="table">',
                '<div class="table-cell">',
                '<h2><span class="trajan-pro"><span class="label">{{ store.data.locale.ui.chapter[store.lang] }}</span> <span class="label num"><span ng-if="$index < 9">0</span>{{ ( $index + 1 ) }}</span> </span></h2>',
                "</div>",
                "</div>",
                "</div>",
                '<div class="rside">',
                '<div class="table">',
                '<div class="table-cell">',
                '<h2><span class="timsans-bold" ng-bind-html="chapter.title"> </span></h2>',
                "</div>",
                "</div>",
                "</div>",
                "</li>",
                "</ul>",
                "</div>",
                "</div>",
                "</div>",
                '<div id="menu-footer">',
                '<div id="social">',
                '<span class="icon"><img class="fb-icon" data-social="fb" ng-click="shareSite($event)" ng-src="{{ store.data.assets.fb_icon.src }}" alt="" /></span>',
                '<span class="icon"><img class="gp-icon" data-social="gp" ng-click="shareSite($event)" ng-src="{{ store.data.assets.gp_icon.src }}" alt="" /></span>',
                '<span class="icon"><img class="tw-icon" data-social="tw" ng-click="shareSite($event)" ng-src="{{ store.data.assets.tw_icon.src }}" alt="" /></span>',
                '<span class="line"></span>',
                "</div>",
                '<div id="lang-switch" class="{{ store.lang }}">',
                '<a class="lang-it" ng-click="changeLang($event)" data-lang="it"><span class="timsans-bold">It</span></a>',
                '<a class="lang-en" ng-click="changeLang($event)" data-lang="en"><span class="timsans-bold">En</span></a>',
                "</div>",
                '<div id="ex-link"><a href="http://www.mausoleodiaugusto.it/" target="_blank"><span class="timsans-bold">{{ store.data.locale.ui.website[store.lang] }}</span></a> </div>',
                "</div>",
                "</div>",
                "</div>",
            ]
                .join()
                .replace(/,/g, ""),
            replace: true,
            restrict: "E",
            link: function ($scope, $element, attrs, controller) {
                TweenMax.set($element, { autoAlpha: 0 });
                controller.setup($element);
            },
        };
    }
    function Controller$3($scope, $state, $window, SoundManager, CookieService) {
        var scope = this;
        $scope.toggleMenu = function (e) {
            $scope.store.menuOpen = !$scope.store.menuOpen;
            scope.dispatch(Events.MENU_OPEN, $scope.store.menuOpen);
        };
        $scope.shareSite = function (e) {
            var social = $(e.currentTarget).data("social");
            $.share({ social: social });
        };
        $scope.changeLang = function (e) {
            var lang = $(e.currentTarget).data("lang"),
                route = $window.location.href.replace(lang == "en" ? "/it/" : "/en/", lang == "en" ? "/en/" : "/it/");
            $window.location.href = route;
        };
        $scope.toggleSound = function (e) {
            SoundManager.toggle();
            $(e.currentTarget).toggleClass("muted");
            $scope.store.muted = $(e.currentTarget).hasClass("muted");
        };
        $scope.getCookie = function (e) {
            $scope.store.cookie = CookieService.get();
        };
        $scope.acceptCookie = function (e) {
            $scope.store.cookie = CookieService.set();
            return false;
        };
    }
    Controller$3.prototype = { constructor: Controller$3 };
    Object.assign(Controller$3.prototype, EventDispatcher.prototype);
    function AppUI($timeout, MobileBrowser) {
        return {
            controller: Controller$3,
            template: [
                '<div id="app-ui" class="appui-tween" ng-class="{active:store.start}">',
                '<div id="hamb-icon" ng-click="toggleMenu()" >',
                '<div class="hit-area">',
                '<div id="menu-icon">',
                '<div class="icon-line-1">',
                '<div class="icon-line-1-l"></div>',
                '<div class="icon-line-1-r"></div>',
                "</div>",
                '<div class="icon-line-2">',
                '<div class="icon-line-2-l"></div>',
                '<div class="icon-line-2-r"></div>',
                "</div>",
                '<div class="icon-line-3">',
                '<div class="icon-line-3-l"></div>',
                '<div class="icon-line-3-r"></div>',
                "</div>",
                "</div>",
                '<div id="close-icon">',
                '<span class="cl1"><span></span></span>',
                '<span class="cr1"><span></span></span>',
                '<span class="cl2"><span></span></span>',
                '<span class="cr2"><span></span></span>',
                "</div>",
                "</div>",
                "</div>",
                '<div id="logos">',
                '<a href="http://www.comune.roma.it/pcr/do/jpsite/Site/home" target="_blank"><img id="capitale-logo" ng-src="{{ store.data.assets.capitale_logo.src }}" alt="" /></a>',
                '<a href="http://www.fondazionetim.it/" target="_blank"><img id="tim-logo" ng-src="{{ store.data.assets.tim_logo.src }}" alt="" /></a>',
                "</div>",
                '<div id="social">',
                '<span class="icon"><img class="fb-icon" data-social="fb" ng-click="shareSite($event)" ng-src="{{ store.data.assets.fb_icon.src }}" alt="" /></span>',
                '<span class="icon"><img class="gp-icon" data-social="gp" ng-click="shareSite($event)" ng-src="{{ store.data.assets.gp_icon.src }}" alt="" /></span>',
                '<span class="icon"><img class="tw-icon" data-social="tw" ng-click="shareSite($event)" ng-src="{{ store.data.assets.tw_icon.src }}" alt="" /></span>',
                '<span class="line"></span>',
                "</div>",
                '<div id="audio" ng-click="toggleSound($event)">',
                '<img ng-src="{{ store.data.assets.audio_icon.src }}" alt="" />',
                "</div>",
                '<div id="lang-switch" class="{{ store.lang }}">',
                '<a class="lang-it" ng-click="changeLang($event)" data-lang="it"><span class="timsans-bold">It</span></a>',
                '<a class="lang-en" ng-click="changeLang($event)" data-lang="en"><span class="timsans-bold">En</span></a>',
                "</div>",
                '<div id="nav"></div>',
                '<div id="ex-link"><a href="http://www.mausoleodiaugusto.it/" target="_blank"><span class="timsans-bold">{{ store.data.locale.ui.website[store.lang] }}</span></a> <span class="mask"></span> <span class="line"></span> </div>',
                '<div id="alert" class="{{ store.lang }}">',
                '<div class="alert-wrap it">',
                '<span class="alert-row"><span class="timsans-bold">I modelli 3d presenti in questo sito sono riproduzioni<br>di fantasia e hanno un puro scopo illustrativo.</span></span>',
                "</div>",
                '<div class="alert-wrap en">',
                '<span class="alert-row"><span class="timsans-bold">The 3d models displayed on this website are made-up<br>images and have illustrative purposes only.</span></span>',
                "</div>",
                "</div>",
                '<div id="cookie" class="{{ store.lang }} cookie-tween" ng-if="store.cookie==false">',
                '<div class="cookie-wrap">',
                "<table>",
                "<tr>",
                '<td class="cookie-body-cell"> <span class="timsans-bold" ng-bind-html="store.data.locale.cookie.body[store.lang]"> </span> </td>',
                '<td class="cookie-cta-cell"> <a href="#" ng-click="acceptCookie($event)"><span class="timsans-bold" ng-bind-html="store.data.locale.cookie.cta[store.lang]"> </span></a> </td>',
                "</tr>",
                "</table>",
                "</div>",
                "</div>",
                "</div>",
            ]
                .join()
                .replace(/,/g, ""),
            replace: true,
            restrict: "E",
            link: function ($scope, $element, attrs, controller) {
                var intro = true,
                    $alert,
                    mobile = MobileBrowser.get();
                TweenMax.set(
                    [$element.find("#nav "), $element.find("#logos "), $element.find("#social "), $element.find("#ex-link "), $element.find("#audio "), $element.find("#lang-switch "), $element.find("#alert "), $element.find("#hamb-icon ")],
                    { autoAlpha: 0 }
                );
                $timeout(function () {
                    $alert = $element.find("#alert ." + $scope.store.lang + " .alert-row");
                    $alert.splitLetters();
                    $alert.data({
                        timeline: new TimelineMax({
                            tweens: [TweenMax.allFrom($alert.data("store"), 0.5, { y: 15, autoAlpha: 0, ease: Cubic.easeOut }, 0.02)],
                            onReverseComplete: function () {
                                $element.find("#alert ").remove();
                            },
                        }),
                    });
                    TweenMax.set($element.find("#alert "), { autoAlpha: 1 });
                });
                $scope.$watch("store.data.locale", function (locale) {
                    if (!locale) return;
                    $scope.getCookie();
                });
                $scope.$watch("store.loaded", function (loaded) {
                    if (!loaded) return;
                    $timeout(function () {
                        $alert.data("timeline").reverse();
                    }, 600);
                    $element
                        .find("#hamb-icon")
                        .on("mouseleave", function () {
                            if (intro || mobile) return;
                            if (!$scope.store.menuOpen) {
                                TweenMax.killChildTweensOf($element.find(".icon-line-1"));
                                TweenMax.killChildTweensOf($element.find(".icon-line-2"));
                                TweenMax.killChildTweensOf($element.find(".icon-line-3"));
                                new TimelineMax({
                                    tweens: [
                                        new TimelineMax({
                                            tweens: [
                                                TweenMax.to($element.find(".icon-line-3-l"), 0.8, { x: 0, scaleX: 1, force3D: true, ease: Expo.easeOut }),
                                                TweenMax.to($element.find(".icon-line-3-r"), 0.8, { x: -40, scaleX: 1, force3D: true, ease: Expo.easeOut }),
                                            ],
                                        }),
                                        new TimelineMax({
                                            tweens: [
                                                TweenMax.to($element.find(".icon-line-2-l"), 0.8, { x: 0, scaleX: 1, force3D: true, ease: Expo.easeOut }),
                                                TweenMax.to($element.find(".icon-line-2-r"), 0.8, { x: -40, scaleX: 1, force3D: true, ease: Expo.easeOut }),
                                            ],
                                        }),
                                        new TimelineMax({
                                            tweens: [
                                                TweenMax.to($element.find(".icon-line-1-l"), 0.8, { x: 0, scaleX: 1, force3D: true, ease: Expo.easeOut }),
                                                TweenMax.to($element.find(".icon-line-1-r"), 0.8, { x: -40, scaleX: 1, force3D: true, ease: Expo.easeOut }),
                                            ],
                                        }),
                                    ],
                                    stagger: 0.08,
                                });
                            } else {
                                TweenMax.killChildTweensOf($element.find(".cl1"));
                                TweenMax.killChildTweensOf($element.find(".cr1"));
                                TweenMax.killChildTweensOf($element.find(".cl2"));
                                TweenMax.killChildTweensOf($element.find(".cr2"));
                                new TimelineMax({
                                    tweens: [
                                        new TimelineMax({
                                            tweens: [
                                                TweenMax.to($element.find(".cl2 span"), 0.8, { x: -30, scaleX: 0, force3D: true, ease: Expo.easeOut }),
                                                TweenMax.to($element.find(".cr2 span"), 0.8, { x: 30, scaleX: 0, force3D: true, ease: Expo.easeOut }),
                                            ],
                                            stagger: 0.08,
                                        }),
                                        new TimelineMax({
                                            tweens: [
                                                TweenMax.to($element.find(".cl1 span"), 0.8, { x: 0, scaleX: 1, force3D: true, ease: Expo.easeOut }),
                                                TweenMax.to($element.find(".cr1 span"), 0.8, { x: 0, scaleX: 1, force3D: true, ease: Expo.easeOut }),
                                            ],
                                            stagger: 0.08,
                                        }),
                                    ],
                                });
                            }
                        })
                        .on("mouseenter", function () {
                            if (intro || mobile) return;
                            if (!$scope.store.menuOpen) {
                                TweenMax.killChildTweensOf($element.find(".icon-line-1"));
                                TweenMax.killChildTweensOf($element.find(".icon-line-2"));
                                TweenMax.killChildTweensOf($element.find(".icon-line-3"));
                                new TimelineMax({
                                    tweens: [
                                        new TimelineMax({
                                            tweens: [
                                                TweenMax.to($element.find(".icon-line-1-l"), 0.8, { x: 40, scaleX: 1, force3D: true, ease: Expo.easeOut }),
                                                TweenMax.to($element.find(".icon-line-1-r"), 0.8, { x: 0, scaleX: 1, force3D: true, ease: Expo.easeOut }),
                                            ],
                                        }),
                                        new TimelineMax({
                                            tweens: [
                                                TweenMax.to($element.find(".icon-line-2-l"), 0.8, { x: 40, scaleX: 1, force3D: true, ease: Expo.easeOut }),
                                                TweenMax.to($element.find(".icon-line-2-r"), 0.8, { x: 0, scaleX: 1, force3D: true, ease: Expo.easeOut }),
                                            ],
                                        }),
                                        new TimelineMax({
                                            tweens: [
                                                TweenMax.to($element.find(".icon-line-3-l"), 0.8, { x: 40, scaleX: 1, force3D: true, ease: Expo.easeOut }),
                                                TweenMax.to($element.find(".icon-line-3-r"), 0.8, { x: 0, scaleX: 1, force3D: true, ease: Expo.easeOut }),
                                            ],
                                        }),
                                    ],
                                    stagger: 0.08,
                                });
                            } else {
                                TweenMax.killChildTweensOf($element.find(".cl1"));
                                TweenMax.killChildTweensOf($element.find(".cr1"));
                                TweenMax.killChildTweensOf($element.find(".cl2"));
                                TweenMax.killChildTweensOf($element.find(".cr2"));
                                new TimelineMax({
                                    tweens: [
                                        new TimelineMax({
                                            tweens: [
                                                TweenMax.to($element.find(".cl1 span"), 0.8, { x: 30, scaleX: 0, force3D: true, ease: Expo.easeOut }),
                                                TweenMax.to($element.find(".cr1 span"), 0.8, { x: -30, scaleX: 0, force3D: true, ease: Expo.easeOut }),
                                            ],
                                            stagger: 0.08,
                                        }),
                                        new TimelineMax({
                                            tweens: [
                                                TweenMax.to($element.find(".cl2 span"), 0.8, { x: 0, scaleX: 1, force3D: true, ease: Expo.easeOut }),
                                                TweenMax.to($element.find(".cr2 span"), 0.8, { x: 0, scaleX: 1, force3D: true, ease: Expo.easeOut }),
                                            ],
                                            stagger: 0.08,
                                        }),
                                    ],
                                });
                            }
                        });
                    var item,
                        index,
                        items = $scope.store.data.book,
                        width = items.length * 20;
                    underscoreMin.each(items, function (item, i) {
                        item = $(['<div class="item">', '<div class="base"></div>', '<div class="line"></div>', "</div>"].join().replace(/,/g, ""));
                        item.on("mouseleave", function (e) {
                            new TimelineMax({ tweens: [TweenMax.to($(e.currentTarget).find(".base"), 1, { y: 20, force3D: true, ease: Cubic.easeOut })] });
                        })
                            .on("mouseenter", function (e) {
                                if (mobile) return;
                                new TimelineMax({ tweens: [TweenMax.to($(e.currentTarget).find(".base"), 0.8, { y: 0, force3D: true, ease: Expo.easeOut })] });
                            })
                            .on("click", function (e) {
                                index = $(e.currentTarget).index();
                                $scope.changeChapter({ index: index, snap: false });
                            });
                        TweenMax.set(item.find(".base"), { y: 40 });
                        TweenMax.set(item.find(".line"), { y: 40 });
                        $("#nav")
                            .append(item)
                            .css({ marginLeft: -width / 2 });
                    });
                    var $exLink = $element.find("#ex-link"),
                        exLinkTimeline = new TimelineMax({
                            tweens: [
                                TweenMax.to($exLink.find(".line"), 0.9, {
                                    bezier: {
                                        curviness: 0,
                                        values: [
                                            { x: 0, width: 160 },
                                            { x: 35, width: 125 },
                                        ],
                                    },
                                    force3D: true,
                                    ease: Expo.easeInOut,
                                }),
                            ],
                            paused: true,
                        });
                    if (!mobile)
                        $exLink
                            .on("mouseenter", function () {
                                if (intro) return;
                                exLinkTimeline.play();
                            })
                            .on("mouseleave", function () {
                                if (intro) return;
                                exLinkTimeline.reverse();
                            });
                });
                controller.listen(Events.MENU_OPEN, function (e, open) {
                    if (open)
                        new TimelineMax({
                            tweens: [
                                new TimelineMax({
                                    tweens: [
                                        new TimelineMax({
                                            tweens: [
                                                new TimelineMax({
                                                    tweens: [
                                                        TweenMax.to($element.find(".icon-line-3-l"), 0, { x: 0, scaleX: 1, force3D: true, ease: Expo.easeOut }),
                                                        TweenMax.to($element.find(".icon-line-3-r"), 0, { x: -40, scaleX: 1, force3D: true, ease: Expo.easeOut }),
                                                    ],
                                                }),
                                                new TimelineMax({
                                                    tweens: [
                                                        TweenMax.to($element.find(".icon-line-2-l"), 0, { x: 0, scaleX: 1, force3D: true, ease: Expo.easeOut }),
                                                        TweenMax.to($element.find(".icon-line-2-r"), 0, { x: -40, scaleX: 1, force3D: true, ease: Expo.easeOut }),
                                                    ],
                                                }),
                                                new TimelineMax({
                                                    tweens: [
                                                        TweenMax.to($element.find(".icon-line-1-l"), 0, { x: 0, scaleX: 1, force3D: true, ease: Expo.easeOut }),
                                                        TweenMax.to($element.find(".icon-line-1-r"), 0, { x: -40, scaleX: 1, force3D: true, ease: Expo.easeOut }),
                                                    ],
                                                }),
                                            ],
                                        }),
                                        new TimelineMax({
                                            tweens: [
                                                TweenMax.to($element.find(".icon-line-1"), 0.8, { x: 30, scaleX: 0, force3D: true, ease: Expo.easeOut }),
                                                TweenMax.to($element.find(".icon-line-2"), 0.8, { x: 30, scaleX: 0, force3D: true, ease: Expo.easeOut }),
                                                TweenMax.to($element.find(".icon-line-3"), 0.8, { x: 30, scaleX: 0, force3D: true, ease: Expo.easeOut }),
                                            ],
                                            stagger: 0.08,
                                        }),
                                    ],
                                }),
                                new TimelineMax({
                                    tweens: [
                                        new TimelineMax({
                                            tweens: [
                                                TweenMax.to($element.find(".cl2 span"), 0.8, { x: -30, scaleX: 0, force3D: true, ease: Expo.easeOut }),
                                                TweenMax.to($element.find(".cr2 span"), 0.8, { x: 30, scaleX: 0, force3D: true, ease: Expo.easeOut }),
                                            ],
                                            stagger: 0.08,
                                        }),
                                        new TimelineMax({
                                            tweens: [
                                                TweenMax.to($element.find(".cl1 span"), 0.8, { x: 0, scaleX: 1, force3D: true, ease: Expo.easeOut }),
                                                TweenMax.to($element.find(".cr1 span"), 0.8, { x: 0, scaleX: 1, force3D: true, ease: Expo.easeOut }),
                                            ],
                                            stagger: 0.08,
                                        }),
                                    ],
                                }),
                            ],
                            stagger: 0.08,
                        });
                    else
                        new TimelineMax({
                            tweens: [
                                new TimelineMax({
                                    tweens: [
                                        new TimelineMax({
                                            tweens: [
                                                TweenMax.to($element.find(".cl2 span"), 0.8, { x: -30, scaleX: 0, force3D: true, ease: Expo.easeOut }),
                                                TweenMax.to($element.find(".cr2 span"), 0.8, { x: 30, scaleX: 0, force3D: true, ease: Expo.easeOut }),
                                            ],
                                            stagger: 0.08,
                                        }),
                                        new TimelineMax({
                                            tweens: [
                                                TweenMax.to($element.find(".cl1 span"), 0.8, { x: -30, scaleX: 0, force3D: true, ease: Expo.easeOut }),
                                                TweenMax.to($element.find(".cr1 span"), 0.8, { x: 30, scaleX: 0, force3D: true, ease: Expo.easeOut }),
                                            ],
                                            stagger: 0.08,
                                        }),
                                    ],
                                }),
                                new TimelineMax({
                                    tweens: [
                                        new TimelineMax({
                                            tweens: [
                                                TweenMax.to($element.find(".icon-line-3"), 0.8, { x: 0, scaleX: 1, force3D: true, ease: Expo.easeOut }),
                                                TweenMax.to($element.find(".icon-line-2"), 0.8, { x: 0, scaleX: 1, force3D: true, ease: Expo.easeOut }),
                                                TweenMax.to($element.find(".icon-line-1"), 0.8, { x: 0, scaleX: 1, force3D: true, ease: Expo.easeOut }),
                                            ],
                                            stagger: 0.08,
                                        }),
                                    ],
                                }),
                            ],
                            stagger: 0.08,
                        });
                });
                controller.listen(Events.LEAF_OPEN, function (e, open) {
                    if (underscoreMin.isUndefined(open)) return;
                    if (open)
                        new TimelineMax({
                            tweens: [
                                TweenMax.to($element.find(".icon-line-3"), 0.8, { x: -30, scaleX: 0, force3D: true, ease: Expo.easeOut }),
                                TweenMax.to($element.find(".icon-line-2"), 0.8, { x: -30, scaleX: 0, force3D: true, ease: Expo.easeOut }),
                                TweenMax.to($element.find(".icon-line-1"), 0.8, { x: -30, scaleX: 0, force3D: true, ease: Expo.easeOut }),
                            ],
                            stagger: 0.08,
                            onComplete: function () {
                                TweenMax.set($element.find("#hamb-icon"), { autoAlpha: 0 });
                            },
                        });
                    else
                        new TimelineMax({
                            tweens: [
                                TweenMax.to($element.find(".icon-line-1"), 0.8, { x: 0, scaleX: 1, force3D: true, ease: Expo.easeOut }),
                                TweenMax.to($element.find(".icon-line-2"), 0.8, { x: 0, scaleX: 1, force3D: true, ease: Expo.easeOut }),
                                TweenMax.to($element.find(".icon-line-3"), 0.8, { x: 0, scaleX: 1, force3D: true, ease: Expo.easeOut }),
                            ],
                            stagger: 0.08,
                            delay: 0.5,
                            onStart: function () {
                                TweenMax.set($element.find("#hamb-icon"), { autoAlpha: 1 });
                            },
                        });
                });
                controller.listen(Events.CHANGE_STATE, function (e, state) {
                    if (!state.to || $scope.store.intro) return;
                    if (!$scope.store.cookie) $scope.acceptCookie();
                    var index = state.options.index,
                        items = $("#nav .item"),
                        current = items.eq(index);
                    if (intro) {
                        new TimelineMax({
                            tweens: [
                                TweenMax.allTo(items.find(".base"), 1, { y: 20, force3D: true, ease: Cubic.easeInOut }, 0.12),
                                new TimelineMax({
                                    tweens: [TweenMax.to(current.find(".base"), 1, { y: 0, force3D: true, ease: Cubic.easeInOut }), TweenMax.to(current.find(".line"), 1, { y: 0, force3D: true, ease: Cubic.easeInOut })],
                                    stagger: 0.15,
                                }),
                            ],
                            stagger: 0.15,
                            delay: 4,
                            onComplete: function () {
                                intro = false;
                            },
                        });
                    } else new TimelineMax({ tweens: [new TimelineMax({ tweens: [TweenMax.to(current.find(".base"), 1, { y: 0, force3D: true, ease: Cubic.easeInOut }), TweenMax.to(current.find(".line"), 1, { y: 0, force3D: true, ease: Cubic.easeInOut })], stagger: 0.15 }), new TimelineMax({ tweens: [TweenMax.to(current.siblings().find(".line"), 1, { y: 40, force3D: true, ease: Cubic.easeInOut }), TweenMax.to(current.siblings().find(".base"), 1, { y: 20, force3D: true, ease: Cubic.easeInOut })], stagger: 0.15 })] });
                });
            },
        };
    }
    function introTween($timeout, MobileBrowser) {
        return {
            enter: function ($element, done) {
                var $el = $element,
                    mobile = MobileBrowser.get(),
                    ctaTweens = [],
                    h2Tweens = [],
                    h1Tweens = [],
                    pTweens = [],
                    tweens = [],
                    stagger = 0,
                    store;
                var index, $letter, y;
                store = $.shuffle($el.find("h1").data("store"));
                underscoreMin.each(store, function (letter) {
                    ($letter = $(letter)), (index = $letter.index()), (y = index % 2 == 0 ? -150 : 150);
                    h1Tweens.push(TweenMax.from($letter, 3, { y: y, autoAlpha: 0, force3D: true, ease: Expo.easeInOut }));
                });
                store = $el.find("h2").data("store");
                underscoreMin.each(store, function (letter) {
                    ($letter = $(letter)), (index = $letter.index()), (y = 60);
                    h2Tweens.push(TweenMax.from($letter, 1, { y: y, force3D: true, ease: Cubic.easeInOut }));
                });
                tweens.push(new TimelineMax({ tweens: h2Tweens, stagger: !mobile ? 0.025 : 0.025 }));
                store = $el.find("p").data("store");
                underscoreMin.each(store, function (letter) {
                    ($letter = $(letter)), (index = $letter.index()), (y = 60);
                    pTweens.push(TweenMax.from($letter, 1, { y: y, force3D: true, ease: Cubic.easeInOut }));
                });
                tweens.push(new TimelineMax({ tweens: pTweens, stagger: !mobile ? 0.015 : 0.015 }));
                ctaTweens.push(new TimelineMax({ tweens: [TweenMax.from($el.find(".cta"), 1, { y: 30, ease: Cubic.easeOut }), TweenMax.from($el.find(".cta"), 1, { autoAlpha: 0, ease: Cubic.easeInOut })] }));
                new TimelineMax({
                    tweens: [new TimelineMax({ tweens: h1Tweens, stagger: 0.045 }), new TimelineMax({ tweens: [new TimelineMax({ tweens: tweens, stagger: 0.35 }), new TimelineMax({ tweens: ctaTweens })], stagger: 1.25 })],
                    stagger: 2.5,
                    onComplete: done,
                });
            },
            leave: function ($element, done) {
                var $el = $element,
                    mobile = MobileBrowser.get(),
                    ctaTweens = [],
                    h2Tweens = [],
                    h1Tweens = [],
                    pTweens = [],
                    tweens = [],
                    stagger = 0,
                    store;
                var index, $letter, y;
                ctaTweens.push(new TimelineMax({ tweens: [TweenMax.to($el.find(".cta"), 1, { y: 30, ease: Cubic.easeIn }), TweenMax.to($el.find(".cta"), 1, { autoAlpha: 0, ease: Cubic.easeInOut })] }));
                store = $el.find("p").data("store");
                underscoreMin.each(store, function (letter) {
                    ($letter = $(letter)), (index = $letter.index()), (y = 60);
                    pTweens.push(TweenMax.to($letter, 1, { y: y, force3D: true, ease: Cubic.easeInOut }));
                });
                tweens.push(new TimelineMax({ tweens: pTweens, stagger: !mobile ? 0.015 : 0.015 }));
                store = $el.find("h2").data("store");
                underscoreMin.each(store, function (letter) {
                    ($letter = $(letter)), (index = $letter.index()), (y = -60);
                    h2Tweens.push(TweenMax.to($letter, 1, { y: y, force3D: true, ease: Cubic.easeInOut }));
                });
                tweens.push(new TimelineMax({ tweens: h2Tweens, stagger: !mobile ? 0.025 : 0.025 }));
                store = $.shuffle($el.find("h1").data("store"));
                underscoreMin.each(store, function (letter) {
                    ($letter = $(letter)), (index = $letter.index()), (y = index % 2 == 0 ? -150 : 150);
                    h1Tweens.push(TweenMax.to($letter, 1, { y: y, autoAlpha: 0, force3D: true, ease: Cubic.easeInOut }));
                });
                tweens.push(new TimelineMax({ tweens: h1Tweens, stagger: 0.025 }));
                new TimelineMax({ tweens: [new TimelineMax({ tweens: ctaTweens }), new TimelineMax({ tweens: tweens, stagger: !mobile ? 0.15 : 0.15 })], stagger: 0.35, onComplete: done });
            },
        };
    }

    function appuiTween() {
        return {
            addClass: function ($element, className, done) {
                var $el = $element,
                    tweens = [];
                tweens.push(
                    new TimelineMax({
                        tweens: [
                            TweenMax.fromTo(
                                $el.find("#hamb-icon .icon-line-1"),
                                1.4,
                                { x: -60, scaleX: 0 },
                                {
                                    bezier: {
                                        curviness: 0,
                                        values: [
                                            { x: -40, scaleX: 1.5 },
                                            { x: 0, scaleX: 1 },
                                        ],
                                    },
                                    force3D: true,
                                    ease: Expo.easeInOut,
                                }
                            ),
                            TweenMax.fromTo(
                                $el.find("#hamb-icon .icon-line-2"),
                                1.4,
                                { x: -60, scaleX: 0 },
                                {
                                    bezier: {
                                        curviness: 0,
                                        values: [
                                            { x: -40, scaleX: 1.5 },
                                            { x: 0, scaleX: 1 },
                                        ],
                                    },
                                    force3D: true,
                                    ease: Expo.easeInOut,
                                }
                            ),
                            TweenMax.fromTo(
                                $el.find("#hamb-icon .icon-line-3"),
                                1.4,
                                { x: -60, scaleX: 0 },
                                {
                                    bezier: {
                                        curviness: 0,
                                        values: [
                                            { x: -40, scaleX: 1.5 },
                                            { x: 0, scaleX: 1 },
                                        ],
                                    },
                                    force3D: true,
                                    ease: Expo.easeInOut,
                                }
                            ),
                        ],
                        stagger: 0.1,
                    })
                );
                tweens.push(
                    new TimelineMax({
                        tweens: [TweenMax.from($el.find("#logos #capitale-logo"), 1, { y: -50, force3D: true, ease: Cubic.easeInOut }), TweenMax.from($el.find("#logos #tim-logo"), 1, { y: -50, force3D: true, ease: Cubic.easeInOut })],
                        stagger: 0.12,
                    })
                );
                tweens.push(
                    new TimelineMax({
                        tweens: [
                            TweenMax.from($el.find("#social .tw-icon"), 1.2, { y: 50, force3D: true, ease: Expo.easeInOut }),
                            TweenMax.from($el.find("#social .gp-icon"), 1.2, { y: 50, force3D: true, ease: Expo.easeInOut }),
                            TweenMax.from($el.find("#social .fb-icon"), 1.2, { y: 50, force3D: true, ease: Expo.easeInOut }),
                            TweenMax.from($el.find("#audio"), 1.2, { y: 50, force3D: true, ease: Expo.easeInOut }),
                            TweenMax.from($el.find("#lang-switch"), 1.2, { y: 50, force3D: true, ease: Expo.easeInOut }),
                        ],
                        stagger: 0.1,
                    })
                );
                tweens.push(
                    new TimelineMax({
                        tweens: [
                            TweenMax.from($el.find("#ex-link .mask"), 1.2, { width: "100%", ease: Expo.easeInOut }),
                            TweenMax.fromTo(
                                $el.find("#ex-link .line"),
                                1.2,
                                { x: 180, width: 0 },
                                {
                                    bezier: {
                                        curviness: 0,
                                        values: [
                                            { x: 30, width: 130 },
                                            { x: 0, width: 20 },
                                        ],
                                    },
                                    force3D: true,
                                    ease: Expo.easeInOut,
                                }
                            ),
                        ],
                        stagger: 0.15,
                    })
                );
                TweenMax.set([$el.find("#nav"), $el.find("#logos"), $el.find("#social"), $el.find("#ex-link"), $el.find("#audio"), $el.find("#lang-switch"), $el.find("#hamb-icon")], { autoAlpha: 1 });
                new TimelineMax({ tweens: tweens, stagger: 0.25, delay: 3.5, onComplete: done });
            },
            removeClass: function ($element, className, done) {
                done();
            },
        };
    }
    var menuTimeline = null;
    function menuTween() {
        return {
            addClass: function ($element, className, done) {
                var $el = $element,
                    $holder = $el.find("#menu-holder"),
                    winH = window.innerHeight;
                if (menuTimeline) menuTimeline.kill();
                menuTimeline = new TimelineMax({
                    tweens: [new TimelineMax({ tweens: [TweenMax.fromTo($holder, 1.5, { z: 200 }, { z: 0, ease: Cubic.easeInOut }), TweenMax.fromTo($el, 1.2, { autoAlpha: 0 }, { autoAlpha: 1, ease: Cubic.easeInOut })] })],
                    onComplete: done,
                });
            },
            removeClass: function ($element, className, done) {
                var $el = $($element[0]),
                    $holder = $el.find("#menu-holder"),
                    winH = window.innerHeight;
                if (menuTimeline) menuTimeline.kill();
                menuTimeline = new TimelineMax({ tweens: [new TimelineMax({ tweens: [TweenMax.to($holder, 1.5, { z: 200, ease: Cubic.easeInOut }), TweenMax.to($el, 1, { autoAlpha: 0, ease: Cubic.easeInOut })] })], onComplete: done });
            },
        };
    }
    function finalTween(MobileBrowser) {
        return {
            enter: function ($element, done) {
                var $el = $element,
                    mobile = MobileBrowser.get(),
                    backTweens = [],
                    ctaTweens = [],
                    h1Tweens = [],
                    tweens = [],
                    stagger = 0,
                    store;
                var index, $letter, y;
                backTweens.push(new TimelineMax({ tweens: [TweenMax.from($el.find(".back"), 2, { autoAlpha: 0, ease: Cubic.easeInOut })] }));
                store = $.shuffle($el.find("h1").data("store"));
                underscoreMin.each(store, function (letter) {
                    ($letter = $(letter)), (index = $letter.index()), (y = index % 2 == 0 ? -150 : 150);
                    h1Tweens.push(TweenMax.from($letter, 3, { y: y, autoAlpha: 0, force3D: true, ease: Expo.easeInOut }));
                });
                ctaTweens.push(new TimelineMax({ tweens: [TweenMax.from($el.find(".cta.website"), 1, { y: 30, ease: Cubic.easeOut }), TweenMax.from($el.find(".cta.website"), 1, { autoAlpha: 0, ease: Cubic.easeInOut })] }));
                ctaTweens.push(new TimelineMax({ tweens: [TweenMax.from($el.find(".cta.restart"), 1, { y: 30, ease: Cubic.easeOut }), TweenMax.from($el.find(".cta.restart"), 1, { autoAlpha: 0, ease: Cubic.easeInOut })] }));
                new TimelineMax({ tweens: [new TimelineMax({ tweens: [new TimelineMax({ tweens: h1Tweens, stagger: 0.045 }), new TimelineMax({ tweens: ctaTweens, stagger: 0.35 })], stagger: 3 })], delay: 3 });
            },
            leave: function ($element, done) {
                var $el = $element,
                    mobile = MobileBrowser.get(),
                    backTweens = [],
                    ctaTweens = [],
                    h1Tweens = [],
                    tweens = [],
                    stagger = 0,
                    store;
                var index, $letter, y;
                ctaTweens.push(new TimelineMax({ tweens: [TweenMax.to($el.find(".cta.restart"), 1, { y: 30, ease: Cubic.easeIn }), TweenMax.to($el.find(".cta.restart"), 1, { autoAlpha: 0, ease: Cubic.easeInOut })] }));
                ctaTweens.push(new TimelineMax({ tweens: [TweenMax.to($el.find(".cta.website"), 1, { y: 30, ease: Cubic.easeIn }), TweenMax.to($el.find(".cta.website"), 1, { autoAlpha: 0, ease: Cubic.easeInOut })] }));
                store = $.shuffle($el.find("h1").data("store"));
                underscoreMin.each(store, function (letter) {
                    ($letter = $(letter)), (index = $letter.index()), (y = index % 2 == 0 ? -150 : 150);
                    h1Tweens.push(TweenMax.to($letter, 1, { y: y, autoAlpha: 0, force3D: true, ease: Cubic.easeInOut }));
                });
                tweens.push(new TimelineMax({ tweens: h1Tweens, stagger: 0.025 }));
                backTweens.push(new TimelineMax({ tweens: [TweenMax.to($el.find(".back"), 2, { autoAlpha: 0, ease: Cubic.easeInOut })] }));
                new TimelineMax({ tweens: [new TimelineMax({ tweens: ctaTweens, stagger: 0.35 }), new TimelineMax({ tweens: tweens })], stagger: 0.35, onComplete: done });
            },
        };
    }
    function cookieTween() {
        return {
            enter: function ($element, done) {
                TweenMax.from($element, 0.9, { y: $element.outerHeight(), force3D: true, ease: Cubic.easeInOut, onComplete: done });
            },
            leave: function ($element, done) {
                TweenMax.to($element, 0.9, { y: $element.outerHeight(), force3D: true, ease: Cubic.easeInOut, onComplete: done });
            },
        };
    }
    function router($stateProvider, $urlRouterProvider, $locationProvider) {
        $locationProvider.html5Mode(true);
        $urlRouterProvider.otherwise(function ($injector, $location) {
            var $state = $injector.get("$state");
            $state.go("app.intro");
        });
        $stateProvider.state("app", { abstract: true, url: "/:lang" }).state("app.intro", { url: "/intro" }).state("app.chapter", { url: "/:chapter" });
    }
    var name = "mausoleo";
    var application = index.module(name, ["ui.router", "ngSanitize", "ngAnimate"]);
    application
        .controller("AppController", AppController)
        .controller("CanvasController", CanvasController)
        .service("ShaderParser", ShaderParser)
        .service("MobileBrowser", MobileBrowser)
        .service("ChapterLoader", ChapterLoader)
        .service("CookieService", CookieService)
        .service("SoundManager", SoundManager)
        .service("DataLoader", DataLoader)
        .directive("app3dCanvas", App3dCanvas)
        .directive("app2dCanvas", App2dCanvas)
        .directive("appChapter", AppChapter)
        .directive("appIntro", AppIntro)
        .directive("appFinal", AppFinal)
        .directive("appMenu", AppMenu)
        .directive("appUi", AppUI)
        .animation(".cookie-tween", cookieTween)
        .animation(".appui-tween", appuiTween)
        .animation(".intro-tween", introTween)
        .animation(".final-tween", finalTween)
        .animation(".menu-tween", menuTween)
        .config(router);
    index.element(document).ready(function () {
        index.bootstrap(document, [name]);
    });
});
